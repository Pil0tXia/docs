<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>死锁 - Pil0tXia 的书房</title>
    <meta name="generator" content="VuePress 1.9.2">
    <link rel="icon" href="https://static.pil0txia.com/assets/favicon.ico">
    <script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-57XMHPB9DW"></script>
    <script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-57XMHPB9DW');</script>
    <meta name="description" content="我的学习笔记和技术分享">
    <meta name="keywords" content="pil0txia,it,docs,note,study">
    <meta name="baidu-site-verification" content="code-f37Lv9IIFX">
    
    <link rel="preload" href="/assets/css/0.styles.021fb583.css" as="style"><link rel="preload" href="/assets/js/app.7c22909a.js" as="script"><link rel="preload" href="/assets/js/2.6758ed52.js" as="script"><link rel="preload" href="/assets/js/33.ed53d32c.js" as="script"><link rel="prefetch" href="/assets/js/10.e24f1e40.js"><link rel="prefetch" href="/assets/js/11.05cb0029.js"><link rel="prefetch" href="/assets/js/12.32af8044.js"><link rel="prefetch" href="/assets/js/13.700f1625.js"><link rel="prefetch" href="/assets/js/14.41717448.js"><link rel="prefetch" href="/assets/js/15.ecaf38f1.js"><link rel="prefetch" href="/assets/js/16.f4a2e8fe.js"><link rel="prefetch" href="/assets/js/17.dd141a48.js"><link rel="prefetch" href="/assets/js/18.d4b349b0.js"><link rel="prefetch" href="/assets/js/19.e768f6f2.js"><link rel="prefetch" href="/assets/js/20.258fe436.js"><link rel="prefetch" href="/assets/js/21.e2e83218.js"><link rel="prefetch" href="/assets/js/22.fbef3388.js"><link rel="prefetch" href="/assets/js/23.0823fda8.js"><link rel="prefetch" href="/assets/js/24.f2106677.js"><link rel="prefetch" href="/assets/js/25.d1029eac.js"><link rel="prefetch" href="/assets/js/26.de8ada83.js"><link rel="prefetch" href="/assets/js/27.5542150b.js"><link rel="prefetch" href="/assets/js/28.73bc9881.js"><link rel="prefetch" href="/assets/js/29.dfc6d141.js"><link rel="prefetch" href="/assets/js/3.0aad90a7.js"><link rel="prefetch" href="/assets/js/30.875cb1d3.js"><link rel="prefetch" href="/assets/js/31.12e24a9b.js"><link rel="prefetch" href="/assets/js/32.3e6b9414.js"><link rel="prefetch" href="/assets/js/34.24759155.js"><link rel="prefetch" href="/assets/js/35.46746eb8.js"><link rel="prefetch" href="/assets/js/36.752fb623.js"><link rel="prefetch" href="/assets/js/37.9fbc624d.js"><link rel="prefetch" href="/assets/js/38.e57c3e9a.js"><link rel="prefetch" href="/assets/js/39.fe320339.js"><link rel="prefetch" href="/assets/js/4.3055ae5e.js"><link rel="prefetch" href="/assets/js/40.2cc14361.js"><link rel="prefetch" href="/assets/js/41.69f063eb.js"><link rel="prefetch" href="/assets/js/42.7e2baa49.js"><link rel="prefetch" href="/assets/js/43.db617122.js"><link rel="prefetch" href="/assets/js/44.a1fc3b4c.js"><link rel="prefetch" href="/assets/js/45.966ef14f.js"><link rel="prefetch" href="/assets/js/46.1b8df3ff.js"><link rel="prefetch" href="/assets/js/47.19f52d31.js"><link rel="prefetch" href="/assets/js/48.99209cdd.js"><link rel="prefetch" href="/assets/js/49.e2fcc246.js"><link rel="prefetch" href="/assets/js/5.e24581f1.js"><link rel="prefetch" href="/assets/js/50.1fb68e50.js"><link rel="prefetch" href="/assets/js/51.8fb412d1.js"><link rel="prefetch" href="/assets/js/52.7f71c13a.js"><link rel="prefetch" href="/assets/js/53.a0638f3f.js"><link rel="prefetch" href="/assets/js/54.197b3a4a.js"><link rel="prefetch" href="/assets/js/55.8f0848d5.js"><link rel="prefetch" href="/assets/js/56.2b6c22ee.js"><link rel="prefetch" href="/assets/js/57.d3b95709.js"><link rel="prefetch" href="/assets/js/58.477eda2a.js"><link rel="prefetch" href="/assets/js/59.e0b4407a.js"><link rel="prefetch" href="/assets/js/6.a90a255b.js"><link rel="prefetch" href="/assets/js/60.02ddfe44.js"><link rel="prefetch" href="/assets/js/7.2fb00079.js"><link rel="prefetch" href="/assets/js/8.a4338d2b.js"><link rel="prefetch" href="/assets/js/9.f988ec8a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.021fb583.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="https://static.pil0txia.com/assets/03_3_600p.webp" alt="Pil0tXia 的书房" class="logo"> <span class="site-name can-hide">Pil0tXia 的书房</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="操作系统课程笔记" class="dropdown-title"><a href="/pages/5719ac/" class="link-title">操作系统课程笔记</a> <span class="title" style="display:none;">操作系统课程笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/d1af54/" class="nav-link">第一章 操作系统引论</a></li><li class="dropdown-item"><!----> <a href="/pages/1f0d42/" class="nav-link">第二章 进程的描述与控制</a></li><li class="dropdown-item"><!----> <a href="/pages/9cf689/" class="nav-link">第三章 处理机调度与死锁</a></li><li class="dropdown-item"><!----> <a href="/pages/1253d7/" class="nav-link">第四章 存储器管理</a></li><li class="dropdown-item"><!----> <a href="/pages/f6080a/" class="nav-link">第五章 虚拟存储器</a></li><li class="dropdown-item"><!----> <a href="/pages/a80c85/" class="nav-link">期末考试备考</a></li></ul></div></div><div class="nav-item"><a href="/asm-notes/shorthand/" class="nav-link">汇编语言课程笔记</a></div> <a href="https://github.com/Pil0tXia/docs" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="操作系统课程笔记" class="dropdown-title"><a href="/pages/5719ac/" class="link-title">操作系统课程笔记</a> <span class="title" style="display:none;">操作系统课程笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/d1af54/" class="nav-link">第一章 操作系统引论</a></li><li class="dropdown-item"><!----> <a href="/pages/1f0d42/" class="nav-link">第二章 进程的描述与控制</a></li><li class="dropdown-item"><!----> <a href="/pages/9cf689/" class="nav-link">第三章 处理机调度与死锁</a></li><li class="dropdown-item"><!----> <a href="/pages/1253d7/" class="nav-link">第四章 存储器管理</a></li><li class="dropdown-item"><!----> <a href="/pages/f6080a/" class="nav-link">第五章 虚拟存储器</a></li><li class="dropdown-item"><!----> <a href="/pages/a80c85/" class="nav-link">期末考试备考</a></li></ul></div></div><div class="nav-item"><a href="/asm-notes/shorthand/" class="nav-link">汇编语言课程笔记</a></div> <a href="https://github.com/Pil0tXia/docs" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>关于本文档</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/5719ac/" class="sidebar-link">操作系统课程笔记</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第一章 操作系统引论</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d1af54/" class="sidebar-link">单道批处理</a></li><li><a href="/pages/4722dd/" class="sidebar-link">多道批处理</a></li><li><a href="/pages/d4063c/" class="sidebar-link">并发与并行的区别</a></li><li><a href="/pages/ed294b/" class="sidebar-link">分时操作系统</a></li><li><a href="/pages/f50a2e/" class="sidebar-link">实时操作系统</a></li><li><a href="/pages/bc61d3/" class="sidebar-link">操作系统的四个基础特性</a></li><li><a href="/pages/4d01a9/" class="sidebar-link">现代OS的基本单位</a></li><li><a href="/pages/ebecb5/" class="sidebar-link">作业1</a></li><li><a href="/pages/5203e5/" class="sidebar-link">内核</a></li><li><a href="/pages/ee322f/" class="sidebar-link">中断和异常</a></li><li><a href="/pages/1501a6/" class="sidebar-link">系统调用</a></li><li><a href="/pages/1fd856/" class="sidebar-link">冷启动和热启动</a></li><li><a href="/pages/e900d8/" class="sidebar-link">补充资料</a></li><li><a href="/pages/3f251a/" class="sidebar-link">作业2</a></li><li><a href="/pages/82c444/" class="sidebar-link">附言</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第二章 进程的描述与控制</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/1f0d42/" class="sidebar-link">程序的基本概念</a></li><li><a href="/pages/a98e4b/" class="sidebar-link">进程的基本概念</a></li><li><a href="/pages/ec4dab/" class="sidebar-link">作业</a></li><li><a href="/pages/d00b2a/" class="sidebar-link">进程控制</a></li><li><a href="/pages/f0811a/" class="sidebar-link">进程的特征</a></li><li><a href="/pages/1da972/" class="sidebar-link">进程同步</a></li><li><a href="/pages/8c5da1/" class="sidebar-link">进程通信</a></li><li><a href="/pages/8676b4/" class="sidebar-link">线程</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>第三章 处理机调度与死锁</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/9cf689/" class="sidebar-link">处理机调度的层次</a></li><li><a href="/pages/053628/" class="sidebar-link">队列调度模型</a></li><li><a href="/pages/79d126/" class="sidebar-link">选择调度算法的原则</a></li><li><a href="/pages/e86493/" class="sidebar-link">调度算法</a></li><li><a href="/pages/15347c/" aria-current="page" class="active sidebar-link">死锁</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/15347c/#出现死锁的场景" class="sidebar-link">出现死锁的场景</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/15347c/#进程推进顺序不当" class="sidebar-link">进程推进顺序不当</a></li><li class="sidebar-sub-header level3"><a href="/pages/15347c/#资源竞争" class="sidebar-link">资源竞争</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/15347c/#产生死锁的四个必要条件" class="sidebar-link">产生死锁的四个必要条件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/15347c/#互斥" class="sidebar-link">互斥</a></li><li class="sidebar-sub-header level3"><a href="/pages/15347c/#非抢占" class="sidebar-link">非抢占</a></li><li class="sidebar-sub-header level3"><a href="/pages/15347c/#请求和占有" class="sidebar-link">请求和占有</a></li><li class="sidebar-sub-header level3"><a href="/pages/15347c/#环路循环等待" class="sidebar-link">环路循环等待</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/15347c/#预防死锁" class="sidebar-link">预防死锁</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/15347c/#破坏互斥条件" class="sidebar-link">破坏互斥条件</a></li><li class="sidebar-sub-header level3"><a href="/pages/15347c/#破坏非抢占条件" class="sidebar-link">破坏非抢占条件</a></li><li class="sidebar-sub-header level3"><a href="/pages/15347c/#破坏-请求和占有-条件" class="sidebar-link">破坏“请求和占有”条件</a></li><li class="sidebar-sub-header level3"><a href="/pages/15347c/#破坏-环路循环等待-条件" class="sidebar-link">破坏“环路循环等待”条件</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/15347c/#避免死锁" class="sidebar-link">避免死锁</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/15347c/#进程-资源分配图" class="sidebar-link">进程-资源分配图</a></li><li class="sidebar-sub-header level3"><a href="/pages/15347c/#银行家算法" class="sidebar-link">银行家算法</a></li><li class="sidebar-sub-header level4"><a href="/pages/15347c/#银行家算法案例" class="sidebar-link">银行家算法案例</a></li><li class="sidebar-sub-header level4"><a href="/pages/15347c/#银行家算法过程" class="sidebar-link">银行家算法过程</a></li><li class="sidebar-sub-header level4"><a href="/pages/15347c/#例题1" class="sidebar-link">例题1</a></li><li class="sidebar-sub-header level4"><a href="/pages/15347c/#例题2" class="sidebar-link">例题2</a></li><li class="sidebar-sub-header level4"><a href="/pages/15347c/#例题3" class="sidebar-link">例题3</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/15347c/#检测死锁" class="sidebar-link">检测死锁</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/15347c/#简化进程-资源分配图" class="sidebar-link">简化进程-资源分配图</a></li><li class="sidebar-sub-header level4"><a href="/pages/15347c/#各类资源只有一个" class="sidebar-link">各类资源只有一个</a></li><li class="sidebar-sub-header level4"><a href="/pages/15347c/#各类资源有多个" class="sidebar-link">各类资源有多个</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/15347c/#解除死锁" class="sidebar-link">解除死锁</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/15347c/#资源剥夺法" class="sidebar-link">资源剥夺法</a></li><li class="sidebar-sub-header level3"><a href="/pages/15347c/#终止进程法" class="sidebar-link">终止进程法</a></li><li class="sidebar-sub-header level3"><a href="/pages/15347c/#进程回退法" class="sidebar-link">进程回退法</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第四章 存储器管理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/1253d7/" class="sidebar-link">多级存储器结构</a></li><li><a href="/pages/ae65e4/" class="sidebar-link">程序的装入与链接</a></li><li><a href="/pages/e66b46/" class="sidebar-link">连续内存分配</a></li><li><a href="/pages/a8d561/" class="sidebar-link">非连续内存分配</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第五章 虚拟存储器</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/f6080a/" class="sidebar-link">虚拟存储器概述</a></li><li><a href="/pages/9b0e23/" class="sidebar-link">请求分页存储管理方式</a></li><li><a href="/pages/985167/" class="sidebar-link">页面置换算法</a></li><li><a href="/pages/3be910/" class="sidebar-link">内存分配策略和分配算法</a></li><li><a href="/pages/8b5fe6/" class="sidebar-link">抖动与工作集</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第六章 输入输出系统</span> <!----></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第七章 文件管理</span> <!----></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>期末考试备考</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/a80c85/" class="sidebar-link">考试题型</a></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>操作系统</span></li><li data-v-06225672><span data-v-06225672>第三章 处理机调度与死锁</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://www.pil0txia.com" target="_blank" title="作者" class="beLink" data-v-06225672>Pil0tXia</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-01-05</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><!---->死锁<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h1 id="死锁"><a href="#死锁" class="header-anchor">#</a> 死锁</h1> <h2 id="出现死锁的场景"><a href="#出现死锁的场景" class="header-anchor">#</a> 出现死锁的场景</h2> <h3 id="进程推进顺序不当"><a href="#进程推进顺序不当" class="header-anchor">#</a> 进程推进顺序不当</h3> <p><img src="https://static.pil0txia.com/picgo/IMG_20221117_102117.jpg" alt="IMG_20221117_102117"></p> <h3 id="资源竞争"><a href="#资源竞争" class="header-anchor">#</a> 资源竞争</h3> <p><img src="https://static.pil0txia.com/picgo/IMG_20221117_102345.jpg" alt="IMG_20221117_102345"></p> <h2 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="header-anchor">#</a> 产生死锁的四个必要条件</h2> <h3 id="互斥"><a href="#互斥" class="header-anchor">#</a> 互斥</h3> <p>进程互斥使用资源。因为如果是可以共享使用的资源，多个进程直接同时使用就好，不会陷入等待的僵局。</p> <h3 id="非抢占"><a href="#非抢占" class="header-anchor">#</a> 非抢占</h3> <p>一个进程不能抢夺其他进程占有的资源。因为如果其它进程可以抢占资源，那么就是直接拿到资源了，也不会陷入等待的僵局。</p> <h3 id="请求和占有"><a href="#请求和占有" class="header-anchor">#</a> 请求和占有</h3> <p>申请新资源时不释放已占有资源，即要求进程是在占有（holding）至少一个资源的前提下，请求（waiting）新的资源的。由于新的资源被其它进程占有，此时，发出请求的进程就会带着自己占有的资源进入阻塞状态。假设 P1，P2 分别都需要 R1，R2 资源，如果是下面这种方式：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token constant">P1</span><span class="token operator">:</span>          <span class="token constant">P2</span><span class="token operator">:</span>
<span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R1</span><span class="token punctuation">)</span>  <span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R2</span><span class="token punctuation">)</span>
<span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R2</span><span class="token punctuation">)</span>  <span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R1</span><span class="token punctuation">)</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果 P1 请求到了 R1 资源之后，P2 请求到了 R2 资源，那么此后不管是哪个进程再次请求资源，都是在占有资源的前提下请求的，此时就会带着这个资源陷入阻塞状态。P1 和 P2 需要互相等待，发生了死锁。</p> <p>换一种情况：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token constant">P1</span><span class="token operator">:</span>          <span class="token constant">P2</span><span class="token operator">:</span>
<span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R1</span><span class="token punctuation">)</span>  <span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R1</span><span class="token punctuation">)</span>
<span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R2</span><span class="token punctuation">)</span>  <span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R2</span><span class="token punctuation">)</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果 P1 请求到了 R1 资源，那么 P2 在请求 R1 的时候虽然也会阻塞，但是<strong>是在不占有资源的情况下阻塞的</strong>，不像之前那样占有 R2。所以，此时 P1 可以正常完成任务并释放 R1，P2 拿到 R1 之后再去执行任务。这种情况就不会发生死锁。</p> <h3 id="环路循环等待"><a href="#环路循环等待" class="header-anchor">#</a> 环路循环等待</h3> <p>要求存在一条进程资源的循环等待链，链中的每一个进程占有的资源同时被另一个进程所请求。</p> <p>[P0，P1，P2，…Pn] 中的 P0 正在等待 P1 占用的资源，P1 正在等待 P2 占用的资源......Pn 正在等待 P0 占用的资源。</p> <p>发生死锁时一定有循环等待（因为是死锁的必要条件），但是发生循环等待的时候不一定会发生死锁。这是因为，如果循环等待链中的 P1 和 链外的 P6 都占有某个进程 P2 请求的资源，那么 P2 完全可以选择不等待 P1 释放该资源，而是等待 P6 释放资源。这样就不会发生死锁了。</p> <h2 id="预防死锁"><a href="#预防死锁" class="header-anchor">#</a> 预防死锁</h2> <p>通过设置某些限制条件，以牺牲资源利用率和系统吞吐量为代价，破坏产生死锁的四个必要条件中的一个或几个。特点是简单、限制条件严格，有可能导致资源利用率和系统吞吐量低</p> <h3 id="破坏互斥条件"><a href="#破坏互斥条件" class="header-anchor">#</a> 破坏互斥条件</h3> <p>如果可以把某个互斥资源转化成共享资源，那么就不存在互相等待资源的情况了，也就不会发生死锁。</p> <h3 id="破坏非抢占条件"><a href="#破坏非抢占条件" class="header-anchor">#</a> 破坏非抢占条件</h3> <p>如果资源是可以抢占的，那么在进程需要资源的时候，就可以直接抢占了，不存在互相等待资源的情况，也就不会发生死锁。要破坏非抢占条件，做到可抢占，可以从两个角度（方案）考虑：</p> <ul><li>从占有资源的进程的角度考虑，如果它请求不到新的资源，那么它必须立即释放占有的全部资源，以后需要的时候重新申请</li> <li>从请求资源的进程的角度考虑，如果它需要请求资源，那么操作系统会帮助它抢占相关资源。比如现在有一个优先级更高的进程，如果是采用优先级调度算法，那么它将有机会在操作系统的帮助下抢占到资源。</li></ul> <p>这种做法的问题在于：</p> <ul><li>实现起来复杂</li> <li>某个占有资源的进程释放占有的全部资源时，可能会导致工作进度丢失</li> <li>反复的申请和释放资源会增加系统开销</li> <li>可能导致饥饿</li></ul> <h3 id="破坏-请求和占有-条件"><a href="#破坏-请求和占有-条件" class="header-anchor">#</a> 破坏 “请求和占有” 条件</h3> <p>所有进程在运行之前，都必须一次性地申请其在整个行过程中的所需的全部资源，此时，若系统有足够的资源分配给某进程，便可把其需要的所有资源分配给该进程，这样，该进程在整个运行期间便不会再提出资源要求。</p> <p>该方法可能导致饥饿现象。若有 ABC 三类进程，A 用到 a 资源，B 用到 b 资源，C 用到 ab 资源，那么 AB 会在运行前事先申请到 ab 资源，如果 AB 源源不断进入就绪队列，那么 C 进程没有办法在运行前拿到 ab 资源，就进入了饥饿状态。</p> <h3 id="破坏-环路循环等待-条件"><a href="#破坏-环路循环等待-条件" class="header-anchor">#</a> 破坏 “环路循环等待” 条件</h3> <p>将所有资源按类型进行线性排队并编号，所有进程必须严格按照序号递增的顺序请求资源，即先请求小编号资源，后请求大编号资源。这样，在形成的资源分配图中，不再出现环路。</p> <p>优点：和前两种相比，资源利用率和吞吐量利用率高</p> <p>缺点：系统中各类资源所分配的序号必须相对稳定，限制了新类型设备的增加；作业（进程）使用各类资源的顺序与系统规定的顺序不同，造成对资源的浪费；为方便用户，系统对用户在编程时所施加的限制条件应尽量少，但必然限制用户简单、自主地编程。</p> <p>以之前的例子讲解：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token constant">P1</span><span class="token operator">:</span>          <span class="token constant">P2</span><span class="token operator">:</span>
<span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R1</span><span class="token punctuation">)</span>  <span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R2</span><span class="token punctuation">)</span>
<span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R2</span><span class="token punctuation">)</span>  <span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R1</span><span class="token punctuation">)</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这种情况下资源请求是无序的，尤其是 P2，它没有按照递增的顺序请求资源，因此很容易发生死锁。但是如果是这种情况：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token constant">P1</span><span class="token operator">:</span>          <span class="token constant">P2</span><span class="token operator">:</span>
<span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R1</span><span class="token punctuation">)</span>  <span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R1</span><span class="token punctuation">)</span>
<span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R2</span><span class="token punctuation">)</span>  <span class="token function">request</span><span class="token punctuation">(</span><span class="token constant">R2</span><span class="token punctuation">)</span> 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>实际上，这里除了破坏 “占有和请求条件” 之外，更重要的是破坏了循环等待条件 —— 因为这里是按照编号递增的顺序请求资源了，不管是 P1 还是 P2，都是先请求小编号的 R1，后请求大编号的 R2，这样的话就不会发生死锁，因为此时两个进程对资源的请求并没有形成一个闭环。</p> <p>也可以拿之前的<a href="/pages/1da972/#五个哲学家进餐问题">哲学家进餐问题</a>解释，如果我们给每个筷子进行编号，规定必须按照编号递增的顺序申请资源，那么从 0 号到 3 号，它们依然会拿起左手边小编号的筷子，但是轮到 4 号的时候，情况就不一样了。因为对于 4 号来说，右手筷子编号更小，所以在拿到左手筷子之前，它会先试图拿右手筷子，又由于该筷子已经被 0 号拿走，4 号被阻塞。对于 3 号来说，没人和自己抢 4 号筷子了，所以 3 号哲学家可以拿到左右筷子，避免了死锁。</p> <p>还可以从另一个角度考虑，因为我们是按照编号递增的顺序请求资源的，设想在某一时刻，若干个进程中必定有一个进程的资源编号暂时是所有进程中最大的，那么该进程在此后申请新的资源的时候，只可能申请编号更大的资源，一方面避开了小编号、可能已经被拿走的资源，也就避开了阻塞和死锁，另一方面，大编号资源并没有被其他进程拿走。因此这个时候，该进程一定可以拿到资源，不会有死锁现象。</p> <blockquote><p>但这种预防死锁的方法，问题在于：</p> <ul><li>如何进行编号，从什么角度考虑？</li> <li>如果增加资源或设备，怎么重新编号？</li> <li>虽然资源请求上是先小编号资源，后大编号资源，但是实际使用的时候可能是得先使用大编号资源，这就意味着小编号资源虽然暂时用不到，但还是被进程占用，明显有资源浪费的问题。</li></ul></blockquote> <h2 id="避免死锁"><a href="#避免死锁" class="header-anchor">#</a> 避免死锁</h2> <p>安全状态：指系统按某种顺序 (P1,P2,…,Pn)(称 &lt; P1,P2,…,Pn &gt; 为安全序列) 来为每个进程分配其所需资源，直至满足每个进程资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</p> <p>避免死锁的实质在于：系统在进行资源分配时，如何使系统不进入不安全状态</p> <p>安全状态之例：假定系统中有三个进程 P1、P2 和 P3, 共有 12 台磁带机。进程 P1 总共要求 10 台磁带机，P2 和 P3 分别要求 4 台和 9 台。假设在 T0 时刻，进程 P1、P2 和 P3 分别获得 5 台、2 台和 2 台，尚有 3 台未分配，如下表所示：</p> <p><img src="https://static.pil0txia.com/picgo/IMG_20221117_111227.jpg" alt="IMG_20221117_111227"></p> <h3 id="进程-资源分配图"><a href="#进程-资源分配图" class="header-anchor">#</a> 进程 - 资源分配图</h3> <p>当各类资源都<strong>只有一个</strong>的时候，可以使用这种方法求解。资源分配图是描述进程和资源之间请求和分配关系的有向图，从进程指向资源的虚线代表资源需求（要使用），从进程指向资源的实线代表资源请求（申请使用），从资源指向进程的实线代表资源分配（正在使用）。</p> <p><img src="https://static.pil0txia.com/picgo/image-20221118230915805.png" alt="image-20221118230915805"></p> <ul><li>如果 P1 请求 R2 资源：那么就把 P1 到 R2 的需求边改为 R2 到 P1 的分配边，此时整个图中不存在回路，那么就认为系统处于安全状态，不会发生死锁。可以分配资源。</li> <li>如果 P2 请求 R2 资源：那么就把 P2 到 R2 的需求边改为 R2 到 P2 的分配边，此时整个图中存在一条回路，那么就认为系统处于不安全状态，有可能发生死锁。不可以分配资源。</li></ul> <h3 id="银行家算法"><a href="#银行家算法" class="header-anchor">#</a> 银行家算法</h3> <ul><li>银行家拥有一笔周转资金</li> <li>客户要求分期贷款，如果客户能够得到各期贷款，就一定能够归还贷款，否则就一定不能放贷</li> <li>银行家应谨慎的贷款，防止出现坏帐</li></ul> <h4 id="银行家算法案例"><a href="#银行家算法案例" class="header-anchor">#</a> 银行家算法案例</h4> <p>设银行家有 10 万贷款，P,Q,R 分别需要 8,3,9 万元搞项目（假设任何人满足资金总额后都会归还所有贷款)</p> <p>如果 P 已申请到了 4 万：</p> <ul><li>Q 要申请 2 万，显然，如果满足 Q 的申请，有安全序列 &lt;P,Q,R&gt;/&lt;Q,P,R&gt;</li> <li>R 要申请 4 万，显然，如果满足 R 的申请，则不存在安全序列。</li></ul> <p><strong>基本思想：分配申请的资源前，判断系统是否安全。如果不安全，则不分配。</strong></p> <h4 id="银行家算法过程"><a href="#银行家算法过程" class="header-anchor">#</a> 银行家算法过程</h4> <p><img src="https://static.pil0txia.com/picgo/image-20221118233726331.png" alt="image-20221118233726331"></p> <p>假设系统中有 n 个进程，m 种资源，规定：</p> <ul><li>每个进程在运行前先声明自己需要的最大资源数，用一个 n*m 的最大需求矩阵  <code>Max</code>  表示各个进程的需求情况，比如  <code>Max[i][j]= K</code>  就表示进程 i 需要 K 个 j 类型资源</li> <li>用一个 n*m 的分配矩阵  <code>Allocation</code>  表示各个进程的已分配资源情况</li> <li>用一个 n*m 的需求矩阵  <code>Need</code>  表示各个进程的最多还需要资源情况， <code>Need = Max - Allocation</code></li> <li>用一个 m 长度的一维数组  <code>Avaliable</code>  表示剩余资源数目</li> <li>用一个 m 长度的申请矩阵  <code>Request[i][j]</code>  表示某个进程 i 某次申请的 j 类型资源数目</li></ul> <p>按照之前说过的流程图，银行家算法的工作过程是：</p> <ul><li>请求资源数是否超过最大资源数？ <code>Request[i][j]&lt;=Need[i][j]</code> ，则到下一步；否则出错</li> <li>请求资源数是否超过剩余资源数？ <code>Request[i][j]&lt;=Available[j]</code> ，则到下一步；否则说明资源不够，进程等待</li> <li>尝试进行资源分配。
<ul><li>剩余资源减少： <code>Available = Available - Request</code></li> <li>已分配资源增加： <code>Allocation[i][j] = Allocation[i][j] + Request[i][j]</code></li> <li>需求资源减少： <code>Need[i][j] = Need[i][j] - Request[i][j]</code></li></ul></li> <li>对分配后的状态通过安全性算法进行预判：
<ul><li>安全状态：不会发生死锁，可以分配资源</li> <li>不安全状态：可能发生死锁，不分配资源，进程进入等待资源状态，并恢复系统状态</li></ul></li></ul> <h4 id="例题1"><a href="#例题1" class="header-anchor">#</a> 例题 1</h4> <p>假如现在有 P0 ~ P4 共五个进程，ABC 三类资源，个数为（10,5,7）。在某一时刻，资源剩余量为（3,3,2），各个进程的最大需求量、已分配量和需求量如下图所示：</p> <p><img src="https://static.pil0txia.com/picgo/image-20221118232822744.png" alt="image-20221118232822744"></p> <p>如何检测当前是否处于安全状态呢？尝试寻找安全序列：</p> <ul><li>当前剩余资源（3,3,2），无法满足 P0 需要的（7,4,3），所以不能首先分配给 P0；但是可以满足 P1 需要的（1,2,2），P3 需要的（0,1,1），所以可以分配给 P1 和 P3，P1 和 P3 进入安全序列。</li> <li>P1 和 P3 执行完之后，归还资源，剩余资源（3,3,2）+（2,0,0）+（2,1,1）=（7,4,3），可以满足 P0 需要的（7,4,3），P2 需要的（6,0,0），P4 需要的（4,3,1），所以 P0、P2、P4 依次进入安全序列。</li> <li>所以存在安全序列  <code>P1-&gt;P3-&gt;P0-&gt;P2-&gt;P4</code>  ，使得按照这个顺序分配资源后，每个进程都能拿到需要的资源并顺利完成，所以该状态是安全状态。</li></ul> <p>看另一种情况。假如现在有 P0 ~ P4 共五个进程，ABC 三类资源，个数为（10,5,7）。在某一时刻，资源剩余量为（3,3,2），各个进程的最大需求量、已分配量和需求量如下图所示：</p> <p><img src="https://static.pil0txia.com/picgo/image-20221118232808706.png" alt="image-20221118232808706"></p> <p>当尝试寻找安全序列的时候，容易发现 P1 P3 可以满足，所以 P1 P3 进入安全序列，此后剩余资源为（7,4,3）。又由于 P0 P2 P4 都是无法满足的，所以实际上并不存在一个安全序列使得所有进程都能被分配资源。因此状态是不安全状态，可能发生死锁，取消资源分配。</p> <h4 id="例题2"><a href="#例题2" class="header-anchor">#</a> 例题 2</h4> <p>t0 时刻安全状态检查。如果 t0 时刻都不安全，则后面的部分都不用做了。但是考试时 t0 都是安全的。</p> <p><img src="https://static.pil0txia.com/picgo/IMG_20221117_114149.jpg" alt="IMG_20221117_114149"></p> <p>安全序列之一：&lt;p1,p3,p4,p2,p0&gt;</p> <h4 id="例题3"><a href="#例题3" class="header-anchor">#</a> 例题 3</h4> <p>在银行家算法中，若出现下述资源分配情况，试问：</p> <table><thead><tr><th style="text-align:center;">Process</th> <th style="text-align:center;">Allocation</th> <th style="text-align:center;">Need</th> <th style="text-align:center;">Available</th></tr></thead> <tbody><tr><td style="text-align:center;">P0</td> <td style="text-align:center;">0032</td> <td style="text-align:center;">0012</td> <td style="text-align:center;">1622</td></tr> <tr><td style="text-align:center;">P1</td> <td style="text-align:center;">1000</td> <td style="text-align:center;">1750</td> <td style="text-align:center;"></td></tr> <tr><td style="text-align:center;">P2</td> <td style="text-align:center;">1354</td> <td style="text-align:center;">2356</td> <td style="text-align:center;"></td></tr> <tr><td style="text-align:center;">P3</td> <td style="text-align:center;">0332</td> <td style="text-align:center;">0652</td> <td style="text-align:center;"></td></tr> <tr><td style="text-align:center;">P4</td> <td style="text-align:center;">0014</td> <td style="text-align:center;">0656</td> <td style="text-align:center;"></td></tr></tbody></table> <p>(1) 该状态是否安全？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>P0 1622+0032=1654
P3 1654+0332=1986
P1 1986+1000=2986
P4 2986+0014=299 10
P2 299 10+1354=3 12 14 14
故存在安全序列P0 P3 P1 P4 P2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>(2) 若进程 P2 提出请求 Request (1,2,2,2) 后，系统能否将资源分配给它？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>P2的Allocation加上1 2 2 2为2 5 7 6，Need变为1 1 3 4， Available变为0 4 0 0
由(1)可知，此时系统资源无法满足任何一个进程，安全性检查不通过，无法分配资源
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="检测死锁"><a href="#检测死锁" class="header-anchor">#</a> 检测死锁</h2> <h3 id="简化进程-资源分配图"><a href="#简化进程-资源分配图" class="header-anchor">#</a> 简化进程 - 资源分配图</h3> <h4 id="各类资源只有一个"><a href="#各类资源只有一个" class="header-anchor">#</a> 各类资源只有一个</h4> <p>当各类资源只有一个的时候，可以把<a href="#%E8%BF%9B%E7%A8%8B-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE">资源分配图</a>化简为一个等待图（wait-for graph），比如说 A 进程请求 X 资源、X 资源被 B 进程占有，这个过程可以被简化为 A 进程等待 B 进程。比如说下面，左图被转化为对应的右图：</p> <p><img src="https://static.pil0txia.com/picgo/image-20221119185911023.png" alt="image-20221119185911023"></p> <p><strong>死锁定理：有环路，且每个类型的资源只有一个，则一定会出现死锁。</strong></p> <ul><li>如果进程 - 资源分配图中无环路，则此时系统没有发生死锁。</li> <li>如果进程 - 资源分配图中有环路，且每个资源类中仅有一个资源，则系统中发生了死锁，此时，环路是系统发生死锁的充分和必要条件，环路中的进程便为死锁进程。</li> <li>如果进程 - 资源分配图中有环路，且涉及的资源类中有多个资源，则环路的存在只是产生死锁的必要条件而不是充分条件。</li></ul> <h4 id="各类资源有多个"><a href="#各类资源有多个" class="header-anchor">#</a> 各类资源有多个</h4> <p>各类资源有多个的时候，我们可能需要根据给定表或给定图检测是否有死锁。对于前者，可以沿用<a href="#%E4%BE%8B%E9%A2%981">之前的安全性算法</a>进行检测；对于后者，可以尝试简化资源分配图。</p> <p>给定一个资源分配图为例：</p> <p><img src="https://static.pil0txia.com/picgo/image-20221119205915983.png" alt="image-20221119205915983"></p> <p>约定蓝色线为请求边，黑色线为分配边，资源中的一个圆点代表一个该类资源。那么 P1 占有两个 R1 资源，请求一个 R2 资源；P2 占有一个 R2 资源，一个 R1 资源，请求一个 R1 资源。</p> <ul><li>首先找出非阻塞非孤立的进程点。P1 P2 都不是孤立的，所谓非阻塞指的是<strong>进程请求的资源数量足够</strong>，比如说 P2 请求 R1，由于 R1 已经有两个被 P1 占有，一个被 P2 占有，无多余资源，所以 P2 是阻塞的；而 P1 请求 R2，因为 R2 只有一个被 P2 占有，有多余资源，P1 是非阻塞的。这样就找到了符合条件的进程点 P1</li> <li>去除这样的点的所有边。那么就会去除 P1 的所有边，归还所有资源。P1 成为孤立点</li> <li>重复第一步和第二步。此时，因为这次 P2 请求的 R2 资源是足够的（被 P1 释放了），所以 P2 是非阻塞非孤立的点，把他的全部边去除</li> <li>由于图中所有的边都能被消除，所以称该图<strong>可以被简化</strong>，因此它不存在死锁（如果不可简化，则存在死锁）</li></ul> <blockquote><p><img src="https://static.pil0txia.com/picgo/IMG_20221117_105216.jpg" alt="IMG_20221117_105216"></p></blockquote> <p>又比如下面这种情况：</p> <p><img src="https://static.pil0txia.com/picgo/image-20221119225907074.png" alt="image-20221119225907074"></p> <p>首先还是找一个非孤立非阻塞的点，很显然只有 P3 符合要求。之后把 P3 的分配边去掉，会发现 P1 和 P2 都是非孤立阻塞的点，它们的边都无法消除。此时就说该资源分配图不能简化，因此存在死锁。</p> <h2 id="解除死锁"><a href="#解除死锁" class="header-anchor">#</a> 解除死锁</h2> <h3 id="资源剥夺法"><a href="#资源剥夺法" class="header-anchor">#</a> 资源剥夺法</h3> <p>将部分死锁的进程挂起并抢占它的资源，将这些资源分配给其它的死锁进程。但应防止被挂起的进程长时间得不到资源而饥饿。</p> <blockquote><p>注意不是抢占非死锁进程的资源。</p></blockquote> <h3 id="终止进程法"><a href="#终止进程法" class="header-anchor">#</a> 终止进程法</h3> <p>强制终止部分或全部死锁进程，并剥夺它们的资源。这种方式的优点是实现简单，但可能付出很大的代价。因为有些进程可能已经运行了很长时间，一旦被终止就功亏一篑了。</p> <h3 id="进程回退法"><a href="#进程回退法" class="header-anchor">#</a> 进程回退法</h3> <p>让一个或多个死锁进程回退到足以避免死锁的地步。这要求系统必须记录进程的历史信息，设置还原点。</p> <blockquote><p>无论是哪种方法，都可以从以下角度考虑需要做出牺牲的进程：</p> <ul><li>优先级比较低的进程做出牺牲</li> <li>占用过多资源的进程做出牺牲</li> <li>执行时间长的进程不做出牺牲</li> <li>快要完成的进程不做出牺牲</li> <li>交互式进程不做出牺牲</li></ul></blockquote></div></div> <!----> <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2023/01/06, 19:28:46</span></div></div> <div class="page-nav-wapper"><!----> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/e86493/" class="prev">调度算法</a></span> <span class="next"><a href="/pages/1253d7/">多级存储器结构</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="https://www.pil0txia.com" title="Blog" target="_blank" class="iconfont icon-shuben"></a><a href="https://github.com/Pil0tXia" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="mailto:admin@pil0txia.com" title="Contact Me" target="_blank" class="iconfont icon-youjian"></a></div> 
    Copyright © 2022-2023
    <span>Pil0tXia | CC BY-NC-SA 4.0 Licensed | <a href="https://beian.miit.gov.cn/" target="_blank">苏ICP备2023001491号-1</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.7c22909a.js" defer></script><script src="/assets/js/2.6758ed52.js" defer></script><script src="/assets/js/33.ed53d32c.js" defer></script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>非连续内存分配 - Pil0tXia 的书房</title>
    <meta name="generator" content="VuePress 1.9.2">
    <link rel="icon" href="https://static.pil0txia.com/assets/favicon.ico">
    <script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-57XMHPB9DW"></script>
    <script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-57XMHPB9DW');</script>
    <meta name="description" content="我的学习笔记和技术分享">
    <meta name="keywords" content="pil0txia,it,docs,note,study">
    <meta name="baidu-site-verification" content="code-f37Lv9IIFX">
    
    <link rel="preload" href="/assets/css/0.styles.021fb583.css" as="style"><link rel="preload" href="/assets/js/app.7c22909a.js" as="script"><link rel="preload" href="/assets/js/2.6758ed52.js" as="script"><link rel="preload" href="/assets/js/37.9fbc624d.js" as="script"><link rel="prefetch" href="/assets/js/10.e24f1e40.js"><link rel="prefetch" href="/assets/js/11.05cb0029.js"><link rel="prefetch" href="/assets/js/12.32af8044.js"><link rel="prefetch" href="/assets/js/13.700f1625.js"><link rel="prefetch" href="/assets/js/14.41717448.js"><link rel="prefetch" href="/assets/js/15.ecaf38f1.js"><link rel="prefetch" href="/assets/js/16.f4a2e8fe.js"><link rel="prefetch" href="/assets/js/17.dd141a48.js"><link rel="prefetch" href="/assets/js/18.d4b349b0.js"><link rel="prefetch" href="/assets/js/19.e768f6f2.js"><link rel="prefetch" href="/assets/js/20.258fe436.js"><link rel="prefetch" href="/assets/js/21.e2e83218.js"><link rel="prefetch" href="/assets/js/22.fbef3388.js"><link rel="prefetch" href="/assets/js/23.0823fda8.js"><link rel="prefetch" href="/assets/js/24.f2106677.js"><link rel="prefetch" href="/assets/js/25.d1029eac.js"><link rel="prefetch" href="/assets/js/26.de8ada83.js"><link rel="prefetch" href="/assets/js/27.5542150b.js"><link rel="prefetch" href="/assets/js/28.73bc9881.js"><link rel="prefetch" href="/assets/js/29.dfc6d141.js"><link rel="prefetch" href="/assets/js/3.0aad90a7.js"><link rel="prefetch" href="/assets/js/30.875cb1d3.js"><link rel="prefetch" href="/assets/js/31.12e24a9b.js"><link rel="prefetch" href="/assets/js/32.3e6b9414.js"><link rel="prefetch" href="/assets/js/33.ed53d32c.js"><link rel="prefetch" href="/assets/js/34.24759155.js"><link rel="prefetch" href="/assets/js/35.46746eb8.js"><link rel="prefetch" href="/assets/js/36.752fb623.js"><link rel="prefetch" href="/assets/js/38.e57c3e9a.js"><link rel="prefetch" href="/assets/js/39.fe320339.js"><link rel="prefetch" href="/assets/js/4.3055ae5e.js"><link rel="prefetch" href="/assets/js/40.2cc14361.js"><link rel="prefetch" href="/assets/js/41.69f063eb.js"><link rel="prefetch" href="/assets/js/42.7e2baa49.js"><link rel="prefetch" href="/assets/js/43.db617122.js"><link rel="prefetch" href="/assets/js/44.a1fc3b4c.js"><link rel="prefetch" href="/assets/js/45.966ef14f.js"><link rel="prefetch" href="/assets/js/46.1b8df3ff.js"><link rel="prefetch" href="/assets/js/47.19f52d31.js"><link rel="prefetch" href="/assets/js/48.99209cdd.js"><link rel="prefetch" href="/assets/js/49.e2fcc246.js"><link rel="prefetch" href="/assets/js/5.e24581f1.js"><link rel="prefetch" href="/assets/js/50.1fb68e50.js"><link rel="prefetch" href="/assets/js/51.8fb412d1.js"><link rel="prefetch" href="/assets/js/52.7f71c13a.js"><link rel="prefetch" href="/assets/js/53.a0638f3f.js"><link rel="prefetch" href="/assets/js/54.197b3a4a.js"><link rel="prefetch" href="/assets/js/55.8f0848d5.js"><link rel="prefetch" href="/assets/js/56.2b6c22ee.js"><link rel="prefetch" href="/assets/js/57.d3b95709.js"><link rel="prefetch" href="/assets/js/58.477eda2a.js"><link rel="prefetch" href="/assets/js/59.e0b4407a.js"><link rel="prefetch" href="/assets/js/6.a90a255b.js"><link rel="prefetch" href="/assets/js/60.02ddfe44.js"><link rel="prefetch" href="/assets/js/7.2fb00079.js"><link rel="prefetch" href="/assets/js/8.a4338d2b.js"><link rel="prefetch" href="/assets/js/9.f988ec8a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.021fb583.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="https://static.pil0txia.com/assets/03_3_600p.webp" alt="Pil0tXia 的书房" class="logo"> <span class="site-name can-hide">Pil0tXia 的书房</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="操作系统课程笔记" class="dropdown-title"><a href="/pages/5719ac/" class="link-title">操作系统课程笔记</a> <span class="title" style="display:none;">操作系统课程笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/d1af54/" class="nav-link">第一章 操作系统引论</a></li><li class="dropdown-item"><!----> <a href="/pages/1f0d42/" class="nav-link">第二章 进程的描述与控制</a></li><li class="dropdown-item"><!----> <a href="/pages/9cf689/" class="nav-link">第三章 处理机调度与死锁</a></li><li class="dropdown-item"><!----> <a href="/pages/1253d7/" class="nav-link">第四章 存储器管理</a></li><li class="dropdown-item"><!----> <a href="/pages/f6080a/" class="nav-link">第五章 虚拟存储器</a></li><li class="dropdown-item"><!----> <a href="/pages/a80c85/" class="nav-link">期末考试备考</a></li></ul></div></div><div class="nav-item"><a href="/asm-notes/shorthand/" class="nav-link">汇编语言课程笔记</a></div> <a href="https://github.com/Pil0tXia/docs" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="操作系统课程笔记" class="dropdown-title"><a href="/pages/5719ac/" class="link-title">操作系统课程笔记</a> <span class="title" style="display:none;">操作系统课程笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/d1af54/" class="nav-link">第一章 操作系统引论</a></li><li class="dropdown-item"><!----> <a href="/pages/1f0d42/" class="nav-link">第二章 进程的描述与控制</a></li><li class="dropdown-item"><!----> <a href="/pages/9cf689/" class="nav-link">第三章 处理机调度与死锁</a></li><li class="dropdown-item"><!----> <a href="/pages/1253d7/" class="nav-link">第四章 存储器管理</a></li><li class="dropdown-item"><!----> <a href="/pages/f6080a/" class="nav-link">第五章 虚拟存储器</a></li><li class="dropdown-item"><!----> <a href="/pages/a80c85/" class="nav-link">期末考试备考</a></li></ul></div></div><div class="nav-item"><a href="/asm-notes/shorthand/" class="nav-link">汇编语言课程笔记</a></div> <a href="https://github.com/Pil0tXia/docs" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>关于本文档</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/5719ac/" class="sidebar-link">操作系统课程笔记</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第一章 操作系统引论</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d1af54/" class="sidebar-link">单道批处理</a></li><li><a href="/pages/4722dd/" class="sidebar-link">多道批处理</a></li><li><a href="/pages/d4063c/" class="sidebar-link">并发与并行的区别</a></li><li><a href="/pages/ed294b/" class="sidebar-link">分时操作系统</a></li><li><a href="/pages/f50a2e/" class="sidebar-link">实时操作系统</a></li><li><a href="/pages/bc61d3/" class="sidebar-link">操作系统的四个基础特性</a></li><li><a href="/pages/4d01a9/" class="sidebar-link">现代OS的基本单位</a></li><li><a href="/pages/ebecb5/" class="sidebar-link">作业1</a></li><li><a href="/pages/5203e5/" class="sidebar-link">内核</a></li><li><a href="/pages/ee322f/" class="sidebar-link">中断和异常</a></li><li><a href="/pages/1501a6/" class="sidebar-link">系统调用</a></li><li><a href="/pages/1fd856/" class="sidebar-link">冷启动和热启动</a></li><li><a href="/pages/e900d8/" class="sidebar-link">补充资料</a></li><li><a href="/pages/3f251a/" class="sidebar-link">作业2</a></li><li><a href="/pages/82c444/" class="sidebar-link">附言</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第二章 进程的描述与控制</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/1f0d42/" class="sidebar-link">程序的基本概念</a></li><li><a href="/pages/a98e4b/" class="sidebar-link">进程的基本概念</a></li><li><a href="/pages/ec4dab/" class="sidebar-link">作业</a></li><li><a href="/pages/d00b2a/" class="sidebar-link">进程控制</a></li><li><a href="/pages/f0811a/" class="sidebar-link">进程的特征</a></li><li><a href="/pages/1da972/" class="sidebar-link">进程同步</a></li><li><a href="/pages/8c5da1/" class="sidebar-link">进程通信</a></li><li><a href="/pages/8676b4/" class="sidebar-link">线程</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第三章 处理机调度与死锁</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/9cf689/" class="sidebar-link">处理机调度的层次</a></li><li><a href="/pages/053628/" class="sidebar-link">队列调度模型</a></li><li><a href="/pages/79d126/" class="sidebar-link">选择调度算法的原则</a></li><li><a href="/pages/e86493/" class="sidebar-link">调度算法</a></li><li><a href="/pages/15347c/" class="sidebar-link">死锁</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>第四章 存储器管理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/1253d7/" class="sidebar-link">多级存储器结构</a></li><li><a href="/pages/ae65e4/" class="sidebar-link">程序的装入与链接</a></li><li><a href="/pages/e66b46/" class="sidebar-link">连续内存分配</a></li><li><a href="/pages/a8d561/" aria-current="page" class="active sidebar-link">非连续内存分配</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/a8d561/#基本分页存储管理" class="sidebar-link">基本分页存储管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/a8d561/#基本思路" class="sidebar-link">基本思路</a></li><li class="sidebar-sub-header level3"><a href="/pages/a8d561/#页面、页框" class="sidebar-link">页面、页框</a></li><li class="sidebar-sub-header level3"><a href="/pages/a8d561/#地址转换的思路" class="sidebar-link">地址转换的思路</a></li><li class="sidebar-sub-header level4"><a href="/pages/a8d561/#十进制地址" class="sidebar-link">十进制地址</a></li><li class="sidebar-sub-header level4"><a href="/pages/a8d561/#二进制地址" class="sidebar-link">二进制地址</a></li><li class="sidebar-sub-header level4"><a href="/pages/a8d561/#例题" class="sidebar-link">例题</a></li><li class="sidebar-sub-header level3"><a href="/pages/a8d561/#页表" class="sidebar-link">页表</a></li><li class="sidebar-sub-header level3"><a href="/pages/a8d561/#地址变换机构" class="sidebar-link">地址变换机构</a></li><li class="sidebar-sub-header level4"><a href="/pages/a8d561/#基本地址变换机构" class="sidebar-link">基本地址变换机构</a></li><li class="sidebar-sub-header level4"><a href="/pages/a8d561/#例题1" class="sidebar-link">例题1</a></li><li class="sidebar-sub-header level4"><a href="/pages/a8d561/#具有快表的地址变换机构" class="sidebar-link">具有快表的地址变换机构</a></li><li class="sidebar-sub-header level4"><a href="/pages/a8d561/#例题2" class="sidebar-link">例题2</a></li><li class="sidebar-sub-header level3"><a href="/pages/a8d561/#页表项的大小" class="sidebar-link">页表项的大小</a></li><li class="sidebar-sub-header level3"><a href="/pages/a8d561/#两级页表" class="sidebar-link">两级页表</a></li><li class="sidebar-sub-header level4"><a href="/pages/a8d561/#单级页表占用过大的连续内存空间的问题" class="sidebar-link">单级页表占用过大的连续内存空间的问题</a></li><li class="sidebar-sub-header level4"><a href="/pages/a8d561/#引入两级页表" class="sidebar-link">引入两级页表</a></li><li class="sidebar-sub-header level4"><a href="/pages/a8d561/#单级页表常驻内存的问题" class="sidebar-link">单级页表常驻内存的问题</a></li><li class="sidebar-sub-header level4"><a href="/pages/a8d561/#多级页表" class="sidebar-link">多级页表</a></li><li class="sidebar-sub-header level3"><a href="/pages/a8d561/#习题" class="sidebar-link">习题</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/a8d561/#基本分段存储管理" class="sidebar-link">基本分段存储管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/a8d561/#基本思路-2" class="sidebar-link">基本思路</a></li><li class="sidebar-sub-header level3"><a href="/pages/a8d561/#逻辑地址" class="sidebar-link">逻辑地址</a></li><li class="sidebar-sub-header level3"><a href="/pages/a8d561/#段表" class="sidebar-link">段表</a></li><li class="sidebar-sub-header level3"><a href="/pages/a8d561/#段表项的大小" class="sidebar-link">段表项的大小</a></li><li class="sidebar-sub-header level3"><a href="/pages/a8d561/#地址转换" class="sidebar-link">地址转换</a></li><li class="sidebar-sub-header level3"><a href="/pages/a8d561/#分页和分段的对比" class="sidebar-link">分页和分段的对比</a></li><li class="sidebar-sub-header level4"><a href="/pages/a8d561/#划分的角度和维度" class="sidebar-link">划分的角度和维度</a></li><li class="sidebar-sub-header level4"><a href="/pages/a8d561/#信息的共享和保护" class="sidebar-link">信息的共享和保护</a></li><li class="sidebar-sub-header level4"><a href="/pages/a8d561/#访存次数" class="sidebar-link">访存次数</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/a8d561/#段页式存储管理" class="sidebar-link">段页式存储管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/a8d561/#基本思路-3" class="sidebar-link">基本思路</a></li><li class="sidebar-sub-header level3"><a href="/pages/a8d561/#逻辑地址-2" class="sidebar-link">逻辑地址</a></li><li class="sidebar-sub-header level3"><a href="/pages/a8d561/#段表-2" class="sidebar-link">段表</a></li><li class="sidebar-sub-header level3"><a href="/pages/a8d561/#地址转换-2" class="sidebar-link">地址转换</a></li><li class="sidebar-sub-header level3"><a href="/pages/a8d561/#访存次数-2" class="sidebar-link">访存次数</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第五章 虚拟存储器</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/f6080a/" class="sidebar-link">虚拟存储器概述</a></li><li><a href="/pages/9b0e23/" class="sidebar-link">请求分页存储管理方式</a></li><li><a href="/pages/985167/" class="sidebar-link">页面置换算法</a></li><li><a href="/pages/3be910/" class="sidebar-link">内存分配策略和分配算法</a></li><li><a href="/pages/8b5fe6/" class="sidebar-link">抖动与工作集</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第六章 输入输出系统</span> <!----></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>第七章 文件管理</span> <!----></p> <!----></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>期末考试备考</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/a80c85/" class="sidebar-link">考试题型</a></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>操作系统</span></li><li data-v-06225672><span data-v-06225672>第四章 存储器管理</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://www.pil0txia.com" target="_blank" title="作者" class="beLink" data-v-06225672>Pil0tXia</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-01-05</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><!---->非连续内存分配<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h1 id="非连续内存分配"><a href="#非连续内存分配" class="header-anchor">#</a> 非连续内存分配</h1> <p>固定分区分配容易产生内部碎片，动态分区分配容易产生外部碎片（虽然可以用紧凑技术解决，但是有一定的成本），都不是理想的解决方案。</p> <h2 id="基本分页存储管理"><a href="#基本分页存储管理" class="header-anchor">#</a> 基本分页存储管理</h2> <h3 id="基本思路"><a href="#基本思路" class="header-anchor">#</a> 基本思路</h3> <p>在连续分配中，一个进程不可被分割，只能整体放入一块连续的内存空间中；但在基本分页存储管理中，允许把一个进程按照固定大小  <code>X</code>  分割为多个部分，同时把内存也按照固定大小  <code>X</code>  分割为多个部分，并把前者对应地放到后者中（不要求连续存放）。通常来说，一个进程的最后一部分会小于  <code>X</code> ，这部分若放到内存的某个  <code>X</code>  空间中，仍然会产生碎片（这种碎片称为页内碎片）。</p> <h3 id="页面、页框"><a href="#页面、页框" class="header-anchor">#</a> 页面、页框</h3> <ul><li><p>页框 (Page Frame)：具体来说，把内存分割为多个固定大小  <code>X</code>  的部分，这些部分就叫做页框 / 页帧 / 物理块 / 内存块，每个页框会有一个数字编号，第一个页框就从 0 开始</p></li> <li><p>页面 (Page)：同样，进程被分割为多个固定大小  <code>X</code>  的部分，这些部分就叫做页面 / 页，每个页面会有一个数字编号，第一个页面就从 0 开始</p></li></ul> <p><img src="https://static.pil0txia.com/picgo/image-20221128191916596.png" alt="image-20221128191916596"></p> <p>若页面太小，虽然可使页内碎片减小、提高内存利用率，但是会使页表过长、降低页面换进换出的效率；若页面太大，则相反。因此页面的大小应是 2 的整数幂，通常为 1KB~8KB。</p> <p>系统以页框为单位为各个进程分配内存空间，一个页面就对应一个页框，它具体放到哪个页框是随意的，无需顾虑是否连续和先后顺序。</p> <h3 id="地址转换的思路"><a href="#地址转换的思路" class="header-anchor">#</a> 地址转换的思路</h3> <p>假设我们采用动态重定位方式进行模块装入，程序中是逻辑地址，但在程序执行到需要访问地址的时候，需要进行逻辑地址到物理地址的转换。</p> <h4 id="十进制地址"><a href="#十进制地址" class="header-anchor">#</a> 十进制地址</h4> <p>左边进程按照 50B 的大小分为 4 个页面，右边内存按照 50B 的大小分为若干个页框：</p> <p><img src="https://static.pil0txia.com/picgo/image-20221128192409450.png" alt="image-20221128192409450"></p> <p>在程序执行到指令 1 的时候，需要访问地址 80，这是一个逻辑地址，需要转换成对应的物理地址。转换步骤如下：</p> <ul><li>计算逻辑地址的页号</li> <li>根据页号找到页号对应页面在内存中的<strong>起始地址</strong></li> <li>计算逻辑地址在当前页面内的偏移量（<strong>页内偏移量</strong>）</li> <li><code>物理地址 = 起始地址 + 页内偏移量</code></li></ul> <p>从左图可以看出，逻辑地址 80 在 1 号页面内，而 1 号页面对应的是右图中的红色页框，起始地址为 450；逻辑地址 80 <strong>在 1 号页面内的偏移量</strong>为 30；所以 <code>物理地址 = 450 + 30 = 480</code></p> <p>也可以用计算的方法，在已知逻辑地址的情况下：</p> <ul><li><code>页号 = 逻辑地址 / 页面大小</code> ，即 <code>80/50 = 1</code> （取整数部分）</li> <li><code>页内偏移量 = 逻辑地址 % 页面大小</code> ，即 <code>80%50 = 30</code></li></ul> <h4 id="二进制地址"><a href="#二进制地址" class="header-anchor">#</a> 二进制地址</h4> <p>地址实际上是用 32 位二进制数表示的。这时候计算页号 P 和页内偏移量 W 实际上更加简单，因为地址本身已经包含了这两者的信息。</p> <p>以页面 / 页框大小 4KB 为例，用地址的前 20 位（红色部分，也叫高 20 位）表示页号 P，用地址的后 12 位（黑色部分，也叫低 12 位）表示页内偏移量 W。页内偏移量的位数可以表明每个页面的大小，即 2<sup>12</sup> = 4KB。0 号页、1 号页、2 号页的表示如下：</p> <p><img src="https://static.pil0txia.com/picgo/image-20221128192830159.png" alt="image-20221128192830159"></p> <p>若页面 / 页框大小为 1KB，也即 2<sup>10</sup>B = 1024B，那么地址的前 22 位表示页号，剩余的 10 位表示页内偏移量：</p> <p><img src="https://static.pil0txia.com/picgo/image-20221128192842511.png" alt="image-20221128192842511"></p> <h4 id="例题"><a href="#例题" class="header-anchor">#</a> 例题</h4> <p><img src="https://static.pil0txia.com/picgo/IMG_20221201_110859.jpg" alt="IMG_20221201_110859"></p> <p><img src="https://static.pil0txia.com/picgo/IMG_20221201_111601.jpg" alt="IMG_20221201_111601"></p> <h3 id="页表"><a href="#页表" class="header-anchor">#</a> 页表</h3> <p>根据地址，就已经可以知道页号和页内偏移量，还有一个工作是<strong>根据页号找到对应页面在内存中的物理地址</strong>。</p> <p>每一个进程都有一张页表来记录页面号（页号）与页框号（块号）的映射关系，可以根据页号找到内存中对应页框的编号。其中页号是隐含的，相当于从 0 开始的下标，不占存储空间，页表实际只保存了块号。</p> <p><img src="https://static.pil0txia.com/picgo/image-20221128192853911.png" alt="image-20221128192853911"></p> <p>根据地址知道页号后，从页表中找出页号对应的块号，再用 <code>块号 * 页框大小</code> ，即可算出块的<strong>起始地址</strong>。用 <code>起始地址 + 偏移量</code> ，即可算出物理地址。</p> <h3 id="地址变换机构"><a href="#地址变换机构" class="header-anchor">#</a> 地址变换机构</h3> <h4 id="基本地址变换机构"><a href="#基本地址变换机构" class="header-anchor">#</a> 基本地址变换机构</h4> <p>上述的地址转换是通过<strong>基本地址变换机构</strong>这个硬件实现的，它借助页表将逻辑地址转换为物理地址。转换过程如下：</p> <p><img src="https://static.pil0txia.com/picgo/image-20221128192904519.png" alt="image-20221128192904519"></p> <p>在程序未执行的时候，PCB 中存放程序对应页表的初始地址 F 以及页表长度 M（页表项个数）。程序一旦开始执行，F 和 M 会被送到页表寄存器中。在需要访问地址的时候，基本地址变换机构开始运行：</p> <ul><li>首先将逻辑地址 A 拆分为页号和页内偏移量两个部分，然后将页号与页表寄存器中的页表长度作比较。页表长度即页表项个数，即页面个数，因此页号是不能大于等于（不能等于，因为页号从 0 开始计算）页表长度的，如果页号越界就会发生越界中断。</li> <li>由于页表中每个页表项的大小是一样的（假设为 size），且已经知道了页表在内存中连续分配的起始地址（假设为 X），所以页号 P 对应的页表项的存放地址等于  <code>X + P*size</code> ，在这个地址保存着页号对应的块号</li> <li>将块号与偏移量的二进制数<strong>拼接</strong>，就得到了物理地址，得以访问目标</li></ul> <p>例子中涉及到的都是二进制数，要计算物理地址，只需要将块号二进制数与偏移量二进制数拼接即可。如果例子给出的是十进制数，则应用  <code>块起始地址 + 页内偏移量</code>  进行<strong>相加</strong>，计算结果再转化为二进制数。</p> <h4 id="例题1"><a href="#例题1" class="header-anchor">#</a> 例题 1</h4> <p>若给定的是十进制：</p> <blockquote><p>页面大小 1KB，块号 2，偏移量 1023。</p></blockquote> <p>块起始地址等于  <code>2 * 1KB = 2 * 1024B = 2048B</code> ，又偏移量 1023，所以物理地址等于  <code>2048 + 1023 = 3071</code> ，转化为 32 位二进制数，就是  <code>0000000000000000000010,1111111111</code></p> <p>若给定的是二进制：</p> <blockquote><p>页面大小 1KB，块号 2，偏移量 1111111111。</p></blockquote> <p>块号 2 转化为 22 位二进制数就是  <code>0000000000000000000010</code> ，与偏移量拼接，就得到  <code>0000000000000000000010,1111111111</code> ，与十进制的结果是一样的。</p> <h4 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="header-anchor">#</a> 具有快表的地址变换机构</h4> <p>在前面的基本地址变换机构中，存在两个问题：</p> <ul><li>每次存取数据都需要<strong>访问内存两次</strong>：第一次访问内存中的页表，找到块号，并将块号与偏移量拼接得到物理地址；第二次根据物理地址访问内存中存放的数据。第二次访存肯定是不能避免的，但是第一次访存可以想办法避免</li> <li>若多条指令涉及到的逻辑地址的页号都相同，就都必须经历第一次访存，找到该页号对应的块号</li></ul> <p>这两个问题可以通过引入快表来解决。</p> <p>快表（联想寄存器）是一种访问速度比内存快很多的高速缓冲存储器，用以存放访问过的页表项的副本，从而加快地址转换的过程。引入快表后，地址转换大概率<strong>不需要经历第一次访存</strong>，而是直接从快表中拿到需要的页表项。于是内存中原本的页表被称为慢表。</p> <p>此时的地址变换机构的运行过程和之前还是差不多的，只是多了一个快表的处理过程：</p> <p><img src="https://static.pil0txia.com/picgo/image-20221128192914850.png" alt="image-20221128192914850"></p> <p>在程序未执行的时候，PCB 中存放程序对应页表的初始地址 F 以及页表长度 M（页表项个数）。程序一旦开始执行，F 和 M 会被送到页表寄存器中。在需要访问地址的时候，地址变换机构开始运行：</p> <ul><li>首先将地址拆分为页号和页内偏移量两个部分，然后将页号与页表寄存器中的页表长度作比较。若越界，则发生越界中断。</li> <li>该页号被送往快表，并与其中的页表项比较，寻找是否有匹配的页号。因为这里我们是第一次查询，所以是没有的，即<strong>未命中</strong>，页号被送往慢表。</li> <li>第一次访存，在慢表中找到页号对应的页表项的地址，意味着找到了页号对应的块号</li> <li>将该页表项拷贝一份副本放到快表中</li> <li>将块号与偏移量的二进制数拼接，就得到了物理地址，得以访问目标</li></ul> <p>我们需要继续访问某个地址，并且与上次访问的地址的页号一样：</p> <ul><li>首先将地址拆分为页号和页内偏移量两个部分，然后将页号与页表寄存器中的页表长度作比较。若越界，则发生越界中断。</li> <li>该页号被送往快表，并与其中的页表项比较，寻找是否有匹配的页号。因为快表中已经存放了一份页表项的副本，所以找到了匹配的页号，即<strong>命中</strong>。</li> <li>从快表中读出该页号对应的块号，并与偏移量拼接，就得到了物理地址，得以访问目标</li></ul> <h4 id="例题2"><a href="#例题2" class="header-anchor">#</a> 例题 2</h4> <blockquote><p>某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。假设访问一次快表耗时 1us，访问一次内存耗时 100us，快表的命中率为 90%。</p></blockquote> <ul><li><p>若未引入快表，则访问一个逻辑地址耗时  <code>100 + 100 = 200us</code></p></li> <li><p>若引入快表，则访问一个逻辑地址耗时  <code>(1+100) * 0.9 + (1+100+100) * 0.1 = 111 us</code></p></li> <li><p>若引入快表，且该系统支持同时查询快表和慢表，则访问一个逻辑地址耗时  <code>(1+100) * 0.9 + (100+100) * 0.1 = 110.9us</code></p></li></ul> <p><img src="https://static.pil0txia.com/picgo/IMG_20221201_112527.jpg" alt="IMG_20221201_112527"></p> <h3 id="页表项的大小"><a href="#页表项的大小" class="header-anchor">#</a> 页表项的大小</h3> <blockquote><p>假设某系统物理内存大小为 4GB，页面大小为 4KB，则每个页表项至少应该为多少字节？</p></blockquote> <p>一条页表项的大小取决于块号的位数。的 4GB=2<sup>32</sup>B， 4KB=2<sup>12</sup>B，因此 4GB 的内存总共会被分为 2<sup>32</sup>/2<sup>12</sup> = 2<sup>20</sup> 个内存块，因此内存块号的范围应该是 0～2<sup>20</sup>-1。因此对于单个页表项，它要用一个 20 位二进制数才能表示这样的一个内存块号，而一个字节 8 位，所以至少要 3B 才可以表示这样的一个内存块号。</p> <p>但是一个页表项用 3 个字节其实会出现一些问题。类似于进程被拆分为多个页面存储在内存中一样，页表也是被拆分为多个页表项存储在内存中的。假设页面 / 页框大小为 4KB，也即 4096B，由于一个页表项 3B，所以一个页框至多可以放 4096/3=1365 个页表项，并且这个页框剩余 1B 的空间。由于 1B 不足以再存放一个页表项，所以第 1366 个页表项（1365 号页表项）只能放在下一个页框中了。</p> <p>这就会导致，前面 1365 个页表项的地址依然可以采用  <code>X + 3*P</code>  的方式计算，但是第 1366 个页表项，它的地址却应该是  <code>X + 3*P + 1</code> ，也就是说，我们无法以一个通用的式子去计算页表项的存放地址。</p> <p>因此，一个页表项的大小通常应选取 2 的整数幂。如果页表项大小为 4B，那么一个页框就刚好可以放 4096/4=1024 个页表项，余下的页表项可以依次放在下一个页框中。这样，涉及到页表项地址的计算都可以用通用的式子  <code>X + 4*P</code> ，就无需考虑<strong>由于页框无法得到完全利用</strong>而带来的查询麻烦的问题了。当然，为了这个式子能够通用，页表通常也应该<strong>连续地存放在内存块</strong>中，中间不出现断节。</p> <blockquote><p><strong>Q:</strong> 首先，在 <a href="#%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%9A%84%E5%A4%A7%E5%B0%8F">页表项的大小</a> 中，按照您的讲述，第 1366 个页表项的地址应为  <code>X + 3*(P+1)</code> 。另外，我对 “一个页表项的大小应同样选取 2 的整数幂” 的说法抱有疑问，因为 “一个页框能否在没有剩余空间的情况下装入足够多的页表项” 并不会影响到 “利用页号在页表中找到对应的块号”。即使页表项大小为 3B 时，第 1366 个页表项会被装入下一个页框，但是当页表项大小为 4B 时，第 4097 个页表项也同样会被装入下一个页框，不是吗？请问您是怎么理解的呢？</p> <p><strong>A:</strong> 页表项的地址≠块号，页表项的存放地址的数据内容才是块号。同样的，块号≠内存块的物理地址，块号是内存块在内存中组织顺序的索引， <code>块号 * 页框大小</code> 才等于内存块的起始物理地址。</p> <p>问题不在于 “如何从已经找到地址的页表项中读取块号”，而在于 “如何根据隐含的页号找到页表项的存放地址”。<strong>页号是隐含的</strong>，页表中并没有储存页号，我们无法根据页号直接读取到页表项存储的块号，必须先根据 <code>X + P*size</code>  这个式子来<a href="#%E9%A1%B5%E8%A1%A8">确定页表项的存放地址</a>。页表项大小为 3B 时，第 1365 个页表项和第 1366 个页表项之间间隔了未分配的 1B，先前 <code>X + 3*P</code>  的寻址规律就被打破了。 <code>X + 3*P + 1</code>  中的 <code>+1</code>  是前一个页框剩余的 1B，而不是 “下一个页框” 的意思。</p></blockquote> <h3 id="两级页表"><a href="#两级页表" class="header-anchor">#</a> 两级页表</h3> <h4 id="单级页表占用过大的连续内存空间的问题"><a href="#单级页表占用过大的连续内存空间的问题" class="header-anchor">#</a> 单级页表占用过大的连续内存空间的问题</h4> <p>假设页面 / 页框大小 4KB，页表项大小 4B，一个页表占用的空间：</p> <ul><li>计算页表一共有多少个页表项：4KB = 2<sup>12</sup>B，所以 32 位逻辑地址中，后 12 位表示偏移量，前 20 位表示页号。总共有 2<sup>20</sup> 个页面，也就是有 2<sup>20</sup> 个页表项需要存放。</li> <li>计算一个页框可以放多少个页表项：一个页框 4KB，一个页表项 4B，所以一个页框可以放 4096/4 = 1024 个页表项</li> <li>计算存放所有页表项需要多少个页框：2<sup>20</sup>/1024 = 1024</li></ul> <p>需要 1024 个页框才能放下整个页表，而且为了以通用的式子计算页表项地址，页表必须是连续存放的，这违背了分页存储的初衷。</p> <h4 id="引入两级页表"><a href="#引入两级页表" class="header-anchor">#</a> 引入两级页表</h4> <p>就像进程拆分为多个页面一样，页表也可以进行拆分：将长的单级页表分为多个子页表，再将每每个子页表离散地存放到各个内存块中。在<a href="#%E5%8D%95%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%8D%A0%E7%94%A8%E8%BF%87%E5%A4%A7%E7%9A%84%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E9%97%AE%E9%A2%98">之前的例子</a>中，一个页框可以放 1024 个页表项，那么每 1024 个页表项就拆分出一个子页表，因为页表一共有 2<sup>20</sup> 个页表项，所以一共可以拆分出 1024 个子页表，这些子页表再各自存放到内存块中。</p> <p>于是，我们需要一张<strong>页目录表</strong>（<strong>一级页表</strong> / 顶层页表 / 外层页表）来记录页目录表和<strong>子页表</strong>（<strong>二级页表</strong>）之间的映射关系，如下图：</p> <p><img src="https://static.pil0txia.com/picgo/image-20221128192925065.png" alt="image-20221128192925065"></p> <p>同时，之前的逻辑地址的含义也发生了改变。在单级页表中，前 20 位表示页号；而在两级页表中，前 10 位表示<strong>一级页号</strong>（一级页表的页号），紧跟着的 10 位表示<strong>二级页号</strong>（二级页表的页号）。这么划分之后，一级页号共有 2<sup>10</sup>=1024 种可能的取值，即页目录表的 1024 个页表项；二级页号也有 2<sup>10</sup>=1024 种可能的取值，即子页表的 1024 个页表项。</p> <p>在需要进行地址转换时：</p> <ul><li>首先将逻辑地址分为三个部分：一级页号、二级页号、页内偏移量</li> <li>然后从 PCB 中读出页目录表的初始地址，结合一级页号以及每个页表项的大小，找到一级页号对应页表项的地址，即读取到了一级页号对应的块号</li> <li>根据块号到内存中找到对应的二级页表</li> <li>在二级页表中，根据二级页号找到对应的块号</li> <li><code>块号 * 页框大小 + 偏移量</code> 得到物理地址</li></ul> <p>上面的过程也可以直接看这幅图理解：</p> <p><img src="https://static.pil0txia.com/picgo/image-20221128192933032.png" alt="image-20221128192933032"></p> <h4 id="单级页表常驻内存的问题"><a href="#单级页表常驻内存的问题" class="header-anchor">#</a> 单级页表常驻内存的问题</h4> <p>执行程序时，往往只需要访问特定的几个页面，但整个单级页表是常驻在内存中的。[虚拟存储技术](# 第五章 虚拟存储器) 可以在需要访问页面的时候才把对应的页表项调入内存。</p> <h4 id="多级页表"><a href="#多级页表" class="header-anchor">#</a> 多级页表</h4> <blockquote><p>某系统按字节编址，采用 40 位逻辑地址，页面大小为 4KB，页表项大小为 4B，假设采用纯页式存储，则要采用多少级页表？页内偏移量为多少位？</p></blockquote> <p>4KB = 4*1024B = 2<sup>12</sup>B，根据之前讲过的，页面偏移量应该是 12 位。40 - 12 = 28，所以前面 28 位用来表示页号。</p> <p>因为<strong>采用多级页表后，各级页表的大小不能超过一个页面</strong>，而一个页面最多只能放 1024 个页表项，所以应该限制页表最多只能包含 1024 个页表项（否则就放不下多余的页表项，导致页表超过一个页面），即逻辑地址中的 10 位二进制数。</p> <p>在逻辑地址的前 28 位中，可以选择 10 位用于表示某一级的页号（这一级的页表假设页表项可能有 1024 个这么多），再用 10 位表示某一级的页号（这一级的页表假设页表项可能有 1024 个这么多），再用剩下的 8 位表示某一级的页号（这一级的页表假设页表项远远少于 1024 个）。</p> <p>也可以考虑前面 8 位作为一级页号，紧接着的 10 位作为二级页号，再紧接着的 10 位作为三级页号，这样刚好就用完了逻辑地址前 28 位。所以题目需要采用三级页表。</p> <p>那如果这里不采用三级页表，强行使用二级页表，则必定有某一级的页号位数超过了 10，说明页表的页表项个数超过了 2<sup>10</sup>=1024 个，很显然就会导致一个页框放不下这一级的页表，需要跨页，这与规定 “<strong>采用多级页表后，各级页表的大小不能超过一个页面</strong>” 是相悖的。</p> <h3 id="习题"><a href="#习题" class="header-anchor">#</a> 习题</h3> <blockquote><ol><li>若系统采用两级分页存储方式，物理内存 64MB，页面大小 1KB，页表项大小 2B，则顶级页表有多少个页表项？</li></ol></blockquote> <p>这里我们可以参考之前<a href="#%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%9A%84%E5%A4%A7%E5%B0%8F">求页表项大小</a>的思路。物理内存 64MB = 2<sup>26</sup>B，表示这么多内存需要 26 位逻辑地址。这 26 位中，一部分表示一级页号，一部分表示二级页号，剩下的表示页内偏移量。</p> <p>因为页面大小 1KB = 2<sup>10</sup>B，所以页内偏移量需要 10 位来表示，余下 16 位供一、二级页号使用。一个页面大小 2<sup>10</sup>B，一个页表项 2B，所以一个页框可以最多可以放 2<sup>10</sup>/2 = 2<sup>9</sup> 个页表项，又由于<strong>各级页表不能超过一个页面</strong>，所以各级页表都不能超过 2<sup>9</sup> 个页表项。在余下的 16 位中，用 9 位表示二级页表的页号（此时该页表的页表项个数取满）。剩下的 7 位表示一级页表的页号，可以包含 2<sup>7</sup> = 128 个页表项。</p> <blockquote><ol start="2"><li>若系统采用分页存储方式，物理内存 256MB，页面大小 1KB，页表如下：</li></ol> <p>页号 0，1，2，3，4，5，6，7，8，9，10 分别对应块号 15，16，20，28，29，30，31，32，36，38，39</p> <p>则逻辑地址 1A68（16 进制）对应的物理地址是多少？</p></blockquote> <p>为了方便计算，我们先统一用十进制计算，得到十进制的物理地址后再转换为十六进制。</p> <p>1A68 按权展开转化为对应的十进制数字是 6760，对于逻辑地址 6760，可以计算它的页号和页内偏移量：</p> <ul><li>页号 = 6760/1024 = 6（取整数部分）</li> <li>页内偏移量 = 6760%1024 = 616</li></ul> <p>根据页号 6 找到块号 31，根据块号 31 计算块初始地址为 31*1024 = 31744，偏移量和初始地址相加得到的物理地址为 31744+616 = 32360。32360 是十进制的物理地址，短除法转化为对应的十六进制物理地址就是 7E68。</p> <blockquote><p>若统一使用二进制计算：</p> <p>256MB = 2<sup>28</sup>B 逻辑地址共 28 位</p> <p>1A68 转换为二进制：0001 1010 0110 1000</p> <p>页内偏移量 10 位</p> <p>28-10=18 页号位数</p> <p>补齐位数 0000 0000 0000 0001 1010 0110 1000</p> <p>即 000000000000000110,1001101000</p> <p>页号为 6，起始地址 31*1024=31744</p> <p>出题者想让你用十进制做，因为给的是十进制的页表</p></blockquote> <blockquote><ol start="3"><li>若系统采用分页存储方式，物理内存 1MB，共有 32 个页面，一个页面 2KB，则逻辑地址一共多少位？</li></ol></blockquote> <p><s>因为物理内存 1MB = 2<sup>20</sup>B，所以逻辑地址 20 位。</s></p> <p>根据上面的经验，我们可能会这么做，但是<strong>这是错误的做法</strong>。上面的习题都没有告诉我们程序具体被划分为多少个页面，所以我们认为物理地址需要多少位，逻辑地址也需要多少位。但是这道题已经告诉了我们程序具体被划分为 32 个页面 —— 显然，仅仅 32 个页面是不需要 20 这么多位的逻辑地址的。</p> <p>逻辑地址包括两部分，页号和页内偏移量：</p> <ul><li>考虑页内偏移量位数。由于一个页面 2KB，也即 2<sup>11</sup>B，所以页内偏移量占 11 位（注意这点是不变的）</li> <li>考虑页号位数。<strong>由于页面仅仅被划分为 32 = 2<sup>5</sup> 个</strong>，所以页号只需要 5 位</li></ul> <p>11 + 5 = 16，所以逻辑地址一共 16 位。</p> <p><strong>当题目明确给出分页个数的时候，按照页号位数 + 偏移量位数计算逻辑地址总位数。</strong></p> <h2 id="基本分段存储管理"><a href="#基本分段存储管理" class="header-anchor">#</a> 基本分段存储管理</h2> <h3 id="基本思路-2"><a href="#基本思路-2" class="header-anchor">#</a> 基本思路</h3> <p>在基本分页存储管理中，我们将程序分为多个大小相等的物理单元（页面）。而在基本分段存储管理中，我们倾向于从逻辑功能的角度去考虑，将程序<strong>分为多个逻辑功能段</strong>，每个段都有自己的段名，并且都从 0 开始编址。分配内存时以段为单位进行分配，段内所占内存空间是连续的，但是各个段之间可以不相邻，如下图：</p> <p><img src="https://static.pil0txia.com/picgo/image-20221128192944911.png" alt="image-20221128192944911"></p> <p>编写程序时可以将程序按照逻辑功能模块进行划分，会更加方便，可读性会更高，比如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>LOAD 1，[D]|&lt;A&gt;
STORE 1，[X]|&lt;B&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>分别表示：将分段 D 中 A 单元内的值读入寄存器 1，以及将寄存器 1 的值存入分段 X 的 B 单元中。这里的分段 D 和 X 都是段名，程序员在编程的时候只需要使用段名，编译时段名会转化为对应的段号。同理，A、B 单元编译时也会转化为寄存器地址。</p> <h3 id="逻辑地址"><a href="#逻辑地址" class="header-anchor">#</a> 逻辑地址</h3> <p>分段存储管理中逻辑地址的含义与分页存储管理不同。假设仍然是用 32 位二进制数表示逻辑地址，地址的前 16 位表示<strong>段号</strong>，后 16 位表示段内<strong>偏移量</strong>：</p> <ul><li>段号是 16 位二进制数，有 2<sup>16</sup> 种取值，即每个进程最多可以被分为 2<sup>16</sup> 个段</li> <li>段内偏移量也是 16 位二进制数，在一个段内，段内地址可能有 2<sup>16</sup> 种取值，所以一个段的最大长度为 2<sup>16</sup></li></ul> <h3 id="段表"><a href="#段表" class="header-anchor">#</a> 段表</h3> <p>类似的，我们需要用<strong>段表</strong>来记录某个编号段与实际物理存放位置之间的映射关系。在分段存储管理中，程序被分为大小不等的多个段，且不连续，没法像之前一样只凭借块号来推导块的初始地址。为了准确地找出段存放在内存中的位置，我们要将<strong>段号、段长、基址</strong> 这三者作为段表的三列。这样，根据段号可以在段表中找到对应段在内存中的基址（即起始地址，不是块号），再结合段长，可以知道这个段具体占用了哪里的空间。</p> <p>如下图所示：</p> <p><img src="https://static.pil0txia.com/picgo/image-20221128192954137.png" alt="image-20221128192954137"></p> <h3 id="段表项的大小"><a href="#段表项的大小" class="header-anchor">#</a> 段表项的大小</h3> <p>每个段表项由段号、段长、基址构成，我们可以依次考虑每一列可能占用的空间（假设物理内存 4GB，按字节寻址）：</p> <ul><li>基址：因为物理内存 4GB，也就是 2<sup>32</sup>B，那么内存中的地址最多可能取到 2<sup>32</sup> 种值。为了让基址列<strong>足够</strong>表示这些值，基址列占用了 32 位。</li> <li>段长：前面讲过，在逻辑地址中，段号和段内偏移量都是 16 位，所以段内偏移量最多可能取到 2<sup>16</sup> 种值，为了让段长列<strong>足够</strong>表示这些值，段长列占用了 16 位</li> <li>段号：和页表一样，在<strong>段表中同样隐含段号</strong>，因为段表也是连续的，我们只需要知道<strong>段表的起始地址</strong>和<strong>每个段表项的大小</strong>就能定位一个<strong>段表项的地址</strong>，而无需去维护一个从段号到段表项的映射。</li></ul> <p>因此，每个段表项占用了 16+32=48 位，一个字节 8 位，占用了 6 个字节， 即 6B。</p> <h3 id="地址转换"><a href="#地址转换" class="header-anchor">#</a> 地址转换</h3> <p>转换过程我们可以直接看下图理解：</p> <p><img src="https://static.pil0txia.com/picgo/image-20221128193010730.png" alt="image-20221128193010730"></p> <p>可以联系分页存储的地址转换过程。在需要将逻辑地址转换为物理地址的时候：</p> <ul><li>首先将逻辑地址分为段号和段内偏移量两个部分，段表寄存器中的段表长度保存了程序总共被分为了多少段，因此段号不应该超过段表长度，若超过则发生越界中断。</li> <li>根据段号、段表初始地址和段表项的大小，找到段号对应的段表项。比较段表项中的段长 C 和逻辑地址中的段内偏移量 W，若 W &gt;= C 则发生越界中断（此处比分页存储多一次越界判断，因为页表的页框大小固定，且受页内偏移量位数限制不会越界，而段长可变）</li> <li>在段表项中找到段号对应的基址，将该基址与段内偏移量<strong>拼接</strong>，得到物理地址，得以访问目标</li></ul> <h3 id="分页和分段的对比"><a href="#分页和分段的对比" class="header-anchor">#</a> 分页和分段的对比</h3> <h4 id="划分的角度和维度"><a href="#划分的角度和维度" class="header-anchor">#</a> 划分的角度和维度</h4> <p><img src="https://static.pil0txia.com/picgo/image-20221128193022033.png" alt="image-20221128193022033"></p> <h4 id="信息的共享和保护"><a href="#信息的共享和保护" class="header-anchor">#</a> 信息的共享和保护</h4> <p>在分段存储方式中，更容易实现信息共享和保护：</p> <p><img src="https://static.pil0txia.com/picgo/image-20221128193032194.png" alt="image-20221128193032194"></p> <p>可重入代码 (Reentry code) 也叫纯代码 (Pure code) 是一种允许多个进程同时访问的代码。为了使各进程所执行的代码完全相同，故不允许任何进程对其进行修改。程序在运行过程中可以被打断，并由开始处再次执行，并且在合理的范围内（多次重入，而不造成堆栈溢出等其他问题），程序可以在被打断处继续执行，且执行结果不受影响。</p> <p>在分页存储方式中，则很难：</p> <p><img src="https://static.pil0txia.com/picgo/image-20221128193042146.png" alt="image-20221128193042146"></p> <h4 id="访存次数"><a href="#访存次数" class="header-anchor">#</a> 访存次数</h4> <p>两者的访存次数是一样的：</p> <ul><li>若不引入快表，两者的第一次访存都是访问内存中的页 / 段表，第二次是访问内存中的目标。</li> <li>若引入快表，则两者的第一次访存有可能因为命中而省去。</li></ul> <h2 id="段页式存储管理"><a href="#段页式存储管理" class="header-anchor">#</a> 段页式存储管理</h2> <h3 id="基本思路-3"><a href="#基本思路-3" class="header-anchor">#</a> 基本思路</h3> <ul><li>采用分页存储管理，内存利用率高，不会产生外部碎片，仅会产生少量内部碎片；但是不方便按照逻辑模块实现信息的共享和保护</li> <li>采用分段存储管理，可以按照逻辑模块实现信息的共享和保护，但是若逻辑过多则会导致段过长，另外，这种方式也会产生外部碎片</li></ul> <p>所以结合二者之长，出现了段页式存储管理方式。</p> <p>如下图，段页存储管理会首先将进程按照逻辑模块划分为多个段，针对每个段再划分为多个页；同时也把内存划分为多个页框。分配内存的时候，一个页面就对应了一个页框。</p> <p><img src="https://static.pil0txia.com/picgo/image-20221128193050234.png" alt="image-20221128193050234"></p> <h3 id="逻辑地址-2"><a href="#逻辑地址-2" class="header-anchor">#</a> 逻辑地址</h3> <p>在分段存储管理中，给出一个逻辑地址，可以划分为段号和段内地址两个部分；而在段页存储管理中，段内地址还要继续细分成页号和页内偏移量两个部分。所以逻辑地址由<strong>段号、页号和页内偏移量</strong>三个部分组成。</p> <p>段号的位数仍然决定了一个进程可以被划分为多少个段，而页号的位数则决定了一个段可以被划分为多少个页面，页内偏移量则决定了一个页面可以有多大，即页面 / 页框大小。</p> <p>和分段存储管理一样，段页存储管理的地址结构也是二维的。</p> <h3 id="段表-2"><a href="#段表-2" class="header-anchor">#</a> 段表</h3> <p>段页存储管理中的段表不同于分段存储管理中的段表。程序被划分为多个段，每个段都会再被划分为多个页面，因此每一个段都维护着属于自己的一张页表。段表需要记录的是段号与段号对应段的页表之间的映射关系，包括<strong>段号</strong>、<strong>页表长度</strong>和<strong>存放页表的块号</strong>（块号 * 页框大小 = 页表所在块的起始地址）。<strong>段号是隐含的</strong>。</p> <p><img src="https://static.pil0txia.com/picgo/image-20221128193058929.png" alt="image-20221128193058929"></p> <h3 id="地址转换-2"><a href="#地址转换-2" class="header-anchor">#</a> 地址转换</h3> <p><img src="https://static.pil0txia.com/picgo/image-20221128193131085.png" alt="image-20221128192331085"></p> <p>段页式存储的地址转换机构结合了分页存储和分段存储的方式，在需要将逻辑地址转换为物理地址的时候：</p> <ul><li>首先将逻辑地址分为<strong>段号、页号和页内偏移量</strong>三个部分，段表寄存器中的段表长度仍代表程序总共被分为多少个段，因此段号不应该超过段表长度，若超过则越界中断（同段式存储第一次越界检查）</li> <li>根据段号、段表初始地址以及段表项的大小，找到段号对应的段表项。可以从这个段表项读取到该段号对应的页表的位置和大小。这里同样要比较段表项中的页表长度和逻辑地址中的页号 P，若页号大于等于页表长度则越界中断（同页式存储唯一一次越界检查，不同于段式存储第二次越界检查）</li> <li>找到了段表项就是找到了该段的页表所在块的块号。根据块号，在内存中找到这个块，再从块中找到页表</li> <li>根据逻辑地址中的页号，在页表中找到页号对应的块号，将块号和逻辑地址中的页内偏移量<strong>拼接</strong>，得到物理地址，得以访问目标</li></ul> <h3 id="访存次数-2"><a href="#访存次数-2" class="header-anchor">#</a> 访存次数</h3> <p>不采用快表时，段页式存储管理需要经历三次访存：第一次访存，访问内存中的段表，找到段表中记录的页表信息；第二次访存，访问内存中的页表，找到目标所在的块；第三次访存，访问内存中的目标。</p> <p>如果采用快表，会利用段号和页号去寄存器中检索，若命中，则无需经历第一次和第二次访存，可以直接拿到块号并和偏移量进行拼接，得到物理地址。同样只需要一次访存。</p></div></div> <!----> <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2023/01/06, 19:28:46</span></div></div> <div class="page-nav-wapper"><!----> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/e66b46/" class="prev">连续内存分配</a></span> <span class="next"><a href="/pages/f6080a/">虚拟存储器概述</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="https://www.pil0txia.com" title="Blog" target="_blank" class="iconfont icon-shuben"></a><a href="https://github.com/Pil0tXia" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="mailto:admin@pil0txia.com" title="Contact Me" target="_blank" class="iconfont icon-youjian"></a></div> 
    Copyright © 2022-2023
    <span>Pil0tXia | CC BY-NC-SA 4.0 Licensed | <a href="https://beian.miit.gov.cn/" target="_blank">苏ICP备2023001491号-1</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.7c22909a.js" defer></script><script src="/assets/js/2.6758ed52.js" defer></script><script src="/assets/js/37.9fbc624d.js" defer></script>
  </body>
</html>

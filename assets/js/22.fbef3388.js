(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{348:function(t,a,p){"use strict";p.r(a);var v=p(7),_=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"进程的基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程的基本概念"}},[t._v("#")]),t._v(" 进程的基本概念")]),t._v(" "),a("p",[t._v("进程是可并发执行的程序在某个数据集合上的一次计算活动，也是操作系统进行资源分配和保护的基本单位。进程是一个既能用来共享资源，又能描述程序并发执行过程的一个基本单位。")]),t._v(" "),a("h2",{attrs:{id:"进程控制块pcb"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程控制块pcb"}},[t._v("#")]),t._v(" 进程控制块 PCB")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static.pil0txia.com/picgo/image-20220926164342078.png",alt:"image-20220926164342078"}})]),t._v(" "),a("p",[t._v("正是因为有了 PCB，可以记录任意时刻下进程的状态。所谓的调度就是进程在运行中被中断，但 PCB 可以记录此时进程的状态。所以进程是 “动态” 的。")]),t._v(" "),a("blockquote",[a("p",[t._v("简答题 “程序为什么不能被调度 + 进程为什么可以并发执行” 是捆绑在一起的。")])]),t._v(" "),a("p",[t._v("父 / 子标识指向父 / 子进程的 PID")]),t._v(" "),a("ul",[a("li",[t._v("进程调度信息")])]),t._v(" "),a("p",[t._v("进程的状态：三态、五态、七态")]),t._v(" "),a("p",[t._v("进程的优先级：一个整数")]),t._v(" "),a("p",[t._v("进程调度需要的信息：如等待 CPU 的时间、执行 CPU 的时间等等，是调度的一个参考。")]),t._v(" "),a("p",[t._v("阻塞原因：执行 -> 阻塞状态转换发生的事件")]),t._v(" "),a("ul",[a("li",[t._v("进程的控制信息")])]),t._v(" "),a("p",[t._v("程序和数据在内存、外存的地址")]),t._v(" "),a("p",[t._v("进程同步和通信机制")]),t._v(" "),a("p",[t._v("资源清单：列出除了 CPU 以外进程所需资源和已经拿到的资源。")]),t._v(" "),a("p",[t._v("链接指针：指出本进程的 pcb 在 pcb 队列中下一个进程的 pcb 首地址")]),t._v(" "),a("h2",{attrs:{id:"进程控制块pcb的组织方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程控制块pcb的组织方式"}},[t._v("#")]),t._v(" 进程控制块 PCB 的组织方式")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static.pil0txia.com/picgo/image-20220926165848247.png",alt:"image-20220926165848247"}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static.pil0txia.com/picgo/image-20220926170442110.png",alt:"image-20220926170442110"}})])])}),[],!1,null,null,null);a.default=_.exports}}]);
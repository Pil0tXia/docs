(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{353:function(t,v,_){"use strict";_.r(v);var s=_(7),r=Object(s.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程"}},[t._v("#")]),t._v(" 线程")]),t._v(" "),v("h2",{attrs:{id:"引入线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#引入线程"}},[t._v("#")]),t._v(" 引入线程")]),t._v(" "),v("p",[t._v("首先回忆一下为什么会有进程 —— 在以前，程序是串行执行的，为了让多道程序并发执行，引入了进程。进程虽然显著提高了资源利用率和系统吞吐量，满足了并发的需求，但是这种并发能不能做得更好呢？事实上，进程"),v("strong",[t._v("既是一个携带资源的独立单位，也是独立调度的基本单位")]),t._v("，因此，在进程的创建、撤销和切换时，系统必须为之付出较大的时间空间开销。鉴于此，系统不宜设置过多的进程，也不宜频繁地切换进程，这对于并发来说是一种限制。")]),t._v(" "),v("p",[t._v("如何解决这个问题呢？可以把进程看作是管理初创公司的老板，一开始人手不足，老板既要管理公司，也要四处奔跑沟通业务；但是一旦人手充足，那么老板仍然可以管理公司，只是沟通业务的工作就可以交给手下人去执行了。同理，我们可以考虑依然让进程作为拥有资源的独立单位，但是独立调度的基本单位则不再是进程，而是新引入的"),v("strong",[t._v("线程")]),t._v("了。")]),t._v(" "),v("h2",{attrs:{id:"线程与进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程与进程"}},[t._v("#")]),t._v(" 线程与进程")]),t._v(" "),v("p",[v("strong",[t._v("调度的基本单位")])]),t._v(" "),v("p",[t._v("引入线程后，调度的基本单位不再是进程，而是线程。线程能够独立运行，且切换的时候，代价远远小于进程切换的代价。同一进程不同线程的切换，不会引起进程的切换。")]),t._v(" "),v("p",[v("strong",[t._v("执行的基本单位")])]),t._v(" "),v("p",[t._v("我们可以说进程处于 “执行” 状态，但其实指的是该进程的某个线程正在执行；可以说进程处于 “挂起” 状态，但其实指的是该进程的所有线程都被挂起。但我们不能说 “挂起线程”，只能说 “挂起进程”，因为我们只有在无法为进程分配资源时才会将其挂起，而线程并不携带资源，“挂起线程” 没有意义。")]),t._v(" "),v("p",[v("strong",[t._v("并发性")])]),t._v(" "),v("p",[t._v("进程间仍然能够并发，不仅如此，同一进程内不需要切换进程运行环境和内存地址空间，一个进程中的多个线程间也能并发，不同进程中的线程也能够并发，系统并发性提升。")]),t._v(" "),v("p",[v("strong",[t._v("资源")])]),t._v(" "),v("p",[t._v("资源由进程携带。为了性能考虑，线程仅占有一点必不可少的资源（比如 TCB，程序计数器等）。虽然线程不携带资源，但它可以使用 fork 的进程的资源，即同一进程的线程共享该进程所拥有的资源。另外，这些线程还共享同一片内存地址空间，所以也可以方便地进行通信。")]),t._v(" "),v("p",[v("strong",[t._v("系统开销")])]),t._v(" "),v("p",[t._v("在创建和撤销进程时，系统需要分配或者回收 PCB，分配或者回收资源，所以需要付出一定的时空开销；但是同一进程下的各个线程共享内存空间，线程的创建、撤销和通信的时空开销则小很多。")]),t._v(" "),v("blockquote",[v("p",[v("strong",[t._v("独立性")])]),t._v(" "),v("p",[t._v("同一进程中的线程间独立性要比不同进程间独立性低很多。前者独立性高，因为要防止进程之间彼此干扰和破坏；后者独立性低，因为同一进程的多个线程通常需要协作完成任务，互相之间可访问程度相对来说会比较高。")]),t._v(" "),v("p",[v("strong",[t._v("支持多处理机系统")])]),t._v(" "),v("p",[t._v("传统的单线程进程，即使处理机再多，一个进程也只能运行在一个处理机上；但是引入了线程后，一个进程的多个线程可以分配到多个处理机上、并行执行。")])]),t._v(" "),v("h2",{attrs:{id:"线程的状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程的状态"}},[t._v("#")]),t._v(" 线程的状态")]),t._v(" "),v("p",[t._v("线程的状态有：运行、就绪和阻塞，线程的状态转换也类似于进程。")])])}),[],!1,null,null,null);v.default=r.exports}}]);
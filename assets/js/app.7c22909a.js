(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,i,s=e[0],l=e[1],c=e[2],u=0,d=[];u<s.length;u++)i=s[u],Object.prototype.hasOwnProperty.call(a,i)&&a[i]&&d.push(a[i][0]),a[i]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(p&&p(e);d.length;)d.shift()();return o.push.apply(o,c||[]),t()}function t(){for(var n,e=0;e<o.length;e++){for(var t=o[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==a[l]&&(r=!1)}r&&(o.splice(e--,1),n=i(i.s=t[0]))}return n}var r={},a={1:0},o=[];function i(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}i.e=function(n){var e=[],t=a[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=a[n]=[e,r]}));e.push(t[2]=r);var o,s=document.createElement("script");s.charset="utf-8",s.timeout=120,i.nc&&s.setAttribute("nonce",i.nc),s.src=function(n){return i.p+"assets/js/"+({}[n]||n)+"."+{2:"6758ed52",3:"0aad90a7",4:"3055ae5e",5:"e24581f1",6:"a90a255b",7:"2fb00079",8:"a4338d2b",9:"f988ec8a",10:"e24f1e40",11:"05cb0029",12:"32af8044",13:"700f1625",14:"41717448",15:"ecaf38f1",16:"f4a2e8fe",17:"dd141a48",18:"d4b349b0",19:"e768f6f2",20:"258fe436",21:"e2e83218",22:"fbef3388",23:"0823fda8",24:"f2106677",25:"d1029eac",26:"de8ada83",27:"5542150b",28:"73bc9881",29:"dfc6d141",30:"875cb1d3",31:"12e24a9b",32:"3e6b9414",33:"ed53d32c",34:"24759155",35:"46746eb8",36:"752fb623",37:"9fbc624d",38:"e57c3e9a",39:"fe320339",40:"2cc14361",41:"69f063eb",42:"7e2baa49",43:"db617122",44:"a1fc3b4c",45:"966ef14f",46:"1b8df3ff",47:"19f52d31",48:"99209cdd",49:"e2fcc246",50:"1fb68e50",51:"8fb412d1",52:"7f71c13a",53:"a0638f3f",54:"197b3a4a",55:"8f0848d5",56:"2b6c22ee",57:"d3b95709",58:"477eda2a",59:"e0b4407a",60:"02ddfe44"}[n]+".js"}(n);var l=new Error;o=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=a[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),o=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+o+")",l.name="ChunkLoadError",l.type=r,l.request=o,t[1](l)}a[n]=void 0}};var c=setTimeout((function(){o({type:"timeout",target:s})}),12e4);s.onerror=s.onload=o,document.head.appendChild(s)}return Promise.all(e)},i.m=n,i.c=r,i.d=function(n,e,t){i.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},i.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},i.t=function(n,e){if(1&e&&(n=i(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)i.d(t,r,function(e){return n[e]}.bind(null,r));return t},i.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return i.d(e,"a",e),e},i.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},i.p="/",i.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var p=l;o.push([102,0]),t()}([function(n,e,t){var r=t(55),a=r.all;n.exports=r.IS_HTMLDDA?function(n){return"function"==typeof n||n===a}:function(n){return"function"==typeof n}},function(n,e,t){var r=t(27),a=Function.prototype,o=a.call,i=r&&a.bind.bind(o,o);n.exports=r?i:function(n){return function(){return o.apply(n,arguments)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var r=t(2);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(69),a="object"==typeof self&&self&&self.Object===Object&&self,o=r||a||Function("return this")();n.exports=o},function(n,e,t){"use strict";function r(n,e,t,r,a,o,i,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),o&&(c._scopeId="data-v-"+o),i?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),a&&a.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(i)},c._ssrRegister=l):a&&(l=s?function(){a.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:a),l)if(c.functional){c._injectStyles=l;var p=c.render;c.render=function(n,e){return l.call(e),p(n,e)}}else{var u=c.beforeCreate;c.beforeCreate=u?[].concat(u,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){var r=t(1),a=t(31),o=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return o(a(n),e)}},function(n,e,t){var r=t(0),a=t(55),o=a.all;n.exports=a.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:r(n)||n===o}:function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(162),a=t(165);n.exports=function(n,e){var t=a(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return o})),t.d(e,"j",(function(){return i})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return p})),t.d(e,"c",(function(){return u})),t.d(e,"f",(function(){return d})),t.d(e,"l",(function(){return f})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return v})),t.d(e,"k",(function(){return g})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return y}));t(16);const r=/#.*$/,a=/\.(md|html)$/,o=/\/$/,i=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(r,"").replace(a,"")}function l(n){return i.test(n)}function c(n){return/^mailto:/.test(n)}function p(n){return/^tel:/.test(n)}function u(n){if(l(n))return n;if(!n)return"404";const e=n.match(r),t=e?e[0]:"",a=s(n);return o.test(a)?n:a+".html"+t}function d(n,e){const t=n.hash,a=function(n){const e=n&&n.match(r);if(e)return e[0]}(e);if(a&&t!==a)return!1;return s(n.path)===s(e)}function f(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;const a=e.split("/");t&&a[a.length-1]||a.pop();const o=n.replace(/^\//,"").split("/");for(let n=0;n<o.length;n++){const e=o[n];".."===e?a.pop():"."!==e&&a.push(e)}""!==a[0]&&a.unshift("");return a.join("/")}(e,t));const r=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===r)return Object.assign({},n[e],{type:"page",path:u(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,r){const{pages:a,themeConfig:o}=t,i=r&&o.locales&&o.locales[r]||o;if("auto"===(n.frontmatter.sidebar||i.sidebar||o.sidebar))return m(n);const s=i.sidebar||o.sidebar;if(s){const{base:t,config:r}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const r in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(r)))return{base:r,config:e[r]};var t;return{}}(e,s);return"auto"===r?m(n):r?r.map(n=>function n(e,t,r,a=1){if("string"==typeof e)return f(t,e,r);if(Array.isArray(e))return Object.assign(f(t,e[0],r),{title:e[1]});{a>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const o=e.children||[];return 0===o.length&&e.path?Object.assign(f(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:o.map(e=>n(e,t,r,a+1)),collapsable:!1!==e.collapsable}}}(n,a,t)):[]}return[]}function m(n){const e=v(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function v(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function g(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function x(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function y(n,e){return x(e)-x(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var r=t(15),a=t(147),o=t(148),i=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":i&&i in Object(n)?a(n):o(n)}},function(n,e,t){var r=t(4),a=t(17),o=t(34);n.exports=r?function(n,e,t){return a.f(n,e,o(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var r=t(6).Symbol;n.exports=r},function(n,e,t){"use strict";var r=t(26),a=t(31),o=t(32),i=t(127),s=t(129);r({target:"Array",proto:!0,arity:1,forced:t(2)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=a(this),t=o(e),r=arguments.length;s(t+r);for(var l=0;l<r;l++)e[t]=arguments[l],t++;return i(e,t),t}})},function(n,e,t){var r=t(4),a=t(64),o=t(98),i=t(25),s=t(54),l=TypeError,c=Object.defineProperty,p=Object.getOwnPropertyDescriptor;e.f=r?o?function(n,e,t){if(i(n),e=s(e),i(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=p(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(i(n),e=s(e),i(t),a)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(1),a=r({}.toString),o=r("".slice);n.exports=function(n){return o(a(n),8,-1)}},function(n,e,t){var r=t(152),a=t(153),o=t(154),i=t(155),s=t(156);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(71);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(10)(Object,"create");n.exports=r},function(n,e,t){var r=t(174);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(44);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var r,a;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(a="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function a(n,e,t){return n<e?e:n>t?t:n}function o(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=a(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),p=r.speed,u=r.easing;return l.offsetWidth,i((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var a;return(a="translate3d"===r.positionUsing?{transform:"translate3d("+o(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+o(n)+"%,0)"}:{"margin-left":o(n)+"%"}).transition="all "+e+"ms "+t,a}(n,p,u)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+p+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),p)}),p)):setTimeout(e,p)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*a(Math.random()*e,.1,.95)),e=a(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var a,i=e.querySelector(r.barSelector),l=n?"-100":o(t.status||0),p=document.querySelector(r.parent);return s(i,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(a=e.querySelector(r.spinnerSelector))&&d(a),p!=document.body&&c(p,"nprogress-custom-parent"),p.appendChild(e),e},t.remove=function(){p(document.documentElement,"nprogress-busy"),p(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&d(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var i=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,a=n.length,o=e.charAt(0).toUpperCase()+e.slice(1);a--;)if((r=n[a]+o)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,a,o=arguments;if(2==o.length)for(t in e)void 0!==(a=e[t])&&e.hasOwnProperty(t)&&r(n,t,a);else r(n,o[1],o[2])}}();function l(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=u(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function p(n,e){var t,r=u(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function d(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=a)},function(n,e,t){var r=t(9),a=String,o=TypeError;n.exports=function(n){if(r(n))return n;throw o(a(n)+" is not an object")}},function(n,e,t){var r=t(3),a=t(51).f,o=t(14),i=t(110),s=t(36),l=t(65),c=t(123);n.exports=function(n,e){var t,p,u,d,f,h=n.target,m=n.global,v=n.stat;if(t=m?r:v?r[h]||s(h,{}):(r[h]||{}).prototype)for(p in e){if(d=e[p],u=n.dontCallGetSet?(f=a(t,p))&&f.value:t[p],!c(m?p:h+(v?".":"#")+p,n.forced)&&void 0!==u){if(typeof d==typeof u)continue;l(d,u)}(n.sham||u&&u.sham)&&o(d,"sham",!0),i(t,p,d,n)}}},function(n,e,t){var r=t(2);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var r=t(46),a=t(52);n.exports=function(n){return r(a(n))}},function(n,e,t){var r=t(3),a=t(0),o=function(n){return a(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?o(r[n]):r[n]&&r[n][e]}},function(n,e,t){var r=t(3),a=t(61),o=t(8),i=t(63),s=t(59),l=t(58),c=r.Symbol,p=a("wks"),u=l?c.for||c:c&&c.withoutSetter||i;n.exports=function(n){return o(p,n)||(p[n]=s&&o(c,n)?c[n]:u("Symbol."+n)),p[n]}},function(n,e,t){var r=t(52),a=Object;n.exports=function(n){return a(r(n))}},function(n,e,t){var r=t(121);n.exports=function(n){return r(n.length)}},function(n,e,t){var r=t(27),a=Function.prototype.call;n.exports=r?a.bind(a):function(){return a.apply(a,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var r=t(3),a=t(36),o=r["__core-js_shared__"]||a("__core-js_shared__",{});n.exports=o},function(n,e,t){var r=t(3),a=Object.defineProperty;n.exports=function(n,e){try{a(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(146),a=t(12),o=Object.prototype,i=o.hasOwnProperty,s=o.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return a(n)&&i.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(10)(t(6),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(166),a=t(173),o=t(175),i=t(176),s=t(177);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(5),a=t(44),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,i=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!a(n))||(i.test(n)||!o.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(13),a=t(12);n.exports=function(n){return"symbol"==typeof n||a(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var r=t(1),a=t(2),o=t(18),i=Object,s=r("".split);n.exports=a((function(){return!i("z").propertyIsEnumerable(0)}))?function(n){return"String"==o(n)?s(n,""):i(n)}:i},function(n,e,t){var r=t(0),a=t(108),o=TypeError;n.exports=function(n){if(r(n))return n;throw o(a(n)+" is not a function")}},function(n,e){n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,a=/^0b[01]+$/i,o=/^0o[0-7]+$/i,i=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),p=Object.prototype.toString,u=Math.max,d=Math.min,f=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function m(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==p.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=a.test(n);return s||o.test(n)?i(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,a,o,i,s,l,c=0,p=!1,v=!1,g=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=r,o=a;return r=a=void 0,c=e,i=n.apply(o,t)}function x(n){return c=n,s=setTimeout(E,e),p?b(n):i}function y(n){var t=n-l;return void 0===l||t>=e||t<0||v&&n-c>=o}function E(){var n=f();if(y(n))return B(n);s=setTimeout(E,function(n){var t=e-(n-l);return v?d(t,o-(n-c)):t}(n))}function B(n){return s=void 0,g&&r?b(n):(r=a=void 0,i)}function P(){var n=f(),t=y(n);if(r=arguments,a=this,l=n,t){if(void 0===s)return x(l);if(v)return s=setTimeout(E,e),b(l)}return void 0===s&&(s=setTimeout(E,e)),i}return e=m(e)||0,h(t)&&(p=!!t.leading,o=(v="maxWait"in t)?u(m(t.maxWait)||0,e):o,g="trailing"in t?!!t.trailing:g),P.cancel=function(){void 0!==s&&clearTimeout(s),c=0,r=l=a=s=void 0},P.flush=function(){return void 0===s?i:B(f())},P}},function(n,e,t){var r=t(4),a=t(33),o=t(104),i=t(34),s=t(28),l=t(54),c=t(8),p=t(64),u=Object.getOwnPropertyDescriptor;e.f=r?u:function(n,e){if(n=s(n),e=l(e),p)try{return u(n,e)}catch(n){}if(c(n,e))return i(!a(o.f,n,e),n[e])}},function(n,e,t){var r=t(53),a=TypeError;n.exports=function(n){if(r(n))throw a("Can't call method on "+n);return n}},function(n,e){n.exports=function(n){return null==n}},function(n,e,t){var r=t(105),a=t(56);n.exports=function(n){var e=r(n,"string");return a(e)?e:e+""}},function(n,e){var t="object"==typeof document&&document.all,r=void 0===t&&void 0!==t;n.exports={all:t,IS_HTMLDDA:r}},function(n,e,t){var r=t(29),a=t(0),o=t(57),i=t(58),s=Object;n.exports=i?function(n){return"symbol"==typeof n}:function(n){var e=r("Symbol");return a(e)&&o(e.prototype,s(n))}},function(n,e,t){var r=t(1);n.exports=r({}.isPrototypeOf)},function(n,e,t){var r=t(59);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(60),a=t(2);n.exports=!!Object.getOwnPropertySymbols&&!a((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r,a,o=t(3),i=t(106),s=o.process,l=o.Deno,c=s&&s.versions||l&&l.version,p=c&&c.v8;p&&(a=(r=p.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!a&&i&&(!(r=i.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=i.match(/Chrome\/(\d+)/))&&(a=+r[1]),n.exports=a},function(n,e,t){var r=t(62),a=t(35);(n.exports=function(n,e){return a[n]||(a[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.27.2",mode:r?"pure":"global",copyright:"© 2014-2023 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.27.2/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var r=t(1),a=0,o=Math.random(),i=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+i(++a+o,36)}},function(n,e,t){var r=t(4),a=t(2),o=t(97);n.exports=!r&&!a((function(){return 7!=Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(8),a=t(116),o=t(51),i=t(17);n.exports=function(n,e,t){for(var s=a(e),l=i.f,c=o.f,p=0;p<s.length;p++){var u=s[p];r(n,u)||t&&r(t,u)||l(n,u,c(e,u))}}},function(n,e,t){var r=t(120);n.exports=function(n){var e=+n;return e!=e||0===e?0:r(e)}},function(n,e,t){var r=t(1),a=t(25),o=t(133);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return a(t),o(r),e?n(t,r):t.__proto__=r,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,a=n.length;++t<r;)n[a+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(19),a=t(157),o=t(158),i=t(159),s=t(160),l=t(161);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=a,c.prototype.delete=o,c.prototype.get=i,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(13),a=t(39);n.exports=function(n){if(!a(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(178),a=t(12);n.exports=function n(e,t,o,i,s){return e===t||(null==e||null==t||!a(e)&&!a(t)?e!=e&&t!=t:r(e,t,o,i,n,s))}},function(n,e,t){var r=t(76),a=t(181),o=t(77);n.exports=function(n,e,t,i,s,l){var c=1&t,p=n.length,u=e.length;if(p!=u&&!(c&&u>p))return!1;var d=l.get(n),f=l.get(e);if(d&&f)return d==e&&f==n;var h=-1,m=!0,v=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++h<p;){var g=n[h],b=e[h];if(i)var x=c?i(b,g,h,e,n,l):i(g,b,h,n,e,l);if(void 0!==x){if(x)continue;m=!1;break}if(v){if(!a(e,(function(n,e){if(!o(v,e)&&(g===n||s(g,n,t,i,l)))return v.push(e)}))){m=!1;break}}else if(g!==b&&!s(g,b,t,i,l)){m=!1;break}}return l.delete(n),l.delete(e),m}},function(n,e,t){var r=t(40),a=t(179),o=t(180);function i(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}i.prototype.add=i.prototype.push=a,i.prototype.has=o,n.exports=i},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(191),a=t(197),o=t(82);n.exports=function(n){return o(n)?r(n):a(n)}},function(n,e,t){(function(n){var r=t(6),a=t(193),o=e&&!e.nodeType&&e,i=o&&"object"==typeof n&&n&&!n.nodeType&&n,s=i&&i.exports===o?r.Buffer:void 0,l=(s?s.isBuffer:void 0)||a;n.exports=l}).call(this,t(49)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(194),a=t(195),o=t(196),i=o&&o.isTypedArray,s=i?a(i):r;n.exports=s},function(n,e,t){var r=t(72),a=t(42);n.exports=function(n){return null!=n&&a(n.length)&&!r(n)}},function(n,e,t){var r=t(10)(t(6),"Set");n.exports=r},function(n,e,t){var r=t(39);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(87),a=t(23);n.exports=function(n,e){for(var t=0,o=(e=r(e,n)).length;null!=n&&t<o;)n=n[a(e[t++])];return t&&t==o?n:void 0}},function(n,e,t){var r=t(5),a=t(43),o=t(208),i=t(211);n.exports=function(n,e){return r(n)?n:a(n,e)?[n]:o(i(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(144),a=t(149),o=t(220),i=t(228),s=t(237),l=t(101),c=o((function(n){var e=l(n);return s(e)&&(e=void 0),i(r(n,1,s,!0),a(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,a=r.exec(t);if(!a)return t;var o="",i=0,s=0;for(i=a.index;i<t.length;i++){switch(t.charCodeAt(i)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==i&&(o+=t.substring(s,i)),s=i+1,o+=e}return s!==i?o+t.substring(s,i):o}},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},a=(t(241),t(7)),o=Object(a.a)(r,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=o.exports},function(n,e,t){"use strict";t.r(e);var r={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},a=(t(242),t(7)),o=Object(a.a)(r,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,r){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=o.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var r=t(3),a=t(9),o=r.document,i=a(o)&&a(o.createElement);n.exports=function(n){return i?o.createElement(n):{}}},function(n,e,t){var r=t(4),a=t(2);n.exports=r&&a((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var r=t(61),a=t(63),o=r("keys");n.exports=function(n){return o[n]||(o[n]=a(n))}},function(n,e,t){var r=t(1),a=t(8),o=t(28),i=t(118).indexOf,s=t(48),l=r([].push);n.exports=function(n,e){var t,r=o(n),c=0,p=[];for(t in r)!a(s,t)&&a(r,t)&&l(p,t);for(;e.length>c;)a(r,t=e[c++])&&(~i(p,t)||l(p,t));return p}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(247)},function(n,e,t){"use strict";var r=t(26),a=t(124).left,o=t(125),i=t(60);r({target:"Array",proto:!0,forced:!t(126)&&i>79&&i<83||!o("reduce")},{reduce:function(n){var e=arguments.length;return a(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,a=Object.getOwnPropertyDescriptor,o=a&&!r.call({1:2},1);e.f=o?function(n){var e=a(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(33),a=t(9),o=t(56),i=t(107),s=t(109),l=t(30),c=TypeError,p=l("toPrimitive");n.exports=function(n,e){if(!a(n)||o(n))return n;var t,l=i(n,p);if(l){if(void 0===e&&(e="default"),t=r(l,n,e),!a(t)||o(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e){n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,e,t){var r=t(47),a=t(53);n.exports=function(n,e){var t=n[e];return a(t)?void 0:r(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var r=t(33),a=t(0),o=t(9),i=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&a(t=n.toString)&&!o(s=r(t,n)))return s;if(a(t=n.valueOf)&&!o(s=r(t,n)))return s;if("string"!==e&&a(t=n.toString)&&!o(s=r(t,n)))return s;throw i("Can't convert object to primitive value")}},function(n,e,t){var r=t(0),a=t(17),o=t(111),i=t(36);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(r(t)&&o(t,c,s),s.global)l?n[e]=t:i(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:a.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){var r=t(1),a=t(2),o=t(0),i=t(8),s=t(4),l=t(112).CONFIGURABLE,c=t(113),p=t(114),u=p.enforce,d=p.get,f=String,h=Object.defineProperty,m=r("".slice),v=r("".replace),g=r([].join),b=s&&!a((function(){return 8!==h((function(){}),"length",{value:8}).length})),x=String(String).split("String"),y=n.exports=function(n,e,t){"Symbol("===m(f(e),0,7)&&(e="["+v(f(e),/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!i(n,"name")||l&&n.name!==e)&&(s?h(n,"name",{value:e,configurable:!0}):n.name=e),b&&t&&i(t,"arity")&&n.length!==t.arity&&h(n,"length",{value:t.arity});try{t&&i(t,"constructor")&&t.constructor?s&&h(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var r=u(n);return i(r,"source")||(r.source=g(x,"string"==typeof e?e:"")),n};Function.prototype.toString=y((function(){return o(this)&&d(this).source||c(this)}),"toString")},function(n,e,t){var r=t(4),a=t(8),o=Function.prototype,i=r&&Object.getOwnPropertyDescriptor,s=a(o,"name"),l=s&&"something"===function(){}.name,c=s&&(!r||r&&i(o,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var r=t(1),a=t(0),o=t(35),i=r(Function.toString);a(o.inspectSource)||(o.inspectSource=function(n){return i(n)}),n.exports=o.inspectSource},function(n,e,t){var r,a,o,i=t(115),s=t(3),l=t(9),c=t(14),p=t(8),u=t(35),d=t(99),f=t(48),h=s.TypeError,m=s.WeakMap;if(i||u.state){var v=u.state||(u.state=new m);v.get=v.get,v.has=v.has,v.set=v.set,r=function(n,e){if(v.has(n))throw h("Object already initialized");return e.facade=n,v.set(n,e),e},a=function(n){return v.get(n)||{}},o=function(n){return v.has(n)}}else{var g=d("state");f[g]=!0,r=function(n,e){if(p(n,g))throw h("Object already initialized");return e.facade=n,c(n,g,e),e},a=function(n){return p(n,g)?n[g]:{}},o=function(n){return p(n,g)}}n.exports={set:r,get:a,has:o,enforce:function(n){return o(n)?a(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=a(e)).type!==n)throw h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var r=t(3),a=t(0),o=r.WeakMap;n.exports=a(o)&&/native code/.test(String(o))},function(n,e,t){var r=t(29),a=t(1),o=t(117),i=t(122),s=t(25),l=a([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=o.f(s(n)),t=i.f;return t?l(e,t(n)):e}},function(n,e,t){var r=t(100),a=t(96).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,a)}},function(n,e,t){var r=t(28),a=t(119),o=t(32),i=function(n){return function(e,t,i){var s,l=r(e),c=o(l),p=a(i,c);if(n&&t!=t){for(;c>p;)if((s=l[p++])!=s)return!0}else for(;c>p;p++)if((n||p in l)&&l[p]===t)return n||p||0;return!n&&-1}};n.exports={includes:i(!0),indexOf:i(!1)}},function(n,e,t){var r=t(66),a=Math.max,o=Math.min;n.exports=function(n,e){var t=r(n);return t<0?a(t+e,0):o(t,e)}},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?r:t)(e)}},function(n,e,t){var r=t(66),a=Math.min;n.exports=function(n){return n>0?a(r(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(2),a=t(0),o=/#|\.prototype\./,i=function(n,e){var t=l[s(n)];return t==p||t!=c&&(a(e)?r(e):!!e)},s=i.normalize=function(n){return String(n).replace(o,".").toLowerCase()},l=i.data={},c=i.NATIVE="N",p=i.POLYFILL="P";n.exports=i},function(n,e,t){var r=t(47),a=t(31),o=t(46),i=t(32),s=TypeError,l=function(n){return function(e,t,l,c){r(t);var p=a(e),u=o(p),d=i(p),f=n?d-1:0,h=n?-1:1;if(l<2)for(;;){if(f in u){c=u[f],f+=h;break}if(f+=h,n?f<0:d<=f)throw s("Reduce of empty array with no initial value")}for(;n?f>=0:d>f;f+=h)f in u&&(c=t(c,u[f],f,p));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var r=t(2);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var r=t(18);n.exports="undefined"!=typeof process&&"process"==r(process)},function(n,e,t){"use strict";var r=t(4),a=t(128),o=TypeError,i=Object.getOwnPropertyDescriptor,s=r&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(a(n)&&!i(n,"length").writable)throw o("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){var r=t(18);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,e){var t=TypeError;n.exports=function(n){if(n>9007199254740991)throw t("Maximum allowed index exceeded");return n}},function(n,e,t){var r=t(26),a=t(3),o=t(131),i=t(132),s=a.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=i(n,e,l),r({global:!0,constructor:!0,arity:1,forced:l},t)},p=function(n,e){if(s&&s[n]){var t={};t[n]=i("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return o(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return o(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return o(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return o(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return o(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return o(n,this,arguments)}})),c("URIError",(function(n){return function(e){return o(n,this,arguments)}})),p("CompileError",(function(n){return function(e){return o(n,this,arguments)}})),p("LinkError",(function(n){return function(e){return o(n,this,arguments)}})),p("RuntimeError",(function(n){return function(e){return o(n,this,arguments)}}))},function(n,e,t){var r=t(27),a=Function.prototype,o=a.apply,i=a.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?i.bind(o):function(){return i.apply(o,arguments)})},function(n,e,t){"use strict";var r=t(29),a=t(8),o=t(14),i=t(57),s=t(67),l=t(65),c=t(134),p=t(135),u=t(136),d=t(140),f=t(141),h=t(4),m=t(62);n.exports=function(n,e,t,v){var g=v?2:1,b=n.split("."),x=b[b.length-1],y=r.apply(null,b);if(y){var E=y.prototype;if(!m&&a(E,"cause")&&delete E.cause,!t)return y;var B=r("Error"),P=e((function(n,e){var t=u(v?e:n,void 0),r=v?new y(n):new y;return void 0!==t&&o(r,"message",t),f(r,P,r.stack,2),this&&i(E,this)&&p(r,this,P),arguments.length>g&&d(r,arguments[g]),r}));if(P.prototype=E,"Error"!==x?s?s(P,B):l(P,B,{name:!0}):h&&"stackTraceLimit"in y&&(c(P,y,"stackTraceLimit"),c(P,y,"prepareStackTrace")),l(P,y),!m)try{E.name!==x&&o(E,"name",x),E.constructor=P}catch(n){}return P}}},function(n,e,t){var r=t(0),a=String,o=TypeError;n.exports=function(n){if("object"==typeof n||r(n))return n;throw o("Can't set "+a(n)+" as a prototype")}},function(n,e,t){var r=t(17).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var r=t(0),a=t(9),o=t(67);n.exports=function(n,e,t){var i,s;return o&&r(i=e.constructor)&&i!==t&&a(s=i.prototype)&&s!==t.prototype&&o(n,s),n}},function(n,e,t){var r=t(137);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){var r=t(138),a=String;n.exports=function(n){if("Symbol"===r(n))throw TypeError("Cannot convert a Symbol value to a string");return a(n)}},function(n,e,t){var r=t(139),a=t(0),o=t(18),i=t(30)("toStringTag"),s=Object,l="Arguments"==o(function(){return arguments}());n.exports=r?o:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),i))?t:l?o(e):"Object"==(r=o(e))&&a(e.callee)?"Arguments":r}},function(n,e,t){var r={};r[t(30)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){var r=t(9),a=t(14);n.exports=function(n,e){r(e)&&"cause"in e&&a(n,"cause",e.cause)}},function(n,e,t){var r=t(14),a=t(142),o=t(143),i=Error.captureStackTrace;n.exports=function(n,e,t,s){o&&(i?i(n,e):r(n,"stack",a(t,s)))}},function(n,e,t){var r=t(1),a=Error,o=r("".replace),i=String(a("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(i);n.exports=function(n,e){if(l&&"string"==typeof n&&!a.prepareStackTrace)for(;e--;)n=o(n,s,"");return n}},function(n,e,t){var r=t(2),a=t(34);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",a(1,7)),7!==n.stack)}))},function(n,e,t){var r=t(68),a=t(145);n.exports=function n(e,t,o,i,s){var l=-1,c=e.length;for(o||(o=a),s||(s=[]);++l<c;){var p=e[l];t>0&&o(p)?t>1?n(p,t-1,o,i,s):r(s,p):i||(s[s.length]=p)}return s}},function(n,e,t){var r=t(15),a=t(37),o=t(5),i=r?r.isConcatSpreadable:void 0;n.exports=function(n){return o(n)||a(n)||!!(i&&n&&n[i])}},function(n,e,t){var r=t(13),a=t(12);n.exports=function(n){return a(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(15),a=Object.prototype,o=a.hasOwnProperty,i=a.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=o.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var a=i.call(n);return r&&(e?n[s]=t:delete n[s]),a}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(150),a=t(206),o=t(45),i=t(5),s=t(217);n.exports=function(n){return"function"==typeof n?n:null==n?o:"object"==typeof n?i(n)?a(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(151),a=t(205),o=t(85);n.exports=function(n){var e=a(n);return 1==e.length&&e[0][2]?o(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(70),a=t(74);n.exports=function(n,e,t,o){var i=t.length,s=i,l=!o;if(null==n)return!s;for(n=Object(n);i--;){var c=t[i];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++i<s;){var p=(c=t[i])[0],u=n[p],d=c[1];if(l&&c[2]){if(void 0===u&&!(p in n))return!1}else{var f=new r;if(o)var h=o(u,d,p,n,e,f);if(!(void 0===h?a(d,u,3,o,f):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(20),a=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():a.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(20);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(20);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(20);n.exports=function(n,e){var t=this.__data__,a=r(t,n);return a<0?(++this.size,t.push([n,e])):t[a][1]=e,this}},function(n,e,t){var r=t(19);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(19),a=t(38),o=t(40);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var i=t.__data__;if(!a||i.length<199)return i.push([n,e]),this.size=++t.size,this;t=this.__data__=new o(i)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(72),a=t(163),o=t(39),i=t(73),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,p=l.toString,u=c.hasOwnProperty,d=RegExp("^"+p.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!o(n)||a(n))&&(r(n)?d:s).test(i(n))}},function(n,e,t){var r,a=t(164),o=(r=/[^.]+$/.exec(a&&a.keys&&a.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!o&&o in n}},function(n,e,t){var r=t(6)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(167),a=t(19),o=t(38);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(o||a),string:new r}}},function(n,e,t){var r=t(168),a=t(169),o=t(170),i=t(171),s=t(172);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(21);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(21),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return a.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(21),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:a.call(e,n)}},function(n,e,t){var r=t(21);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(22);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(22);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(22);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(22);n.exports=function(n,e){var t=r(this,n),a=t.size;return t.set(n,e),this.size+=t.size==a?0:1,this}},function(n,e,t){var r=t(70),a=t(75),o=t(182),i=t(185),s=t(201),l=t(5),c=t(79),p=t(81),u="[object Object]",d=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,f,h,m){var v=l(n),g=l(e),b=v?"[object Array]":s(n),x=g?"[object Array]":s(e),y=(b="[object Arguments]"==b?u:b)==u,E=(x="[object Arguments]"==x?u:x)==u,B=b==x;if(B&&c(n)){if(!c(e))return!1;v=!0,y=!1}if(B&&!y)return m||(m=new r),v||p(n)?a(n,e,t,f,h,m):o(n,e,b,t,f,h,m);if(!(1&t)){var P=y&&d.call(n,"__wrapped__"),_=E&&d.call(e,"__wrapped__");if(P||_){var C=P?n.value():n,A=_?e.value():e;return m||(m=new r),h(C,A,t,f,m)}}return!!B&&(m||(m=new r),i(n,e,t,f,h,m))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(15),a=t(183),o=t(71),i=t(75),s=t(184),l=t(41),c=r?r.prototype:void 0,p=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,u,d){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new a(n),new a(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return o(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var f=s;case"[object Set]":var h=1&r;if(f||(f=l),n.size!=e.size&&!h)return!1;var m=d.get(n);if(m)return m==e;r|=2,d.set(n,e);var v=i(f(n),f(e),r,c,u,d);return d.delete(n),v;case"[object Symbol]":if(p)return p.call(n)==p.call(e)}return!1}},function(n,e,t){var r=t(6).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(186),a=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,o,i,s){var l=1&t,c=r(n),p=c.length;if(p!=r(e).length&&!l)return!1;for(var u=p;u--;){var d=c[u];if(!(l?d in e:a.call(e,d)))return!1}var f=s.get(n),h=s.get(e);if(f&&h)return f==e&&h==n;var m=!0;s.set(n,e),s.set(e,n);for(var v=l;++u<p;){var g=n[d=c[u]],b=e[d];if(o)var x=l?o(b,g,d,e,n,s):o(g,b,d,n,e,s);if(!(void 0===x?g===b||i(g,b,t,o,s):x)){m=!1;break}v||(v="constructor"==d)}if(m&&!v){var y=n.constructor,E=e.constructor;y==E||!("constructor"in n)||!("constructor"in e)||"function"==typeof y&&y instanceof y&&"function"==typeof E&&E instanceof E||(m=!1)}return s.delete(n),s.delete(e),m}},function(n,e,t){var r=t(187),a=t(188),o=t(78);n.exports=function(n){return r(n,o,a)}},function(n,e,t){var r=t(68),a=t(5);n.exports=function(n,e,t){var o=e(n);return a(n)?o:r(o,t(n))}},function(n,e,t){var r=t(189),a=t(190),o=Object.prototype.propertyIsEnumerable,i=Object.getOwnPropertySymbols,s=i?function(n){return null==n?[]:(n=Object(n),r(i(n),(function(e){return o.call(n,e)})))}:a;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=0,o=[];++t<r;){var i=n[t];e(i,t,n)&&(o[a++]=i)}return o}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(192),a=t(37),o=t(5),i=t(79),s=t(80),l=t(81),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=o(n),p=!t&&a(n),u=!t&&!p&&i(n),d=!t&&!p&&!u&&l(n),f=t||p||u||d,h=f?r(n.length,String):[],m=h.length;for(var v in n)!e&&!c.call(n,v)||f&&("length"==v||u&&("offset"==v||"parent"==v)||d&&("buffer"==v||"byteLength"==v||"byteOffset"==v)||s(v,m))||h.push(v);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(13),a=t(42),o=t(12),i={};i["[object Float32Array]"]=i["[object Float64Array]"]=i["[object Int8Array]"]=i["[object Int16Array]"]=i["[object Int32Array]"]=i["[object Uint8Array]"]=i["[object Uint8ClampedArray]"]=i["[object Uint16Array]"]=i["[object Uint32Array]"]=!0,i["[object Arguments]"]=i["[object Array]"]=i["[object ArrayBuffer]"]=i["[object Boolean]"]=i["[object DataView]"]=i["[object Date]"]=i["[object Error]"]=i["[object Function]"]=i["[object Map]"]=i["[object Number]"]=i["[object Object]"]=i["[object RegExp]"]=i["[object Set]"]=i["[object String]"]=i["[object WeakMap]"]=!1,n.exports=function(n){return o(n)&&a(n.length)&&!!i[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(69),a=e&&!e.nodeType&&e,o=a&&"object"==typeof n&&n&&!n.nodeType&&n,i=o&&o.exports===a&&r.process,s=function(){try{var n=o&&o.require&&o.require("util").types;return n||i&&i.binding&&i.binding("util")}catch(n){}}();n.exports=s}).call(this,t(49)(n))},function(n,e,t){var r=t(198),a=t(199),o=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return a(n);var e=[];for(var t in Object(n))o.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(200)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(202),a=t(38),o=t(203),i=t(83),s=t(204),l=t(13),c=t(73),p=c(r),u=c(a),d=c(o),f=c(i),h=c(s),m=l;(r&&"[object DataView]"!=m(new r(new ArrayBuffer(1)))||a&&"[object Map]"!=m(new a)||o&&"[object Promise]"!=m(o.resolve())||i&&"[object Set]"!=m(new i)||s&&"[object WeakMap]"!=m(new s))&&(m=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case p:return"[object DataView]";case u:return"[object Map]";case d:return"[object Promise]";case f:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=m},function(n,e,t){var r=t(10)(t(6),"DataView");n.exports=r},function(n,e,t){var r=t(10)(t(6),"Promise");n.exports=r},function(n,e,t){var r=t(10)(t(6),"WeakMap");n.exports=r},function(n,e,t){var r=t(84),a=t(78);n.exports=function(n){for(var e=a(n),t=e.length;t--;){var o=e[t],i=n[o];e[t]=[o,i,r(i)]}return e}},function(n,e,t){var r=t(74),a=t(207),o=t(214),i=t(43),s=t(84),l=t(85),c=t(23);n.exports=function(n,e){return i(n)&&s(e)?l(c(n),e):function(t){var i=a(t,n);return void 0===i&&i===e?o(t,n):r(e,i,3)}}},function(n,e,t){var r=t(86);n.exports=function(n,e,t){var a=null==n?void 0:r(n,e);return void 0===a?t:a}},function(n,e,t){var r=t(209),a=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,i=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(a,(function(n,t,r,a){e.push(r?a.replace(o,"$1"):t||n)})),e}));n.exports=i},function(n,e,t){var r=t(210);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(40);function a(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,a=e?e.apply(this,r):r[0],o=t.cache;if(o.has(a))return o.get(a);var i=n.apply(this,r);return t.cache=o.set(a,i)||o,i};return t.cache=new(a.Cache||r),t}a.Cache=r,n.exports=a},function(n,e,t){var r=t(212);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(15),a=t(213),o=t(5),i=t(44),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(o(e))return a(e,n)+"";if(i(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=Array(r);++t<r;)a[t]=e(n[t],t,n);return a}},function(n,e,t){var r=t(215),a=t(216);n.exports=function(n,e){return null!=n&&a(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(87),a=t(37),o=t(5),i=t(80),s=t(42),l=t(23);n.exports=function(n,e,t){for(var c=-1,p=(e=r(e,n)).length,u=!1;++c<p;){var d=l(e[c]);if(!(u=null!=n&&t(n,d)))break;n=n[d]}return u||++c!=p?u:!!(p=null==n?0:n.length)&&s(p)&&i(d,p)&&(o(n)||a(n))}},function(n,e,t){var r=t(218),a=t(219),o=t(43),i=t(23);n.exports=function(n){return o(n)?r(i(n)):a(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(86);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(45),a=t(221),o=t(223);n.exports=function(n,e){return o(a(n,e,r),n+"")}},function(n,e,t){var r=t(222),a=Math.max;n.exports=function(n,e,t){return e=a(void 0===e?n.length-1:e,0),function(){for(var o=arguments,i=-1,s=a(o.length-e,0),l=Array(s);++i<s;)l[i]=o[e+i];i=-1;for(var c=Array(e+1);++i<e;)c[i]=o[i];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(224),a=t(227)(r);n.exports=a},function(n,e,t){var r=t(225),a=t(226),o=t(45),i=a?function(n,e){return a(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:o;n.exports=i},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(10),a=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=a},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var a=t(),o=16-(a-r);if(r=a,o>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(76),a=t(229),o=t(234),i=t(77),s=t(235),l=t(41);n.exports=function(n,e,t){var c=-1,p=a,u=n.length,d=!0,f=[],h=f;if(t)d=!1,p=o;else if(u>=200){var m=e?null:s(n);if(m)return l(m);d=!1,p=i,h=new r}else h=e?[]:f;n:for(;++c<u;){var v=n[c],g=e?e(v):v;if(v=t||0!==v?v:0,d&&g==g){for(var b=h.length;b--;)if(h[b]===g)continue n;e&&h.push(g),f.push(v)}else p(h,g,t)||(h!==f&&h.push(g),f.push(v))}return f}},function(n,e,t){var r=t(230);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(231),a=t(232),o=t(233);n.exports=function(n,e,t){return e==e?o(n,e,t):r(n,a,t)}},function(n,e){n.exports=function(n,e,t,r){for(var a=n.length,o=t+(r?1:-1);r?o--:++o<a;)if(e(n[o],o,n))return o;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,a=n.length;++r<a;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,a=null==n?0:n.length;++r<a;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(83),a=t(236),o=t(41),i=r&&1/o(new r([,-0]))[1]==1/0?function(n){return new r(n)}:a;n.exports=i},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(82),a=t(12);n.exports=function(n){return a(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e){},function(n,e,t){"use strict";t(88)},function(n,e,t){"use strict";t(89)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(90)},function(n,e,t){"use strict";t(91)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({}),a=Array.isArray;function o(n){return null==n}function i(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function p(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function d(n){return"[object Object]"===u.call(n)}function f(n){return"[object RegExp]"===u.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function m(n){return i(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function v(n){return null==n?"":Array.isArray(n)||d(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function g(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),r=n.split(","),a=0;a<r.length;a++)t[r[a]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var x=b("key,ref,slot,slot-scope,is");function y(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var r=n.indexOf(e);if(r>-1)return n.splice(r,1)}}var E=Object.prototype.hasOwnProperty;function B(n,e){return E.call(n,e)}function P(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var _=/-(\w)/g,C=P((function(n){return n.replace(_,(function(n,e){return e?e.toUpperCase():""}))})),A=P((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),w=/\B([A-Z])/g,S=P((function(n){return n.replace(w,"-$1").toLowerCase()}));var k=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function T(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function I(n,e){for(var t in e)n[t]=e[t];return n}function j(n){for(var e={},t=0;t<n.length;t++)n[t]&&I(e,n[t]);return e}function z(n,e,t){}var O=function(n,e,t){return!1},D=function(n){return n};function F(n,e){if(n===e)return!0;var t=p(n),r=p(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var a=Array.isArray(n),o=Array.isArray(e);if(a&&o)return n.length===e.length&&n.every((function(n,t){return F(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(a||o)return!1;var i=Object.keys(n),s=Object.keys(e);return i.length===s.length&&i.every((function(t){return F(n[t],e[t])}))}catch(n){return!1}}function U(n,e){for(var t=0;t<n.length;t++)if(F(n[t],e))return t;return-1}function $(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function L(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var R=["component","directive","filter"],M=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],N={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:O,isReservedAttr:O,isUnknownElement:O,getTagNamespace:z,parsePlatformTagName:D,mustUseProp:O,async:!0,_lifecycleHooks:M},V=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function H(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function q(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var K=new RegExp("[^".concat(V.source,".$_\\d]"));var X="__proto__"in{},Z="undefined"!=typeof window,W=Z&&window.navigator.userAgent.toLowerCase(),G=W&&/msie|trident/.test(W),J=W&&W.indexOf("msie 9.0")>0,Y=W&&W.indexOf("edge/")>0;W&&W.indexOf("android");var Q=W&&/iphone|ipad|ipod|ios/.test(W);W&&/chrome\/\d+/.test(W),W&&/phantomjs/.test(W);var nn,en=W&&W.match(/firefox\/(\d+)/),tn={}.watch,rn=!1;if(Z)try{var an={};Object.defineProperty(an,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,an)}catch(n){}var on=function(){return void 0===nn&&(nn=!Z&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=Z&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,pn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=null;function dn(n){void 0===n&&(n=null),n||un&&un._scope.off(),un=n,n&&n._scope.on()}var fn=function(){function n(n,e,t,r,a,o,i,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=a,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=i,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),hn=function(n){void 0===n&&(n="");var e=new fn;return e.text=n,e.isComment=!0,e};function mn(n){return new fn(void 0,void 0,void 0,String(n))}function vn(n){var e=new fn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var gn=0,bn=[],xn=function(){function n(){this._pending=!1,this.id=gn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,bn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,r=e.length;t<r;t++){0,e[t].update()}},n}();xn.target=null;var yn=[];function En(n){yn.push(n),xn.target=n}function Bn(){yn.pop(),xn.target=yn[yn.length-1]}var Pn=Array.prototype,_n=Object.create(Pn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=Pn[n];q(_n,n,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var a,o=e.apply(this,t),i=this.__ob__;switch(n){case"push":case"unshift":a=t;break;case"splice":a=t.slice(2)}return a&&i.observeArray(a),i.dep.notify(),o}))}));var Cn=Object.getOwnPropertyNames(_n),An={},wn=!0;function Sn(n){wn=n}var kn={notify:z,depend:z,addSub:z,removeSub:z},Tn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?kn:new xn,this.vmCount=0,q(n,"__ob__",this),a(n)){if(!t)if(X)n.__proto__=_n;else for(var r=0,o=Cn.length;r<o;r++){q(n,s=Cn[r],_n[s])}e||this.observeArray(n)}else{var i=Object.keys(n);for(r=0;r<i.length;r++){var s;jn(n,s=i[r],An,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)In(n[e],!1,this.mock)},n}();function In(n,e,t){return n&&B(n,"__ob__")&&n.__ob__ instanceof Tn?n.__ob__:!wn||!t&&on()||!a(n)&&!d(n)||!Object.isExtensible(n)||n.__v_skip||Ln(n)||n instanceof fn?void 0:new Tn(n,e,t)}function jn(n,e,t,r,o,i){var s=new xn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var c=l&&l.get,p=l&&l.set;c&&!p||t!==An&&2!==arguments.length||(t=n[e]);var u=!o&&In(t,!1,i);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return xn.target&&(s.depend(),u&&(u.dep.depend(),a(e)&&Dn(e))),Ln(e)&&!o?e.value:e},set:function(e){var r=c?c.call(n):t;if(L(r,e)){if(p)p.call(n,e);else{if(c)return;if(!o&&Ln(r)&&!Ln(e))return void(r.value=e);t=e}u=!o&&In(e,!1,i),s.notify()}}}),s}}function zn(n,e,t){if(!$n(n)){var r=n.__ob__;return a(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),r&&!r.shallow&&r.mock&&In(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||r&&r.vmCount?t:r?(jn(r.value,e,t,void 0,r.shallow,r.mock),r.dep.notify(),t):(n[e]=t,t)}}function On(n,e){if(a(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||$n(n)||B(n,e)&&(delete n[e],t&&t.dep.notify())}}function Dn(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),a(e)&&Dn(e)}function Fn(n){return Un(n,!0),q(n,"__v_isShallow",!0),n}function Un(n,e){if(!$n(n)){In(n,e,on());0}}function $n(n){return!(!n||!n.__v_isReadonly)}function Ln(n){return!(!n||!0!==n.__v_isRef)}function Rn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Ln(n))return n.value;var r=n&&n.__ob__;return r&&r.dep.depend(),n},set:function(n){var r=e[t];Ln(r)&&!Ln(n)?r.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Mn;var Nn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Mn,!n&&Mn&&(this.index=(Mn.scopes||(Mn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Mn;try{return Mn=this,n()}finally{Mn=e}}else 0},n.prototype.on=function(){Mn=this},n.prototype.off=function(){Mn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Vn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Hn=P((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function qn(n,e){function t(){var n=t.fns;if(!a(n))return we(n,null,arguments,e,"v-on handler");for(var r=n.slice(),o=0;o<r.length;o++)we(r[o],null,arguments,e,"v-on handler")}return t.fns=n,t}function Kn(n,e,t,r,a,i){var l,c,p,u;for(l in n)c=n[l],p=e[l],u=Hn(l),o(c)||(o(p)?(o(c.fns)&&(c=n[l]=qn(c,i)),s(u.once)&&(c=n[l]=a(u.name,c,u.capture)),t(u.name,c,u.capture,u.passive,u.params)):c!==p&&(p.fns=c,n[l]=p));for(l in e)o(n[l])&&r((u=Hn(l)).name,e[l],u.capture)}function Xn(n,e,t){var r;n instanceof fn&&(n=n.data.hook||(n.data.hook={}));var a=n[e];function l(){t.apply(this,arguments),y(r.fns,l)}o(a)?r=qn([l]):i(a.fns)&&s(a.merged)?(r=a).fns.push(l):r=qn([a,l]),r.merged=!0,n[e]=r}function Zn(n,e,t,r,a){if(i(e)){if(B(e,t))return n[t]=e[t],a||delete e[t],!0;if(B(e,r))return n[t]=e[r],a||delete e[r],!0}return!1}function Wn(n){return l(n)?[mn(n)]:a(n)?function n(e,t){var r,c,p,u,d=[];for(r=0;r<e.length;r++)o(c=e[r])||"boolean"==typeof c||(p=d.length-1,u=d[p],a(c)?c.length>0&&(Gn((c=n(c,"".concat(t||"","_").concat(r)))[0])&&Gn(u)&&(d[p]=mn(u.text+c[0].text),c.shift()),d.push.apply(d,c)):l(c)?Gn(u)?d[p]=mn(u.text+c):""!==c&&d.push(mn(c)):Gn(c)&&Gn(u)?d[p]=mn(u.text+c.text):(s(e._isVList)&&i(c.tag)&&o(c.key)&&i(t)&&(c.key="__vlist".concat(t,"_").concat(r,"__")),d.push(c)));return d}(n):void 0}function Gn(n){return i(n)&&i(n.text)&&!1===n.isComment}function Jn(n,e){var t,r,o,s,l=null;if(a(n)||"string"==typeof n)for(l=new Array(n.length),t=0,r=n.length;t<r;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(p(n))if(pn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),u=c.next();!u.done;)l.push(e(u.value,l.length)),u=c.next()}else for(o=Object.keys(n),l=new Array(o.length),t=0,r=o.length;t<r;t++)s=o[t],l[t]=e(n[s],s,t);return i(l)||(l=[]),l._isVList=!0,l}function Yn(n,e,t,r){var a,o=this.$scopedSlots[n];o?(t=t||{},r&&(t=I(I({},r),t)),a=o(t)||(c(e)?e():e)):a=this.$slots[n]||(c(e)?e():e);var i=t&&t.slot;return i?this.$createElement("template",{slot:i},a):a}function Qn(n){return Tt(this.$options,"filters",n,!0)||D}function ne(n,e){return a(n)?-1===n.indexOf(e):n!==e}function ee(n,e,t,r,a){var o=N.keyCodes[e]||t;return a&&r&&!N.keyCodes[e]?ne(a,r):o?ne(o,n):r?S(r)!==e:void 0===n}function te(n,e,t,r,o){if(t)if(p(t)){a(t)&&(t=j(t));var i=void 0,s=function(a){if("class"===a||"style"===a||x(a))i=n;else{var s=n.attrs&&n.attrs.type;i=r||N.mustUseProp(e,s,a)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=C(a),c=S(a);l in i||c in i||(i[a]=t[a],o&&((n.on||(n.on={}))["update:".concat(a)]=function(n){t[a]=n}))};for(var l in t)s(l)}else;return n}function re(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||oe(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),r}function ae(n,e,t){return oe(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function oe(n,e,t){if(a(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&ie(n[r],"".concat(e,"_").concat(r),t);else ie(n,e,t)}function ie(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function se(n,e){if(e)if(d(e)){var t=n.on=n.on?I({},n.on):{};for(var r in e){var a=t[r],o=e[r];t[r]=a?[].concat(a,o):o}}else;return n}function le(n,e,t,r){e=e||{$stable:!t};for(var o=0;o<n.length;o++){var i=n[o];a(i)?le(i,e,t):i&&(i.proxy&&(i.fn.proxy=!0),e[i.key]=i.fn)}return r&&(e.$key=r),e}function ce(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function pe(n,e){return"string"==typeof n?e+n:n}function ue(n){n._o=ae,n._n=g,n._s=v,n._l=Jn,n._t=Yn,n._q=F,n._i=U,n._m=re,n._f=Qn,n._k=ee,n._b=te,n._v=mn,n._e=hn,n._u=le,n._g=se,n._d=ce,n._p=pe}function de(n,e){if(!n||!n.length)return{};for(var t={},r=0,a=n.length;r<a;r++){var o=n[r],i=o.data;if(i&&i.attrs&&i.attrs.slot&&delete i.attrs.slot,o.context!==e&&o.fnContext!==e||!i||null==i.slot)(t.default||(t.default=[])).push(o);else{var s=i.slot,l=t[s]||(t[s]=[]);"template"===o.tag?l.push.apply(l,o.children||[]):l.push(o)}}for(var c in t)t[c].every(fe)&&delete t[c];return t}function fe(n){return n.isComment&&!n.asyncFactory||" "===n.text}function he(n){return n.isComment&&n.asyncFactory}function me(n,e,t,a){var o,i=Object.keys(t).length>0,s=e?!!e.$stable:!i,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&a&&a!==r&&l===a.$key&&!i&&!a.$hasNormal)return a;for(var c in o={},e)e[c]&&"$"!==c[0]&&(o[c]=ve(n,t,c,e[c]))}else o={};for(var p in t)p in o||(o[p]=ge(t,p));return e&&Object.isExtensible(e)&&(e._normalized=o),q(o,"$stable",s),q(o,"$key",l),q(o,"$hasNormal",i),o}function ve(n,e,t,r){var o=function(){var e=un;dn(n);var t=arguments.length?r.apply(null,arguments):r({}),o=(t=t&&"object"==typeof t&&!a(t)?[t]:Wn(t))&&t[0];return dn(e),t&&(!o||1===t.length&&o.isComment&&!he(o))?void 0:t};return r.proxy&&Object.defineProperty(e,t,{get:o,enumerable:!0,configurable:!0}),o}function ge(n,e){return function(){return n[e]}}function be(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};q(e,"_v_attr_proxy",!0),xe(e,n.$attrs,r,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||xe(n._listenersProxy={},n.$listeners,r,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||Ee(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:k(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Rn(n,e,t)}))}}}function xe(n,e,t,r,a){var o=!1;for(var i in e)i in n?e[i]!==t[i]&&(o=!0):(o=!0,ye(n,i,r,a));for(var i in n)i in e||(o=!0,delete n[i]);return o}function ye(n,e,t,r){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[r][e]}})}function Ee(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var Be=null;function Pe(n,e){return(n.__esModule||pn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),p(n)?e.extend(n):n}function _e(n){if(a(n))for(var e=0;e<n.length;e++){var t=n[e];if(i(t)&&(i(t.componentOptions)||he(t)))return t}}function Ce(n,e,t,r,u,d){return(a(t)||l(t))&&(u=r,r=t,t=void 0),s(d)&&(u=2),function(n,e,t,r,l){if(i(t)&&i(t.__ob__))return hn();i(t)&&i(t.is)&&(e=t.is);if(!e)return hn();0;a(r)&&c(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===l?r=Wn(r):1===l&&(r=function(n){for(var e=0;e<n.length;e++)if(a(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var u,d;if("string"==typeof e){var f=void 0;d=n.$vnode&&n.$vnode.ns||N.getTagNamespace(e),u=N.isReservedTag(e)?new fn(N.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!i(f=Tt(n.$options,"components",e))?new fn(e,t,r,void 0,void 0,n):yt(f,t,n,r,e)}else u=yt(e,t,n,r);return a(u)?u:i(u)?(i(d)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(i(e.children))for(var a=0,l=e.children.length;a<l;a++){var c=e.children[a];i(c.tag)&&(o(c.ns)||s(r)&&"svg"!==c.tag)&&n(c,t,r)}}(u,d),i(t)&&function(n){p(n.style)&&Ne(n.style);p(n.class)&&Ne(n.class)}(t),u):hn()}(n,e,t,r,u)}function Ae(n,e,t){En();try{if(e)for(var r=e;r=r.$parent;){var a=r.$options.errorCaptured;if(a)for(var o=0;o<a.length;o++)try{if(!1===a[o].call(r,n,e,t))return}catch(n){Se(n,r,"errorCaptured hook")}}Se(n,e,t)}finally{Bn()}}function we(n,e,t,r,a){var o;try{(o=t?n.apply(e,t):n.call(e))&&!o._isVue&&m(o)&&!o._handled&&(o.catch((function(n){return Ae(n,r,a+" (Promise/async)")})),o._handled=!0)}catch(n){Ae(n,r,a)}return o}function Se(n,e,t){if(N.errorHandler)try{return N.errorHandler.call(null,n,e,t)}catch(e){e!==n&&ke(e,null,"config.errorHandler")}ke(n,e,t)}function ke(n,e,t){if(!Z||"undefined"==typeof console)throw n;console.error(n)}var Te,Ie=!1,je=[],ze=!1;function Oe(){ze=!1;var n=je.slice(0);je.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var De=Promise.resolve();Te=function(){De.then(Oe),Q&&setTimeout(z)},Ie=!0}else if(G||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Te="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(Oe)}:function(){setTimeout(Oe,0)};else{var Fe=1,Ue=new MutationObserver(Oe),$e=document.createTextNode(String(Fe));Ue.observe($e,{characterData:!0}),Te=function(){Fe=(Fe+1)%2,$e.data=String(Fe)},Ie=!0}function Le(n,e){var t;if(je.push((function(){if(n)try{n.call(e)}catch(n){Ae(n,e,"nextTick")}else t&&t(e)})),ze||(ze=!0,Te()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Re(n){return function(e,t){if(void 0===t&&(t=un),t)return function(n,e,t){var r=n.$options;r[e]=At(r[e],t)}(t,n,e)}}Re("beforeMount"),Re("mounted"),Re("beforeUpdate"),Re("updated"),Re("beforeDestroy"),Re("destroyed"),Re("activated"),Re("deactivated"),Re("serverPrefetch"),Re("renderTracked"),Re("renderTriggered"),Re("errorCaptured");var Me=new cn;function Ne(n){return function n(e,t){var r,o,i=a(e);if(!i&&!p(e)||e.__v_skip||Object.isFrozen(e)||e instanceof fn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(i)for(r=e.length;r--;)n(e[r],t);else if(Ln(e))n(e.value,t);else for(o=Object.keys(e),r=o.length;r--;)n(e[o[r]],t)}(n,Me),Me.clear(),n}var Ve,He=0,qe=function(){function n(n,e,t,r,a){var o,i;o=this,void 0===(i=Mn&&!Mn._vm?Mn:n?n._scope:void 0)&&(i=Mn),i&&i.active&&i.effects.push(o),(this.vm=n)&&a&&(n._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++He,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!K.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=z)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;En(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Ae(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Ne(n),Bn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():dt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||p(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');we(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&y(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Ke(n,e){Ve.$on(n,e)}function Xe(n,e){Ve.$off(n,e)}function Ze(n,e){var t=Ve;return function r(){var a=e.apply(null,arguments);null!==a&&t.$off(n,r)}}function We(n,e,t){Ve=n,Kn(e,t||{},Ke,Xe,Ze,n),Ve=void 0}var Ge=null;function Je(n){var e=Ge;return Ge=n,function(){Ge=e}}function Ye(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Qe(n,e){if(e){if(n._directInactive=!1,Ye(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Qe(n.$children[t]);nt(n,"activated")}}function nt(n,e,t,r){void 0===r&&(r=!0),En();var a=un;r&&dn(n);var o=n.$options[e],i="".concat(e," hook");if(o)for(var s=0,l=o.length;s<l;s++)we(o[s],n,t||null,n,i);n._hasHookEvent&&n.$emit("hook:"+e),r&&dn(a),Bn()}var et=[],tt=[],rt={},at=!1,ot=!1,it=0;var st=0,lt=Date.now;if(Z&&!G){var ct=window.performance;ct&&"function"==typeof ct.now&&lt()>document.createEvent("Event").timeStamp&&(lt=function(){return ct.now()})}var pt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function ut(){var n,e;for(st=lt(),ot=!0,et.sort(pt),it=0;it<et.length;it++)(n=et[it]).before&&n.before(),e=n.id,rt[e]=null,n.run();var t=tt.slice(),r=et.slice();it=et.length=tt.length=0,rt={},at=ot=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Qe(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&nt(r,"updated")}}(r),function(){for(var n=0;n<bn.length;n++){var e=bn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}bn.length=0}(),sn&&N.devtools&&sn.emit("flush")}function dt(n){var e=n.id;if(null==rt[e]&&(n!==xn.target||!n.noRecurse)){if(rt[e]=!0,ot){for(var t=et.length-1;t>it&&et[t].id>n.id;)t--;et.splice(t+1,0,n)}else et.push(n);at||(at=!0,Le(ut))}}function ft(n,e){if(n){for(var t=Object.create(null),r=pn?Reflect.ownKeys(n):Object.keys(n),a=0;a<r.length;a++){var o=r[a];if("__ob__"!==o){var i=n[o].from;if(i in e._provided)t[o]=e._provided[i];else if("default"in n[o]){var s=n[o].default;t[o]=c(s)?s.call(e):s}else 0}}return t}}function ht(n,e,t,o,i){var l,c=this,p=i.options;B(o,"_uid")?(l=Object.create(o))._original=o:(l=o,o=o._original);var u=s(p._compiled),d=!u;this.data=n,this.props=e,this.children=t,this.parent=o,this.listeners=n.on||r,this.injections=ft(p.inject,o),this.slots=function(){return c.$slots||me(o,n.scopedSlots,c.$slots=de(t,o)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return me(o,n.scopedSlots,this.slots())}}),u&&(this.$options=p,this.$slots=this.slots(),this.$scopedSlots=me(o,n.scopedSlots,this.$slots)),p._scopeId?this._c=function(n,e,t,r){var i=Ce(l,n,e,t,r,d);return i&&!a(i)&&(i.fnScopeId=p._scopeId,i.fnContext=o),i}:this._c=function(n,e,t,r){return Ce(l,n,e,t,r,d)}}function mt(n,e,t,r,a){var o=vn(n);return o.fnContext=t,o.fnOptions=r,e.slot&&((o.data||(o.data={})).slot=e.slot),o}function vt(n,e){for(var t in e)n[C(t)]=e[t]}function gt(n){return n.name||n.__name||n._componentTag}ue(ht.prototype);var bt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;bt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;i(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ge)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,a,o){var i=a.data.scopedSlots,s=n.$scopedSlots,l=!!(i&&!i.$stable||s!==r&&!s.$stable||i&&n.$scopedSlots.$key!==i.$key||!i&&n.$scopedSlots.$key),c=!!(o||n.$options._renderChildren||l),p=n.$vnode;n.$options._parentVnode=a,n.$vnode=a,n._vnode&&(n._vnode.parent=a),n.$options._renderChildren=o;var u=a.data.attrs||r;n._attrsProxy&&xe(n._attrsProxy,u,p.data&&p.data.attrs||r,n,"$attrs")&&(c=!0),n.$attrs=u,t=t||r;var d=n.$options._parentListeners;if(n._listenersProxy&&xe(n._listenersProxy,t,d||r,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,We(n,t,d),e&&n.$options.props){Sn(!1);for(var f=n._props,h=n.$options._propKeys||[],m=0;m<h.length;m++){var v=h[m],g=n.$options.props;f[v]=It(v,g,e,n)}Sn(!0),n.$options.propsData=e}c&&(n.$slots=de(o,a.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,nt(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,tt.push(e)):Qe(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Ye(e))||e._inactive)){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);nt(e,"deactivated")}}(e,!0):e.$destroy())}},xt=Object.keys(bt);function yt(n,e,t,l,c){if(!o(n)){var u=t.$options._base;if(p(n)&&(n=u.extend(n)),"function"==typeof n){var d;if(o(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&i(n.errorComp))return n.errorComp;if(i(n.resolved))return n.resolved;var t=Be;if(t&&i(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&i(n.loadingComp))return n.loadingComp;if(t&&!i(n.owners)){var r=n.owners=[t],a=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return y(r,t)}));var u=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},d=$((function(t){n.resolved=Pe(t,e),a?r.length=0:u(!0)})),f=$((function(e){i(n.errorComp)&&(n.error=!0,u(!0))})),h=n(d,f);return p(h)&&(m(h)?o(n.resolved)&&h.then(d,f):m(h.component)&&(h.component.then(d,f),i(h.error)&&(n.errorComp=Pe(h.error,e)),i(h.loading)&&(n.loadingComp=Pe(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,o(n.resolved)&&o(n.error)&&(n.loading=!0,u(!1))}),h.delay||200)),i(h.timeout)&&(c=setTimeout((function(){c=null,o(n.resolved)&&f(null)}),h.timeout)))),a=!1,n.loading?n.loadingComp:n.resolved}}(d=n,u)))return function(n,e,t,r,a){var o=hn();return o.asyncFactory=n,o.asyncMeta={data:e,context:t,children:r,tag:a},o}(d,e,t,l,c);e=e||{},qt(n),i(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var o=e.on||(e.on={}),s=o[r],l=e.model.callback;i(s)?(a(s)?-1===s.indexOf(l):s!==l)&&(o[r]=[l].concat(s)):o[r]=l}(n.options,e);var f=function(n,e,t){var r=e.options.props;if(!o(r)){var a={},s=n.attrs,l=n.props;if(i(s)||i(l))for(var c in r){var p=S(c);Zn(a,l,c,p,!0)||Zn(a,s,c,p,!1)}return a}}(e,n);if(s(n.options.functional))return function(n,e,t,o,s){var l=n.options,c={},p=l.props;if(i(p))for(var u in p)c[u]=It(u,p,e||r);else i(t.attrs)&&vt(c,t.attrs),i(t.props)&&vt(c,t.props);var d=new ht(t,c,s,o,n),f=l.render.call(null,d._c,d);if(f instanceof fn)return mt(f,t,d.parent,l,d);if(a(f)){for(var h=Wn(f)||[],m=new Array(h.length),v=0;v<h.length;v++)m[v]=mt(h[v],t,d.parent,l,d);return m}}(n,f,e,t,l);var h=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var v=e.slot;e={},v&&(e.slot=v)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<xt.length;t++){var r=xt[t],a=e[r],o=bt[r];a===o||a&&a._merged||(e[r]=a?Et(o,a):o)}}(e);var g=gt(n.options)||c;return new fn("vue-component-".concat(n.cid).concat(g?"-".concat(g):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:f,listeners:h,tag:c,children:l},d)}}}function Et(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}var Bt=z,Pt=N.optionMergeStrategies;function _t(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var r,a,o,i=pn?Reflect.ownKeys(e):Object.keys(e),s=0;s<i.length;s++)"__ob__"!==(r=i[s])&&(a=n[r],o=e[r],t&&B(n,r)?a!==o&&d(a)&&d(o)&&_t(a,o):zn(n,r,o));return n}function Ct(n,e,t){return t?function(){var r=c(e)?e.call(t,t):e,a=c(n)?n.call(t,t):n;return r?_t(r,a):a}:e?n?function(){return _t(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function At(n,e){var t=e?n?n.concat(e):a(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function wt(n,e,t,r){var a=Object.create(n||null);return e?I(a,e):a}Pt.data=function(n,e,t){return t?Ct(n,e,t):e&&"function"!=typeof e?n:Ct(n,e)},M.forEach((function(n){Pt[n]=At})),R.forEach((function(n){Pt[n+"s"]=wt})),Pt.watch=function(n,e,t,r){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var o={};for(var i in I(o,n),e){var s=o[i],l=e[i];s&&!a(s)&&(s=[s]),o[i]=s?s.concat(l):a(l)?l:[l]}return o},Pt.props=Pt.methods=Pt.inject=Pt.computed=function(n,e,t,r){if(!n)return e;var a=Object.create(null);return I(a,n),e&&I(a,e),a},Pt.provide=function(n,e){return n?function(){var t=Object.create(null);return _t(t,c(n)?n.call(this):n),e&&_t(t,c(e)?e.call(this):e,!1),t}:e};var St=function(n,e){return void 0===e?n:e};function kt(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var r,o,i={};if(a(t))for(r=t.length;r--;)"string"==typeof(o=t[r])&&(i[C(o)]={type:null});else if(d(t))for(var s in t)o=t[s],i[C(s)]=d(o)?o:{type:o};else 0;n.props=i}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(a(t))for(var o=0;o<t.length;o++)r[t[o]]={from:t[o]};else if(d(t))for(var i in t){var s=t[i];r[i]=d(s)?I({from:i},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];c(r)&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=kt(n,e.extends,t)),e.mixins))for(var r=0,o=e.mixins.length;r<o;r++)n=kt(n,e.mixins[r],t);var i,s={};for(i in n)l(i);for(i in e)B(n,i)||l(i);function l(r){var a=Pt[r]||St;s[r]=a(n[r],e[r],t,r)}return s}function Tt(n,e,t,r){if("string"==typeof t){var a=n[e];if(B(a,t))return a[t];var o=C(t);if(B(a,o))return a[o];var i=A(o);return B(a,i)?a[i]:a[t]||a[o]||a[i]}}function It(n,e,t,r){var a=e[n],o=!B(t,n),i=t[n],s=Dt(Boolean,a.type);if(s>-1)if(o&&!B(a,"default"))i=!1;else if(""===i||i===S(n)){var l=Dt(String,a.type);(l<0||s<l)&&(i=!0)}if(void 0===i){i=function(n,e,t){if(!B(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(r)&&"Function"!==zt(e.type)?r.call(n):r}(r,a,n);var p=wn;Sn(!0),In(i),Sn(p)}return i}var jt=/^\s*function (\w+)/;function zt(n){var e=n&&n.toString().match(jt);return e?e[1]:""}function Ot(n,e){return zt(n)===zt(e)}function Dt(n,e){if(!a(e))return Ot(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Ot(e[t],n))return t;return-1}var Ft={enumerable:!0,configurable:!0,get:z,set:z};function Ut(n,e,t){Ft.get=function(){return this[e][t]},Ft.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Ft)}function $t(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props=Fn({}),a=n.$options._propKeys=[];n.$parent&&Sn(!1);var o=function(o){a.push(o);var i=It(o,e,t,n);jn(r,o,i),o in n||Ut(n,"_props",o)};for(var i in e)o(i);Sn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var r=n._setupContext=be(n);dn(n),En();var a=we(t,null,[n._props||Fn({}),r],n,"setup");if(Bn(),dn(),c(a))e.render=a;else if(p(a))if(n._setupState=a,a.__sfc){var o=n._setupProxy={};for(var i in a)"__sfc"!==i&&Rn(o,a,i)}else for(var i in a)H(i)||Rn(n,a,i);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?z:k(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;d(e=n._data=c(e)?function(n,e){En();try{return n.call(e,e)}catch(n){return Ae(n,e,"data()"),{}}finally{Bn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,a=(n.$options.methods,t.length);for(;a--;){var o=t[a];0,r&&B(r,o)||H(o)||Ut(n,"_data",o)}var i=In(e);i&&i.vmCount++}(n);else{var t=In(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=on();for(var a in e){var o=e[a],i=c(o)?o:o.get;0,r||(t[a]=new qe(n,i||z,z,Lt)),a in n||Rt(n,a,o)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var r=e[t];if(a(r))for(var o=0;o<r.length;o++)Vt(n,t,r[o]);else Vt(n,t,r)}}(n,e.watch)}var Lt={lazy:!0};function Rt(n,e,t){var r=!on();c(t)?(Ft.get=r?Mt(e):Nt(t),Ft.set=z):(Ft.get=t.get?r&&!1!==t.cache?Mt(e):Nt(t.get):z,Ft.set=t.set||z),Object.defineProperty(n,e,Ft)}function Mt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),xn.target&&e.depend(),e.value}}function Nt(n){return function(){return n.call(this,this)}}function Vt(n,e,t,r){return d(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var Ht=0;function qt(n){var e=n.options;if(n.super){var t=qt(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var a in t)t[a]!==r[a]&&(e||(e={}),e[a]=t[a]);return e}(n);r&&I(n.extendOptions,r),(e=n.options=kt(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Kt(n){this._init(n)}function Xt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,a=n._Ctor||(n._Ctor={});if(a[r])return a[r];var o=gt(n)||gt(t.options);var i=function(n){this._init(n)};return(i.prototype=Object.create(t.prototype)).constructor=i,i.cid=e++,i.options=kt(t.options,n),i.super=t,i.options.props&&function(n){var e=n.options.props;for(var t in e)Ut(n.prototype,"_props",t)}(i),i.options.computed&&function(n){var e=n.options.computed;for(var t in e)Rt(n.prototype,t,e[t])}(i),i.extend=t.extend,i.mixin=t.mixin,i.use=t.use,R.forEach((function(n){i[n]=t[n]})),o&&(i.options.components[o]=i),i.superOptions=t.options,i.extendOptions=n,i.sealedOptions=I({},i.options),a[r]=i,i}}function Zt(n){return n&&(gt(n.Ctor.options)||n.tag)}function Wt(n,e){return a(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!f(n)&&n.test(e)}function Gt(n,e){var t=n.cache,r=n.keys,a=n._vnode;for(var o in t){var i=t[o];if(i){var s=i.name;s&&!e(s)&&Jt(t,o,r,a)}}}function Jt(n,e,t,r){var a=n[e];!a||r&&a.tag===r.tag||a.componentInstance.$destroy(),n[e]=null,y(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Ht++,e._isVue=!0,e.__v_skip=!0,e._scope=new Nn(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var a=r.componentOptions;t.propsData=a.propsData,t._parentListeners=a.listeners,t._renderChildren=a.children,t._componentTag=a.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=kt(qt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&We(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,a=t&&t.context;n.$slots=de(e._renderChildren,a),n.$scopedSlots=t?me(n.$parent,t.data.scopedSlots,n.$slots):r,n._c=function(e,t,r,a){return Ce(n,e,t,r,a,!1)},n.$createElement=function(e,t,r,a){return Ce(n,e,t,r,a,!0)};var o=t&&t.data;jn(n,"$attrs",o&&o.attrs||r,null,!0),jn(n,"$listeners",e._parentListeners||r,null,!0)}(e),nt(e,"beforeCreate",void 0,!1),function(n){var e=ft(n.$options.inject,n);e&&(Sn(!1),Object.keys(e).forEach((function(t){jn(n,t,e[t])})),Sn(!0))}(e),$t(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!p(t))return;for(var r=Vn(n),a=pn?Reflect.ownKeys(t):Object.keys(t),o=0;o<a.length;o++){var i=a[o];Object.defineProperty(r,i,Object.getOwnPropertyDescriptor(t,i))}}}(e),nt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Kt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=zn,n.prototype.$delete=On,n.prototype.$watch=function(n,e,t){if(d(e))return Vt(this,n,e,t);(t=t||{}).user=!0;var r=new qe(this,n,e,t);if(t.immediate){var a='callback for immediate watcher "'.concat(r.expression,'"');En(),we(e,this,[r.value],this,a),Bn()}return function(){r.teardown()}}}(Kt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(a(n))for(var o=0,i=n.length;o<i;o++)r.$on(n[o],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(a(n)){for(var r=0,o=n.length;r<o;r++)t.$off(n[r],e);return t}var i,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((i=s[l])===e||i.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?T(t):t;for(var r=T(arguments,1),a='event handler for "'.concat(n,'"'),o=0,i=t.length;o<i;o++)we(t[o],e,r,e,a)}return e}}(Kt),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,a=t._vnode,o=Je(t);t._vnode=n,t.$el=a?t.__patch__(a,n):t.__patch__(t.$el,n,e,!1),o(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var i=t;i&&i.$vnode&&i.$parent&&i.$vnode===i.$parent._vnode;)i.$parent.$el=i.$el,i=i.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){nt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||y(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),nt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Kt),function(n){ue(n.prototype),n.prototype.$nextTick=function(n){return Le(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,o=t._parentVnode;o&&e._isMounted&&(e.$scopedSlots=me(e.$parent,o.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&Ee(e._slotsProxy,e.$scopedSlots)),e.$vnode=o;try{dn(e),Be=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){Ae(t,e,"render"),n=e._vnode}finally{Be=null,dn()}return a(n)&&1===n.length&&(n=n[0]),n instanceof fn||(n=hn()),n.parent=o,n}}(Kt);var Yt=[String,RegExp,Array],Qt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Yt,exclude:Yt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var a=t.tag,o=t.componentInstance,i=t.componentOptions;n[r]={name:Zt(i),tag:a,componentInstance:o},e.push(r),this.max&&e.length>parseInt(this.max)&&Jt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Jt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Gt(n,(function(n){return Wt(e,n)}))})),this.$watch("exclude",(function(e){Gt(n,(function(n){return!Wt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=_e(n),t=e&&e.componentOptions;if(t){var r=Zt(t),a=this.include,o=this.exclude;if(a&&(!r||!Wt(a,r))||o&&r&&Wt(o,r))return e;var i=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;i[l]?(e.componentInstance=i[l].componentInstance,y(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return N}};Object.defineProperty(n,"config",e),n.util={warn:Bt,extend:I,mergeOptions:kt,defineReactive:jn},n.set=zn,n.delete=On,n.nextTick=Le,n.observable=function(n){return In(n),n},n.options=Object.create(null),R.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,I(n.options.components,Qt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=T(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=kt(this.options,n),this}}(n),Xt(n),function(n){R.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&d(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Kt),Object.defineProperty(Kt.prototype,"$isServer",{get:on}),Object.defineProperty(Kt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Kt,"FunctionalRenderContext",{value:ht}),Kt.version="2.7.14";var nr=b("style,class"),er=b("input,textarea,option,select,progress"),tr=b("contenteditable,draggable,spellcheck"),rr=b("events,caret,typing,plaintext-only"),ar=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),or="http://www.w3.org/1999/xlink",ir=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},sr=function(n){return ir(n)?n.slice(6,n.length):""},lr=function(n){return null==n||!1===n};function cr(n){for(var e=n.data,t=n,r=n;i(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=pr(r.data,e));for(;i(t=t.parent);)t&&t.data&&(e=pr(e,t.data));return function(n,e){if(i(n)||i(e))return ur(n,dr(e));return""}(e.staticClass,e.class)}function pr(n,e){return{staticClass:ur(n.staticClass,e.staticClass),class:i(n.class)?[n.class,e.class]:e.class}}function ur(n,e){return n?e?n+" "+e:n:e||""}function dr(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,a=n.length;r<a;r++)i(e=dr(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):p(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var fr={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},hr=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),mr=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),vr=function(n){return hr(n)||mr(n)};var gr=Object.create(null);var br=b("text,number,password,search,email,tel,url");var xr=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(fr[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),yr={create:function(n,e){Er(e)},update:function(n,e){n.data.ref!==e.data.ref&&(Er(n,!0),Er(e))},destroy:function(n){Er(n,!0)}};function Er(n,e){var t=n.data.ref;if(i(t)){var r=n.context,o=n.componentInstance||n.elm,s=e?null:o,l=e?void 0:o;if(c(t))we(t,r,[s],r,"template ref function");else{var p=n.data.refInFor,u="string"==typeof t||"number"==typeof t,d=Ln(t),f=r.$refs;if(u||d)if(p){var h=u?f[t]:t.value;e?a(h)&&y(h,o):a(h)?h.includes(o)||h.push(o):u?(f[t]=[o],Br(r,t,f[t])):t.value=[o]}else if(u){if(e&&f[t]!==o)return;f[t]=l,Br(r,t,s)}else if(d){if(e&&t.value!==o)return;t.value=s}else 0}}}function Br(n,e,t){var r=n._setupState;r&&B(r,e)&&(Ln(r[e])?r[e].value=t:r[e]=t)}var Pr=new fn("",{},[]),_r=["create","activate","update","remove","destroy"];function Cr(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&i(n.data)===i(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=i(t=n.data)&&i(t=t.attrs)&&t.type,a=i(t=e.data)&&i(t=t.attrs)&&t.type;return r===a||br(r)&&br(a)}(n,e)||s(n.isAsyncPlaceholder)&&o(e.asyncFactory.error))}function Ar(n,e,t){var r,a,o={};for(r=e;r<=t;++r)i(a=n[r].key)&&(o[a]=r);return o}var wr={create:Sr,update:Sr,destroy:function(n){Sr(n,Pr)}};function Sr(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,a,o=n===Pr,i=e===Pr,s=Tr(n.data.directives,n.context),l=Tr(e.data.directives,e.context),c=[],p=[];for(t in l)r=s[t],a=l[t],r?(a.oldValue=r.value,a.oldArg=r.arg,jr(a,"update",e,n),a.def&&a.def.componentUpdated&&p.push(a)):(jr(a,"bind",e,n),a.def&&a.def.inserted&&c.push(a));if(c.length){var u=function(){for(var t=0;t<c.length;t++)jr(c[t],"inserted",e,n)};o?Xn(e,"insert",u):u()}p.length&&Xn(e,"postpatch",(function(){for(var t=0;t<p.length;t++)jr(p[t],"componentUpdated",e,n)}));if(!o)for(t in s)l[t]||jr(s[t],"unbind",n,n,i)}(n,e)}var kr=Object.create(null);function Tr(n,e){var t,r,a=Object.create(null);if(!n)return a;for(t=0;t<n.length;t++){if((r=n[t]).modifiers||(r.modifiers=kr),a[Ir(r)]=r,e._setupState&&e._setupState.__sfc){var o=r.def||Tt(e,"_setupState","v-"+r.name);r.def="function"==typeof o?{bind:o,update:o}:o}r.def=r.def||Tt(e.$options,"directives",r.name)}return a}function Ir(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function jr(n,e,t,r,a){var o=n.def&&n.def[e];if(o)try{o(t.elm,n,t,r,a)}catch(r){Ae(r,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var zr=[yr,wr];function Or(n,e){var t=e.componentOptions;if(!(i(t)&&!1===t.Ctor.options.inheritAttrs||o(n.data.attrs)&&o(e.data.attrs))){var r,a,l=e.elm,c=n.data.attrs||{},p=e.data.attrs||{};for(r in(i(p.__ob__)||s(p._v_attr_proxy))&&(p=e.data.attrs=I({},p)),p)a=p[r],c[r]!==a&&Dr(l,r,a,e.data.pre);for(r in(G||Y)&&p.value!==c.value&&Dr(l,"value",p.value),c)o(p[r])&&(ir(r)?l.removeAttributeNS(or,sr(r)):tr(r)||l.removeAttribute(r))}}function Dr(n,e,t,r){r||n.tagName.indexOf("-")>-1?Fr(n,e,t):ar(e)?lr(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):tr(e)?n.setAttribute(e,function(n,e){return lr(e)||"false"===e?"false":"contenteditable"===n&&rr(e)?e:"true"}(e,t)):ir(e)?lr(t)?n.removeAttributeNS(or,sr(e)):n.setAttributeNS(or,e,t):Fr(n,e,t)}function Fr(n,e,t){if(lr(t))n.removeAttribute(e);else{if(G&&!J&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var Ur={create:Or,update:Or};function $r(n,e){var t=e.elm,r=e.data,a=n.data;if(!(o(r.staticClass)&&o(r.class)&&(o(a)||o(a.staticClass)&&o(a.class)))){var s=cr(e),l=t._transitionClasses;i(l)&&(s=ur(s,dr(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Lr,Rr={create:$r,update:$r};function Mr(n,e,t){var r=Lr;return function a(){var o=e.apply(null,arguments);null!==o&&Hr(n,a,t,r)}}var Nr=Ie&&!(en&&Number(en[1])<=53);function Vr(n,e,t,r){if(Nr){var a=st,o=e;e=o._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=a||n.timeStamp<=0||n.target.ownerDocument!==document)return o.apply(this,arguments)}}Lr.addEventListener(n,e,rn?{capture:t,passive:r}:t)}function Hr(n,e,t,r){(r||Lr).removeEventListener(n,e._wrapper||e,t)}function qr(n,e){if(!o(n.data.on)||!o(e.data.on)){var t=e.data.on||{},r=n.data.on||{};Lr=e.elm||n.elm,function(n){if(i(n.__r)){var e=G?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}i(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Kn(t,r,Vr,Hr,Mr,e.context),Lr=void 0}}var Kr,Xr={create:qr,update:qr,destroy:function(n){return qr(n,Pr)}};function Zr(n,e){if(!o(n.data.domProps)||!o(e.data.domProps)){var t,r,a=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(i(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=I({},c)),l)t in c||(a[t]="");for(t in c){if(r=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===l[t])continue;1===a.childNodes.length&&a.removeChild(a.childNodes[0])}if("value"===t&&"PROGRESS"!==a.tagName){a._value=r;var p=o(r)?"":String(r);Wr(a,p)&&(a.value=p)}else if("innerHTML"===t&&mr(a.tagName)&&o(a.innerHTML)){(Kr=Kr||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var u=Kr.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;u.firstChild;)a.appendChild(u.firstChild)}else if(r!==l[t])try{a[t]=r}catch(n){}}}}function Wr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(i(r)){if(r.number)return g(t)!==g(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Gr={create:Zr,update:Zr},Jr=P((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Yr(n){var e=Qr(n.style);return n.staticStyle?I(n.staticStyle,e):e}function Qr(n){return Array.isArray(n)?j(n):"string"==typeof n?Jr(n):n}var na,ea=/^--/,ta=/\s*!important$/,ra=function(n,e,t){if(ea.test(e))n.style.setProperty(e,t);else if(ta.test(t))n.style.setProperty(S(e),t.replace(ta,""),"important");else{var r=oa(e);if(Array.isArray(t))for(var a=0,o=t.length;a<o;a++)n.style[r]=t[a];else n.style[r]=t}},aa=["Webkit","Moz","ms"],oa=P((function(n){if(na=na||document.createElement("div").style,"filter"!==(n=C(n))&&n in na)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<aa.length;t++){var r=aa[t]+e;if(r in na)return r}}));function ia(n,e){var t=e.data,r=n.data;if(!(o(t.staticStyle)&&o(t.style)&&o(r.staticStyle)&&o(r.style))){var a,s,l=e.elm,c=r.staticStyle,p=r.normalizedStyle||r.style||{},u=c||p,d=Qr(e.data.style)||{};e.data.normalizedStyle=i(d.__ob__)?I({},d):d;var f=function(n,e){var t,r={};if(e)for(var a=n;a.componentInstance;)(a=a.componentInstance._vnode)&&a.data&&(t=Yr(a.data))&&I(r,t);(t=Yr(n.data))&&I(r,t);for(var o=n;o=o.parent;)o.data&&(t=Yr(o.data))&&I(r,t);return r}(e,!0);for(s in u)o(f[s])&&ra(l,s,"");for(s in f)(a=f[s])!==u[s]&&ra(l,s,null==a?"":a)}}var sa={create:ia,update:ia},la=/\s+/;function ca(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(la).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function pa(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(la).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function ua(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&I(e,da(n.name||"v")),I(e,n),e}return"string"==typeof n?da(n):void 0}}var da=P((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),fa=Z&&!J,ha="transition",ma="transitionend",va="animation",ga="animationend";fa&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(ha="WebkitTransition",ma="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(va="WebkitAnimation",ga="webkitAnimationEnd"));var ba=Z?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function xa(n){ba((function(){ba(n)}))}function ya(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),ca(n,e))}function Ea(n,e){n._transitionClasses&&y(n._transitionClasses,e),pa(n,e)}function Ba(n,e,t){var r=_a(n,e),a=r.type,o=r.timeout,i=r.propCount;if(!a)return t();var s="transition"===a?ma:ga,l=0,c=function(){n.removeEventListener(s,p),t()},p=function(e){e.target===n&&++l>=i&&c()};setTimeout((function(){l<i&&c()}),o+1),n.addEventListener(s,p)}var Pa=/\b(transform|all)(,|$)/;function _a(n,e){var t,r=window.getComputedStyle(n),a=(r[ha+"Delay"]||"").split(", "),o=(r[ha+"Duration"]||"").split(", "),i=Ca(a,o),s=(r[va+"Delay"]||"").split(", "),l=(r[va+"Duration"]||"").split(", "),c=Ca(s,l),p=0,u=0;return"transition"===e?i>0&&(t="transition",p=i,u=o.length):"animation"===e?c>0&&(t="animation",p=c,u=l.length):u=(t=(p=Math.max(i,c))>0?i>c?"transition":"animation":null)?"transition"===t?o.length:l.length:0,{type:t,timeout:p,propCount:u,hasTransform:"transition"===t&&Pa.test(r[ha+"Property"])}}function Ca(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Aa(e)+Aa(n[t])})))}function Aa(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function wa(n,e){var t=n.elm;i(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=ua(n.data.transition);if(!o(r)&&!i(t._enterCb)&&1===t.nodeType){for(var a=r.css,s=r.type,l=r.enterClass,u=r.enterToClass,d=r.enterActiveClass,f=r.appearClass,h=r.appearToClass,m=r.appearActiveClass,v=r.beforeEnter,b=r.enter,x=r.afterEnter,y=r.enterCancelled,E=r.beforeAppear,B=r.appear,P=r.afterAppear,_=r.appearCancelled,C=r.duration,A=Ge,w=Ge.$vnode;w&&w.parent;)A=w.context,w=w.parent;var S=!A._isMounted||!n.isRootInsert;if(!S||B||""===B){var k=S&&f?f:l,T=S&&m?m:d,I=S&&h?h:u,j=S&&E||v,z=S&&c(B)?B:b,O=S&&P||x,D=S&&_||y,F=g(p(C)?C.enter:C);0;var U=!1!==a&&!J,L=Ta(z),R=t._enterCb=$((function(){U&&(Ea(t,I),Ea(t,T)),R.cancelled?(U&&Ea(t,k),D&&D(t)):O&&O(t),t._enterCb=null}));n.data.show||Xn(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),z&&z(t,R)})),j&&j(t),U&&(ya(t,k),ya(t,T),xa((function(){Ea(t,k),R.cancelled||(ya(t,I),L||(ka(F)?setTimeout(R,F):Ba(t,s,R)))}))),n.data.show&&(e&&e(),z&&z(t,R)),U||L||R()}}}function Sa(n,e){var t=n.elm;i(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=ua(n.data.transition);if(o(r)||1!==t.nodeType)return e();if(!i(t._leaveCb)){var a=r.css,s=r.type,l=r.leaveClass,c=r.leaveToClass,u=r.leaveActiveClass,d=r.beforeLeave,f=r.leave,h=r.afterLeave,m=r.leaveCancelled,v=r.delayLeave,b=r.duration,x=!1!==a&&!J,y=Ta(f),E=g(p(b)?b.leave:b);0;var B=t._leaveCb=$((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),x&&(Ea(t,c),Ea(t,u)),B.cancelled?(x&&Ea(t,l),m&&m(t)):(e(),h&&h(t)),t._leaveCb=null}));v?v(P):P()}function P(){B.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),d&&d(t),x&&(ya(t,l),ya(t,u),xa((function(){Ea(t,l),B.cancelled||(ya(t,c),y||(ka(E)?setTimeout(B,E):Ba(t,s,B)))}))),f&&f(t,B),x||y||B())}}function ka(n){return"number"==typeof n&&!isNaN(n)}function Ta(n){if(o(n))return!1;var e=n.fns;return i(e)?Ta(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Ia(n,e){!0!==e.data.show&&wa(e)}var ja=function(n){var e,t,r={},c=n.modules,p=n.nodeOps;for(e=0;e<_r.length;++e)for(r[_r[e]]=[],t=0;t<c.length;++t)i(c[t][_r[e]])&&r[_r[e]].push(c[t][_r[e]]);function u(n){var e=p.parentNode(n);i(e)&&p.removeChild(e,n)}function d(n,e,t,a,o,l,c){if(i(n.elm)&&i(l)&&(n=l[c]=vn(n)),n.isRootInsert=!o,!function(n,e,t,a){var o=n.data;if(i(o)){var l=i(n.componentInstance)&&o.keepAlive;if(i(o=o.hook)&&i(o=o.init)&&o(n,!1),i(n.componentInstance))return f(n,e),h(t,n.elm,a),s(l)&&function(n,e,t,a){var o,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,i(o=s.data)&&i(o=o.transition)){for(o=0;o<r.activate.length;++o)r.activate[o](Pr,s);e.push(s);break}h(t,n.elm,a)}(n,e,t,a),!0}}(n,e,t,a)){var u=n.data,d=n.children,v=n.tag;i(v)?(n.elm=n.ns?p.createElementNS(n.ns,v):p.createElement(v,n),x(n),m(n,d,e),i(u)&&g(n,e),h(t,n.elm,a)):s(n.isComment)?(n.elm=p.createComment(n.text),h(t,n.elm,a)):(n.elm=p.createTextNode(n.text),h(t,n.elm,a))}}function f(n,e){i(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,v(n)?(g(n,e),x(n)):(Er(n),e.push(n))}function h(n,e,t){i(n)&&(i(t)?p.parentNode(t)===n&&p.insertBefore(n,e,t):p.appendChild(n,e))}function m(n,e,t){if(a(e)){0;for(var r=0;r<e.length;++r)d(e[r],t,n.elm,null,!0,e,r)}else l(n.text)&&p.appendChild(n.elm,p.createTextNode(String(n.text)))}function v(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return i(n.tag)}function g(n,t){for(var a=0;a<r.create.length;++a)r.create[a](Pr,n);i(e=n.data.hook)&&(i(e.create)&&e.create(Pr,n),i(e.insert)&&t.push(n))}function x(n){var e;if(i(e=n.fnScopeId))p.setStyleScope(n.elm,e);else for(var t=n;t;)i(e=t.context)&&i(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e),t=t.parent;i(e=Ge)&&e!==n.context&&e!==n.fnContext&&i(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e)}function y(n,e,t,r,a,o){for(;r<=a;++r)d(t[r],o,n,e,!1,t,r)}function E(n){var e,t,a=n.data;if(i(a))for(i(e=a.hook)&&i(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(i(e=n.children))for(t=0;t<n.children.length;++t)E(n.children[t])}function B(n,e,t){for(;e<=t;++e){var r=n[e];i(r)&&(i(r.tag)?(P(r),E(r)):u(r.elm))}}function P(n,e){if(i(e)||i(n.data)){var t,a=r.remove.length+1;for(i(e)?e.listeners+=a:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,a),i(t=n.componentInstance)&&i(t=t._vnode)&&i(t.data)&&P(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);i(t=n.data.hook)&&i(t=t.remove)?t(n,e):e()}else u(n.elm)}function _(n,e,t,r){for(var a=t;a<r;a++){var o=e[a];if(i(o)&&Cr(n,o))return a}}function C(n,e,t,a,l,c){if(n!==e){i(e.elm)&&i(a)&&(e=a[l]=vn(e));var u=e.elm=n.elm;if(s(n.isAsyncPlaceholder))i(e.asyncFactory.resolved)?S(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var f,h=e.data;i(h)&&i(f=h.hook)&&i(f=f.prepatch)&&f(n,e);var m=n.children,g=e.children;if(i(h)&&v(e)){for(f=0;f<r.update.length;++f)r.update[f](n,e);i(f=h.hook)&&i(f=f.update)&&f(n,e)}o(e.text)?i(m)&&i(g)?m!==g&&function(n,e,t,r,a){var s,l,c,u=0,f=0,h=e.length-1,m=e[0],v=e[h],g=t.length-1,b=t[0],x=t[g],E=!a;for(0;u<=h&&f<=g;)o(m)?m=e[++u]:o(v)?v=e[--h]:Cr(m,b)?(C(m,b,r,t,f),m=e[++u],b=t[++f]):Cr(v,x)?(C(v,x,r,t,g),v=e[--h],x=t[--g]):Cr(m,x)?(C(m,x,r,t,g),E&&p.insertBefore(n,m.elm,p.nextSibling(v.elm)),m=e[++u],x=t[--g]):Cr(v,b)?(C(v,b,r,t,f),E&&p.insertBefore(n,v.elm,m.elm),v=e[--h],b=t[++f]):(o(s)&&(s=Ar(e,u,h)),o(l=i(b.key)?s[b.key]:_(b,e,u,h))?d(b,r,n,m.elm,!1,t,f):Cr(c=e[l],b)?(C(c,b,r,t,f),e[l]=void 0,E&&p.insertBefore(n,c.elm,m.elm)):d(b,r,n,m.elm,!1,t,f),b=t[++f]);u>h?y(n,o(t[g+1])?null:t[g+1].elm,t,f,g,r):f>g&&B(e,u,h)}(u,m,g,t,c):i(g)?(i(n.text)&&p.setTextContent(u,""),y(u,null,g,0,g.length-1,t)):i(m)?B(m,0,m.length-1):i(n.text)&&p.setTextContent(u,""):n.text!==e.text&&p.setTextContent(u,e.text),i(h)&&i(f=h.hook)&&i(f=f.postpatch)&&f(n,e)}}}function A(n,e,t){if(s(t)&&i(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var w=b("attrs,class,staticClass,staticStyle,key");function S(n,e,t,r){var a,o=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,s(e.isComment)&&i(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(i(l)&&(i(a=l.hook)&&i(a=a.init)&&a(e,!0),i(a=e.componentInstance)))return f(e,t),!0;if(i(o)){if(i(c))if(n.hasChildNodes())if(i(a=l)&&i(a=a.domProps)&&i(a=a.innerHTML)){if(a!==n.innerHTML)return!1}else{for(var p=!0,u=n.firstChild,d=0;d<c.length;d++){if(!u||!S(u,c[d],t,r)){p=!1;break}u=u.nextSibling}if(!p||u)return!1}else m(e,c,t);if(i(l)){var h=!1;for(var v in l)if(!w(v)){h=!0,g(e,t);break}!h&&l.class&&Ne(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,a){if(!o(e)){var l,c=!1,u=[];if(o(n))c=!0,d(e,u);else{var f=i(n.nodeType);if(!f&&Cr(n,e))C(n,e,u,null,null,a);else{if(f){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&S(n,e,u))return A(e,u,!0),n;l=n,n=new fn(p.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,m=p.parentNode(h);if(d(e,u,h._leaveCb?null:m,p.nextSibling(h)),i(e.parent))for(var g=e.parent,b=v(e);g;){for(var x=0;x<r.destroy.length;++x)r.destroy[x](g);if(g.elm=e.elm,b){for(var y=0;y<r.create.length;++y)r.create[y](Pr,g);var P=g.data.hook.insert;if(P.merged)for(var _=1;_<P.fns.length;_++)P.fns[_]()}else Er(g);g=g.parent}i(m)?B([n],0,0):i(n.tag)&&E(n)}}return A(e,u,c),e.elm}i(n)&&E(n)}}({nodeOps:xr,modules:[Ur,Rr,Xr,Gr,sa,Z?{create:Ia,activate:Ia,remove:function(n,e){!0!==n.data.show?Sa(n,e):e()}}:{}].concat(zr)});J&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Ra(n,"input")}));var za={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?Xn(t,"postpatch",(function(){za.componentUpdated(n,e,t)})):Oa(n,e,t.context),n._vOptions=[].map.call(n.options,Ua)):("textarea"===t.tag||br(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",$a),n.addEventListener("compositionend",La),n.addEventListener("change",La),J&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Oa(n,e,t.context);var r=n._vOptions,a=n._vOptions=[].map.call(n.options,Ua);if(a.some((function(n,e){return!F(n,r[e])})))(n.multiple?e.value.some((function(n){return Fa(n,a)})):e.value!==e.oldValue&&Fa(e.value,a))&&Ra(n,"change")}}};function Oa(n,e,t){Da(n,e,t),(G||Y)&&setTimeout((function(){Da(n,e,t)}),0)}function Da(n,e,t){var r=e.value,a=n.multiple;if(!a||Array.isArray(r)){for(var o,i,s=0,l=n.options.length;s<l;s++)if(i=n.options[s],a)o=U(r,Ua(i))>-1,i.selected!==o&&(i.selected=o);else if(F(Ua(i),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));a||(n.selectedIndex=-1)}}function Fa(n,e){return e.every((function(e){return!F(e,n)}))}function Ua(n){return"_value"in n?n._value:n.value}function $a(n){n.target.composing=!0}function La(n){n.target.composing&&(n.target.composing=!1,Ra(n.target,"input"))}function Ra(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Ma(n){return!n.componentInstance||n.data&&n.data.transition?n:Ma(n.componentInstance._vnode)}var Na={model:za,show:{bind:function(n,e,t){var r=e.value,a=(t=Ma(t)).data&&t.data.transition,o=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&a?(t.data.show=!0,wa(t,(function(){n.style.display=o}))):n.style.display=r?o:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=Ma(t)).data&&t.data.transition?(t.data.show=!0,r?wa(t,(function(){n.style.display=n.__vOriginalDisplay})):Sa(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,a){a||(n.style.display=n.__vOriginalDisplay)}}},Va={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Ha(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Ha(_e(e.children)):n}function qa(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var a=t._parentListeners;for(var r in a)e[C(r)]=a[r];return e}function Ka(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Xa=function(n){return n.tag||he(n)},Za=function(n){return"show"===n.name},Wa={name:"transition",props:Va,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Xa)).length){0;var r=this.mode;0;var a=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return a;var o=Ha(a);if(!o)return a;if(this._leaving)return Ka(n,a);var i="__transition-".concat(this._uid,"-");o.key=null==o.key?o.isComment?i+"comment":i+o.tag:l(o.key)?0===String(o.key).indexOf(i)?o.key:i+o.key:o.key;var s=(o.data||(o.data={})).transition=qa(this),c=this._vnode,p=Ha(c);if(o.data.directives&&o.data.directives.some(Za)&&(o.data.show=!0),p&&p.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(o,p)&&!he(p)&&(!p.componentInstance||!p.componentInstance._vnode.isComment)){var u=p.data.transition=I({},s);if("out-in"===r)return this._leaving=!0,Xn(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Ka(n,a);if("in-out"===r){if(he(o))return c;var d,f=function(){d()};Xn(s,"afterEnter",f),Xn(s,"enterCancelled",f),Xn(u,"delayLeave",(function(n){d=n}))}}return a}}},Ga=I({tag:String,moveClass:String},Va);function Ja(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Ya(n){n.data.newPos=n.elm.getBoundingClientRect()}function Qa(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,a=e.top-t.top;if(r||a){n.data.moved=!0;var o=n.elm.style;o.transform=o.WebkitTransform="translate(".concat(r,"px,").concat(a,"px)"),o.transitionDuration="0s"}}delete Ga.mode;var no={Transition:Wa,TransitionGroup:{props:Ga,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var a=Je(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,a(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,a=this.$slots.default||[],o=this.children=[],i=qa(this),s=0;s<a.length;s++){if((p=a[s]).tag)if(null!=p.key&&0!==String(p.key).indexOf("__vlist"))o.push(p),t[p.key]=p,(p.data||(p.data={})).transition=i;else;}if(r){var l=[],c=[];for(s=0;s<r.length;s++){var p;(p=r[s]).data.transition=i,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?l.push(p):c.push(p)}this.kept=n(e,null,l),this.removed=c}return n(e,null,o)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Ja),n.forEach(Ya),n.forEach(Qa),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;ya(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(ma,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(ma,n),t._moveCb=null,Ea(t,e))})}})))},methods:{hasMove:function(n,e){if(!fa)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){pa(t,n)})),ca(t,e),t.style.display="none",this.$el.appendChild(t);var r=_a(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};function eo(n,e){for(var t in e)n[t]=e[t];return n}Kt.config.mustUseProp=function(n,e,t){return"value"===t&&er(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Kt.config.isReservedTag=vr,Kt.config.isReservedAttr=nr,Kt.config.getTagNamespace=function(n){return mr(n)?"svg":"math"===n?"math":void 0},Kt.config.isUnknownElement=function(n){if(!Z)return!0;if(vr(n))return!1;if(n=n.toLowerCase(),null!=gr[n])return gr[n];var e=document.createElement(n);return n.indexOf("-")>-1?gr[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:gr[n]=/HTMLUnknownElement/.test(e.toString())},I(Kt.options.directives,Na),I(Kt.options.components,no),Kt.prototype.__patch__=Z?ja:z,Kt.prototype.$mount=function(n,e){return function(n,e,t){var r;n.$el=e,n.$options.render||(n.$options.render=hn),nt(n,"beforeMount"),r=function(){n._update(n._render(),t)},new qe(n,r,z,{before:function(){n._isMounted&&!n._isDestroyed&&nt(n,"beforeUpdate")}},!0),t=!1;var a=n._preWatchers;if(a)for(var o=0;o<a.length;o++)a[o].run();return null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n}(this,n=n&&Z?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},Z&&setTimeout((function(){N.devtools&&sn&&sn.emit("init",Kt)}),0);var to=/[!'()*]/g,ro=function(n){return"%"+n.charCodeAt(0).toString(16)},ao=/%2C/g,oo=function(n){return encodeURIComponent(n).replace(to,ro).replace(ao,",")};function io(n){try{return decodeURIComponent(n)}catch(n){0}return n}var so=function(n){return null==n||"object"==typeof n?n:String(n)};function lo(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=io(t.shift()),a=t.length>0?io(t.join("=")):null;void 0===e[r]?e[r]=a:Array.isArray(e[r])?e[r].push(a):e[r]=[e[r],a]})),e):e}function co(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return oo(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(oo(e)):r.push(oo(e)+"="+oo(n)))})),r.join("&")}return oo(e)+"="+oo(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var po=/\/?$/;function uo(n,e,t,r){var a=r&&r.options.stringifyQuery,o=e.query||{};try{o=fo(o)}catch(n){}var i={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:o,params:e.params||{},fullPath:vo(e,a),matched:n?mo(n):[]};return t&&(i.redirectedFrom=vo(t,a)),Object.freeze(i)}function fo(n){if(Array.isArray(n))return n.map(fo);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=fo(n[t]);return e}return n}var ho=uo(null,{path:"/"});function mo(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function vo(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var a=n.hash;return void 0===a&&(a=""),(t||"/")+(e||co)(r)+a}function go(n,e,t){return e===ho?n===e:!!e&&(n.path&&e.path?n.path.replace(po,"")===e.path.replace(po,"")&&(t||n.hash===e.hash&&bo(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&bo(n.query,e.query)&&bo(n.params,e.params))))}function bo(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,a){var o=n[t];if(r[a]!==t)return!1;var i=e[t];return null==o||null==i?o===i:"object"==typeof o&&"object"==typeof i?bo(o,i):String(o)===String(i)}))}function xo(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var a=t.instances[r],o=t.enteredCbs[r];if(a&&o){delete t.enteredCbs[r];for(var i=0;i<o.length;i++)a._isBeingDestroyed||o[i](a)}}}}var yo={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,a=e.parent,o=e.data;o.routerView=!0;for(var i=a.$createElement,s=t.name,l=a.$route,c=a._routerViewCache||(a._routerViewCache={}),p=0,u=!1;a&&a._routerRoot!==a;){var d=a.$vnode?a.$vnode.data:{};d.routerView&&p++,d.keepAlive&&a._directInactive&&a._inactive&&(u=!0),a=a.$parent}if(o.routerViewDepth=p,u){var f=c[s],h=f&&f.component;return h?(f.configProps&&Eo(h,o,f.route,f.configProps),i(h,o,r)):i()}var m=l.matched[p],v=m&&m.components[s];if(!m||!v)return c[s]=null,i();c[s]={component:v},o.registerRouteInstance=function(n,e){var t=m.instances[s];(e&&t!==n||!e&&t===n)&&(m.instances[s]=e)},(o.hook||(o.hook={})).prepatch=function(n,e){m.instances[s]=e.componentInstance},o.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==m.instances[s]&&(m.instances[s]=n.componentInstance),xo(l)};var g=m.props&&m.props[s];return g&&(eo(c[s],{route:l,configProps:g}),Eo(v,o,l,g)),i(v,o,r)}};function Eo(n,e,t,r){var a=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(a){a=e.props=eo({},a);var o=e.attrs=e.attrs||{};for(var i in a)n.props&&i in n.props||(o[i]=a[i],delete a[i])}}function Bo(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var o=n.replace(/^\//,"").split("/"),i=0;i<o.length;i++){var s=o[i];".."===s?a.pop():"."!==s&&a.push(s)}return""!==a[0]&&a.unshift(""),a.join("/")}function Po(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var _o=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},Co=Lo,Ao=Io,wo=function(n,e){return zo(Io(n,e),e)},So=zo,ko=$o,To=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Io(n,e){for(var t,r=[],a=0,o=0,i="",s=e&&e.delimiter||"/";null!=(t=To.exec(n));){var l=t[0],c=t[1],p=t.index;if(i+=n.slice(o,p),o=p+l.length,c)i+=c[1];else{var u=n[o],d=t[2],f=t[3],h=t[4],m=t[5],v=t[6],g=t[7];i&&(r.push(i),i="");var b=null!=d&&null!=u&&u!==d,x="+"===v||"*"===v,y="?"===v||"*"===v,E=t[2]||s,B=h||m;r.push({name:f||a++,prefix:d||"",delimiter:E,optional:y,repeat:x,partial:b,asterisk:!!g,pattern:B?Do(B):g?".*":"[^"+Oo(E)+"]+?"})}}return o<n.length&&(i+=n.substr(o)),i&&r.push(i),r}function jo(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function zo(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",Uo(e)));return function(e,r){for(var a="",o=e||{},i=(r||{}).pretty?jo:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,p=o[l.name];if(null==p){if(l.optional){l.partial&&(a+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(_o(p)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(p)+"`");if(0===p.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var u=0;u<p.length;u++){if(c=i(p[u]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");a+=(0===u?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(p).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):i(p),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');a+=l.prefix+c}}else a+=l}return a}}function Oo(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Do(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Fo(n,e){return n.keys=e,n}function Uo(n){return n&&n.sensitive?"":"i"}function $o(n,e,t){_o(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,a=!1!==t.end,o="",i=0;i<n.length;i++){var s=n[i];if("string"==typeof s)o+=Oo(s);else{var l=Oo(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),o+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var p=Oo(t.delimiter||"/"),u=o.slice(-p.length)===p;return r||(o=(u?o.slice(0,-p.length):o)+"(?:"+p+"(?=$))?"),o+=a?"$":r&&u?"":"(?="+p+"|$)",Fo(new RegExp("^"+o,Uo(t)),e)}function Lo(n,e,t){return _o(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Fo(n,e)}(n,e):_o(n)?function(n,e,t){for(var r=[],a=0;a<n.length;a++)r.push(Lo(n[a],e,t).source);return Fo(new RegExp("(?:"+r.join("|")+")",Uo(t)),e)}(n,e,t):function(n,e,t){return $o(Io(n,t),e,t)}(n,e,t)}Co.parse=Ao,Co.compile=wo,Co.tokensToFunction=So,Co.tokensToRegExp=ko;var Ro=Object.create(null);function Mo(n,e,t){e=e||{};try{var r=Ro[n]||(Ro[n]=Co.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function No(n,e,t,r){var a="string"==typeof n?{path:n}:n;if(a._normalized)return a;if(a.name){var o=(a=eo({},n)).params;return o&&"object"==typeof o&&(a.params=eo({},o)),a}if(!a.path&&a.params&&e){(a=eo({},a))._normalized=!0;var i=eo(eo({},e.params),a.params);if(e.name)a.name=e.name,a.params=i;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;a.path=Mo(s,i,e.path)}else 0;return a}var l=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var a=n.indexOf("?");return a>=0&&(t=n.slice(a+1),n=n.slice(0,a)),{path:n,query:t,hash:e}}(a.path||""),c=e&&e.path||"/",p=l.path?Bo(l.path,c,t||a.append):c,u=function(n,e,t){void 0===e&&(e={});var r,a=t||lo;try{r=a(n||"")}catch(n){r={}}for(var o in e){var i=e[o];r[o]=Array.isArray(i)?i.map(so):so(i)}return r}(l.query,a.query,r&&r.options.parseQuery),d=a.hash||l.hash;return d&&"#"!==d.charAt(0)&&(d="#"+d),{_normalized:!0,path:p,query:u,hash:d}}var Vo,Ho=function(){},qo={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,a=t.resolve(this.to,r,this.append),o=a.location,i=a.route,s=a.href,l={},c=t.options.linkActiveClass,p=t.options.linkExactActiveClass,u=null==c?"router-link-active":c,d=null==p?"router-link-exact-active":p,f=null==this.activeClass?u:this.activeClass,h=null==this.exactActiveClass?d:this.exactActiveClass,m=i.redirectedFrom?uo(null,No(i.redirectedFrom),null,t):i;l[h]=go(r,m,this.exactPath),l[f]=this.exact||this.exactPath?l[h]:function(n,e){return 0===n.path.replace(po,"/").indexOf(e.path.replace(po,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,m);var v=l[h]?this.ariaCurrentValue:null,g=function(n){Ko(n)&&(e.replace?t.replace(o,Ho):t.push(o,Ho))},b={click:Ko};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=g})):b[this.event]=g;var x={class:l},y=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:i,navigate:g,isActive:l[f],isExactActive:l[h]});if(y){if(1===y.length)return y[0];if(y.length>1||!y.length)return 0===y.length?n():n("span",{},y)}if("a"===this.tag)x.on=b,x.attrs={href:s,"aria-current":v};else{var E=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(E){E.isStatic=!1;var B=E.data=eo({},E.data);for(var P in B.on=B.on||{},B.on){var _=B.on[P];P in b&&(B.on[P]=Array.isArray(_)?_:[_])}for(var C in b)C in B.on?B.on[C].push(b[C]):B.on[C]=g;var A=E.data.attrs=eo({},E.data.attrs);A.href=s,A["aria-current"]=v}else x.on=b}return n(this.tag,x,this.$slots.default)}};function Ko(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Xo="undefined"!=typeof window;function Zo(n,e,t,r,a){var o=e||[],i=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,a,o,i){var s=a.path,l=a.name;0;var c=a.pathToRegexpOptions||{},p=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return Po(e.path+"/"+n)}(s,o,c.strict);"boolean"==typeof a.caseSensitive&&(c.sensitive=a.caseSensitive);var u={path:p,regex:Wo(p,c),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:l,parent:o,matchAs:i,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};a.children&&a.children.forEach((function(a){var o=i?Po(i+"/"+a.path):void 0;n(e,t,r,a,u,o)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==a.alias)for(var d=Array.isArray(a.alias)?a.alias:[a.alias],f=0;f<d.length;++f){0;var h={path:d[f],children:a.children};n(e,t,r,h,o,u.path||"/")}l&&(r[l]||(r[l]=u))}(o,i,s,n,a)}));for(var l=0,c=o.length;l<c;l++)"*"===o[l]&&(o.push(o.splice(l,1)[0]),c--,l--);return{pathList:o,pathMap:i,nameMap:s}}function Wo(n,e){return Co(n,[],e)}function Go(n,e){var t=Zo(n),r=t.pathList,a=t.pathMap,o=t.nameMap;function i(n,t,i){var s=No(n,t,!1,e),c=s.name;if(c){var p=o[c];if(!p)return l(null,s);var u=p.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var d in t.params)!(d in s.params)&&u.indexOf(d)>-1&&(s.params[d]=t.params[d]);return s.path=Mo(p.path,s.params),l(p,s,i)}if(s.path){s.params={};for(var f=0;f<r.length;f++){var h=r[f],m=a[h];if(Jo(m.regex,s.path,s.params))return l(m,s,i)}}return l(null,s)}function s(n,t){var r=n.redirect,a="function"==typeof r?r(uo(n,t,null,e)):r;if("string"==typeof a&&(a={path:a}),!a||"object"!=typeof a)return l(null,t);var s=a,c=s.name,p=s.path,u=t.query,d=t.hash,f=t.params;if(u=s.hasOwnProperty("query")?s.query:u,d=s.hasOwnProperty("hash")?s.hash:d,f=s.hasOwnProperty("params")?s.params:f,c){o[c];return i({_normalized:!0,name:c,query:u,hash:d,params:f},void 0,t)}if(p){var h=function(n,e){return Bo(n,e.parent?e.parent.path:"/",!0)}(p,n);return i({_normalized:!0,path:Mo(h,f),query:u,hash:d},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=i({_normalized:!0,path:Mo(t,e.params)});if(r){var a=r.matched,o=a[a.length-1];return e.params=r.params,l(o,e)}return l(null,e)}(0,t,n.matchAs):uo(n,t,r,e)}return{match:i,addRoute:function(n,e){var t="object"!=typeof n?o[n]:void 0;Zo([e||n],r,a,o,t),t&&t.alias.length&&Zo(t.alias.map((function(n){return{path:n,children:[e]}})),r,a,o,t)},getRoutes:function(){return r.map((function(n){return a[n]}))},addRoutes:function(n){Zo(n,r,a,o)}}}function Jo(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var a=1,o=r.length;a<o;++a){var i=n.keys[a-1];i&&(t[i.name||"pathMatch"]="string"==typeof r[a]?io(r[a]):r[a])}return!0}var Yo=Xo&&window.performance&&window.performance.now?window.performance:Date;function Qo(){return Yo.now().toFixed(3)}var ni=Qo();function ei(){return ni}function ti(n){return ni=n}var ri=Object.create(null);function ai(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=eo({},window.history.state);return t.key=ei(),window.history.replaceState(t,"",e),window.addEventListener("popstate",si),function(){window.removeEventListener("popstate",si)}}function oi(n,e,t,r){if(n.app){var a=n.options.scrollBehavior;a&&n.app.$nextTick((function(){var o=function(){var n=ei();if(n)return ri[n]}(),i=a.call(n,e,t,r?o:null);i&&("function"==typeof i.then?i.then((function(n){di(n,o)})).catch((function(n){0})):di(i,o))}))}}function ii(){var n=ei();n&&(ri[n]={x:window.pageXOffset,y:window.pageYOffset})}function si(n){ii(),n.state&&n.state.key&&ti(n.state.key)}function li(n){return pi(n.x)||pi(n.y)}function ci(n){return{x:pi(n.x)?n.x:window.pageXOffset,y:pi(n.y)?n.y:window.pageYOffset}}function pi(n){return"number"==typeof n}var ui=/^#\d/;function di(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var a=ui.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(a){var o=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(a,o={x:pi((t=o).x)?t.x:0,y:pi(t.y)?t.y:0})}else li(n)&&(e=ci(n))}else r&&li(n)&&(e=ci(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var fi,hi=Xo&&((-1===(fi=window.navigator.userAgent).indexOf("Android 2.")&&-1===fi.indexOf("Android 4.0")||-1===fi.indexOf("Mobile Safari")||-1!==fi.indexOf("Chrome")||-1!==fi.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function mi(n,e){ii();var t=window.history;try{if(e){var r=eo({},t.state);r.key=ei(),t.replaceState(r,"",n)}else t.pushState({key:ti(Qo())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function vi(n){mi(n,!0)}var gi={redirected:2,aborted:4,cancelled:8,duplicated:16};function bi(n,e){return yi(n,e,gi.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return Ei.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function xi(n,e){return yi(n,e,gi.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function yi(n,e,t,r){var a=new Error(r);return a._isRouter=!0,a.from=n,a.to=e,a.type=t,a}var Ei=["params","query","hash"];function Bi(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function Pi(n,e){return Bi(n)&&n._isRouter&&(null==e||n.type===e)}function _i(n,e,t){var r=function(a){a>=n.length?t():n[a]?e(n[a],(function(){r(a+1)})):r(a+1)};r(0)}function Ci(n){return function(e,t,r){var a=!1,o=0,i=null;Ai(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){a=!0,o++;var l,c=ki((function(e){var a;((a=e).__esModule||Si&&"Module"===a[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Vo.extend(e),t.components[s]=e,--o<=0&&r()})),p=ki((function(n){var e="Failed to resolve async component "+s+": "+n;i||(i=Bi(n)?n:new Error(e),r(i))}));try{l=n(c,p)}catch(n){p(n)}if(l)if("function"==typeof l.then)l.then(c,p);else{var u=l.component;u&&"function"==typeof u.then&&u.then(c,p)}}})),a||r()}}function Ai(n,e){return wi(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function wi(n){return Array.prototype.concat.apply([],n)}var Si="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function ki(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var Ti=function(n,e){this.router=n,this.base=function(n){if(!n)if(Xo){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=ho,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Ii(n,e,t,r){var a=Ai(n,(function(n,r,a,o){var i=function(n,e){"function"!=typeof n&&(n=Vo.extend(n));return n.options[e]}(n,e);if(i)return Array.isArray(i)?i.map((function(n){return t(n,r,a,o)})):t(i,r,a,o)}));return wi(r?a.reverse():a)}function ji(n,e){if(e)return function(){return n.apply(e,arguments)}}Ti.prototype.listen=function(n){this.cb=n},Ti.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Ti.prototype.onError=function(n){this.errorCbs.push(n)},Ti.prototype.transitionTo=function(n,e,t){var r,a=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var o=this.current;this.confirmTransition(r,(function(){a.updateRoute(r),e&&e(r),a.ensureURL(),a.router.afterHooks.forEach((function(n){n&&n(r,o)})),a.ready||(a.ready=!0,a.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!a.ready&&(Pi(n,gi.redirected)&&o===ho||(a.ready=!0,a.readyErrorCbs.forEach((function(e){e(n)}))))}))},Ti.prototype.confirmTransition=function(n,e,t){var r=this,a=this.current;this.pending=n;var o,i,s=function(n){!Pi(n)&&Bi(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=a.matched.length-1;if(go(n,a)&&l===c&&n.matched[l]===a.matched[c])return this.ensureURL(),n.hash&&oi(this.router,a,n,!1),s(((i=yi(o=a,n,gi.duplicated,'Avoided redundant navigation to current location: "'+o.fullPath+'".')).name="NavigationDuplicated",i));var p=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=p.updated,d=p.deactivated,f=p.activated,h=[].concat(function(n){return Ii(n,"beforeRouteLeave",ji,!0)}(d),this.router.beforeHooks,function(n){return Ii(n,"beforeRouteUpdate",ji)}(u),f.map((function(n){return n.beforeEnter})),Ci(f)),m=function(e,t){if(r.pending!==n)return s(xi(a,n));try{e(n,a,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return yi(n,e,gi.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(a,n))):Bi(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(bi(a,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};_i(h,m,(function(){_i(function(n){return Ii(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,a,o){return n(r,a,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),o(n)}))}}(n,t,r)}))}(f).concat(r.router.resolveHooks),m,(function(){if(r.pending!==n)return s(xi(a,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){xo(n)}))}))}))},Ti.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Ti.prototype.setupListeners=function(){},Ti.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=ho,this.pending=null};var zi=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Oi(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=hi&&t;r&&this.listeners.push(ai());var a=function(){var t=n.current,a=Oi(n.base);n.current===ho&&a===n._startLocation||n.transitionTo(a,(function(n){r&&oi(e,n,t,!0)}))};window.addEventListener("popstate",a),this.listeners.push((function(){window.removeEventListener("popstate",a)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){mi(Po(r.base+n.fullPath)),oi(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){vi(Po(r.base+n.fullPath)),oi(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Oi(this.base)!==this.current.fullPath){var e=Po(this.base+this.current.fullPath);n?mi(e):vi(e)}},e.prototype.getCurrentLocation=function(){return Oi(this.base)},e}(Ti);function Oi(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(Po(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Di=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=Oi(n);if(!/^\/#/.test(e))return window.location.replace(Po(n+"/#"+e)),!0}(this.base)||Fi()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=hi&&e;t&&this.listeners.push(ai());var r=function(){var e=n.current;Fi()&&n.transitionTo(Ui(),(function(r){t&&oi(n.router,r,e,!0),hi||Ri(r.fullPath)}))},a=hi?"popstate":"hashchange";window.addEventListener(a,r),this.listeners.push((function(){window.removeEventListener(a,r)}))}},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Li(n.fullPath),oi(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Ri(n.fullPath),oi(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Ui()!==e&&(n?Li(e):Ri(e))},e.prototype.getCurrentLocation=function(){return Ui()},e}(Ti);function Fi(){var n=Ui();return"/"===n.charAt(0)||(Ri("/"+n),!1)}function Ui(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function $i(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Li(n){hi?mi($i(n)):window.location.hash=n}function Ri(n){hi?vi($i(n)):window.location.replace($i(n))}var Mi=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){Pi(n,gi.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Ti),Ni=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Go(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!hi&&!1!==n.fallback,this.fallback&&(e="hash"),Xo||(e="abstract"),this.mode=e,e){case"history":this.history=new zi(this,n.base);break;case"hash":this.history=new Di(this,n.base,this.fallback);break;case"abstract":this.history=new Mi(this,n.base);break;default:0}},Vi={currentRoute:{configurable:!0}};Ni.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Vi.currentRoute.get=function(){return this.history&&this.history.current},Ni.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof zi||t instanceof Di){var r=function(n){t.setupListeners(),function(n){var r=t.current,a=e.options.scrollBehavior;hi&&a&&"fullPath"in n&&oi(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Ni.prototype.beforeEach=function(n){return qi(this.beforeHooks,n)},Ni.prototype.beforeResolve=function(n){return qi(this.resolveHooks,n)},Ni.prototype.afterEach=function(n){return qi(this.afterHooks,n)},Ni.prototype.onReady=function(n,e){this.history.onReady(n,e)},Ni.prototype.onError=function(n){this.history.onError(n)},Ni.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},Ni.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},Ni.prototype.go=function(n){this.history.go(n)},Ni.prototype.back=function(){this.go(-1)},Ni.prototype.forward=function(){this.go(1)},Ni.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Ni.prototype.resolve=function(n,e,t){var r=No(n,e=e||this.history.current,t,this),a=this.match(r,e),o=a.redirectedFrom||a.fullPath;return{location:r,route:a,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?Po(n+"/"+r):r}(this.history.base,o,this.mode),normalizedTo:r,resolved:a}},Ni.prototype.getRoutes=function(){return this.matcher.getRoutes()},Ni.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==ho&&this.history.transitionTo(this.history.getCurrentLocation())},Ni.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==ho&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Ni.prototype,Vi);var Hi=Ni;function qi(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Ni.install=function n(e){if(!n.installed||Vo!==e){n.installed=!0,Vo=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",yo),e.component("RouterLink",qo);var a=e.config.optionMergeStrategies;a.beforeRouteEnter=a.beforeRouteLeave=a.beforeRouteUpdate=a.created}},Ni.version="3.6.5",Ni.isNavigationFailure=Pi,Ni.NavigationFailureType=gi,Ni.START_LOCATION=ho,Xo&&window.Vue&&window.Vue.use(Ni);t(103);t(16),t(130);var Ki={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,330)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,329))},Xi={"v-dac9f86c":()=>t.e(6).then(t.bind(null,331)),"v-0547b318":()=>t.e(9).then(t.bind(null,332)),"v-511a7ce0":()=>t.e(5).then(t.bind(null,333)),"v-1bc65186":()=>t.e(10).then(t.bind(null,334)),"v-b8115b44":()=>t.e(7).then(t.bind(null,335)),"v-694da75f":()=>t.e(11).then(t.bind(null,336)),"v-ee7d4de2":()=>t.e(8).then(t.bind(null,337)),"v-c926f994":()=>t.e(13).then(t.bind(null,338)),"v-7d4e16c2":()=>t.e(12).then(t.bind(null,339)),"v-1df475c6":()=>t.e(14).then(t.bind(null,340)),"v-7196114d":()=>t.e(15).then(t.bind(null,341)),"v-32484570":()=>t.e(17).then(t.bind(null,342)),"v-6d5faa60":()=>t.e(18).then(t.bind(null,343)),"v-20343e8e":()=>t.e(16).then(t.bind(null,344)),"v-a0bcf658":()=>t.e(20).then(t.bind(null,345)),"v-4be611fe":()=>t.e(19).then(t.bind(null,346)),"v-6dc754d2":()=>t.e(21).then(t.bind(null,347)),"v-072dd8ef":()=>t.e(22).then(t.bind(null,348)),"v-a7225ce8":()=>t.e(23).then(t.bind(null,349)),"v-19dfd020":()=>t.e(24).then(t.bind(null,350)),"v-8dbc2d50":()=>t.e(25).then(t.bind(null,351)),"v-c91c1caa":()=>t.e(27).then(t.bind(null,352)),"v-08eb3d76":()=>t.e(28).then(t.bind(null,353)),"v-21e297d6":()=>t.e(26).then(t.bind(null,354)),"v-438f4343":()=>t.e(30).then(t.bind(null,355)),"v-3decb41e":()=>t.e(29).then(t.bind(null,356)),"v-9583bd3c":()=>t.e(31).then(t.bind(null,357)),"v-60ef5aff":()=>t.e(32).then(t.bind(null,358)),"v-8ecad5d0":()=>t.e(34).then(t.bind(null,359)),"v-c81693ae":()=>t.e(35).then(t.bind(null,360)),"v-163d8114":()=>t.e(33).then(t.bind(null,361)),"v-a2241a92":()=>t.e(36).then(t.bind(null,362)),"v-95f67a58":()=>t.e(38).then(t.bind(null,363)),"v-55469fce":()=>t.e(37).then(t.bind(null,364)),"v-10ced923":()=>t.e(39).then(t.bind(null,365)),"v-ebc83474":()=>t.e(40).then(t.bind(null,366)),"v-64f88198":()=>t.e(41).then(t.bind(null,367)),"v-269b9ef7":()=>t.e(42).then(t.bind(null,368)),"v-71917082":()=>t.e(43).then(t.bind(null,369)),"v-88e97502":()=>t.e(44).then(t.bind(null,370)),"v-cd163ea4":()=>t.e(46).then(t.bind(null,371)),"v-bd5139f6":()=>t.e(45).then(t.bind(null,372)),"v-64e50a5c":()=>t.e(47).then(t.bind(null,373)),"v-424e13f0":()=>t.e(48).then(t.bind(null,374)),"v-98f5d5a4":()=>t.e(49).then(t.bind(null,375)),"v-e967490c":()=>t.e(50).then(t.bind(null,376)),"v-2843adab":()=>t.e(51).then(t.bind(null,377)),"v-47390ea0":()=>t.e(52).then(t.bind(null,378)),"v-139c8f69":()=>t.e(53).then(t.bind(null,379)),"v-8268a1fe":()=>t.e(54).then(t.bind(null,380)),"v-31c3f598":()=>t.e(55).then(t.bind(null,381)),"v-12cb66be":()=>t.e(56).then(t.bind(null,382)),"v-525139f4":()=>t.e(58).then(t.bind(null,383)),"v-35d53af0":()=>t.e(57).then(t.bind(null,384))};function Zi(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Wi=/-(\w)/g,Gi=Zi(n=>n.replace(Wi,(n,e)=>e?e.toUpperCase():"")),Ji=/\B([A-Z])/g,Yi=Zi(n=>n.replace(Ji,"-$1").toLowerCase()),Qi=Zi(n=>n.charAt(0).toUpperCase()+n.slice(1));function ns(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Qi(Gi(e))):n(Qi(e))||n(Yi(e))}const es=Object.assign({},Ki,Xi),ts=n=>es[n],rs=n=>Xi[n],as=n=>Ki[n],os=n=>Kt.component(n);function is(n){return ns(rs,n)}function ss(n){return ns(as,n)}function ls(n){return ns(ts,n)}function cs(n){return ns(os,n)}function ps(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!cs(n)&&ls(n)){const e=await ls(n)();Kt.component(n,e.default)}}))}function us(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var ds=t(92),fs=t.n(ds),hs=t(93),ms=t.n(hs),vs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${ms()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=bs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=xs(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return fs()([{name:"description",content:this.$description}],n,this.siteMeta,ys)},updateCanonicalLink(){gs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",bs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){xs(null,this.currentMetaTags),gs()}};function gs(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function bs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function xs(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function ys(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var Es=t(50),Bs={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(Es)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),a=window.innerHeight+t;for(let n=0;n<e.length;n++){const o=e[n],i=e[n+1],s=0===n&&0===t||t>=o.parentElement.offsetTop+10&&(!i||t<i.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(o.hash)){const t=o;if(a===r)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},Ps=t(24),_s=t.n(Ps),Cs={mounted(){_s.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Kt.component(n.name)||_s.a.start(),t()}),this.$router.afterEach(()=>{_s.a.done(),this.isSidebarOpen=!1})}};t(238),t(239);class As{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var ws={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="复制代码",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new As).show({text:"复制成功",duration:900}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],a=document.createElement("style");a.type="text/css","top"===t&&r.firstChild?r.insertBefore(a,r.firstChild):r.appendChild(a),a.styleSheet?a.styleSheet.cssText=n:a.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Ss={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},ks={},Ts=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},Is=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:Ss[n]},js=function n(e,t,r){var a=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))a[n]=t[n];else{var e=n.replace("data","");a.dataset[e]=t[n]}})),r&&r.forEach((function(e){var t=e.tag,r=e.attrs,o=e.children;a.appendChild(n(t,r,o))})),a},zs=function(n,e,t){var r,a=(r=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(r));return 1!==a.length||t?a:a[0]},Os=function(n,e){var t,r,a=n.match(/<style>([\s\S]+)<\/style>/),o=n.match(/<template>([\s\S]+)<\/template>/),i=n.match(/<script>([\s\S]+)<\/script>/),s={css:a&&a[1].replace(/^\n|\n$/g,""),html:o&&o[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=Ts(s.html),s.jsTpl=(t=s.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),a=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,o=[eval][0](a);return o.template=e,o}(s.js,s.html);var l=Is("vue");return s.jsLib.unshift(l),s},Ds=function(n,e){var t,r=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<html>([\s\S]+)<\/html>/),o=n.match(/<script>([\s\S]+)<\/script>/),i={css:r&&r[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return i.htmlTpl=i.html,i.jsTpl=i.js,i.script=(t=i.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),i},Fs=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Us(){var n=zs(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=zs(n,"vuepress-plugin-demo-block__code"),t=zs(n,"vuepress-plugin-demo-block__display"),r=zs(n,"vuepress-plugin-demo-block__footer"),a=zs(t,"vuepress-plugin-demo-block__app"),o=decodeURIComponent(n.dataset.code),i=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);i=i?JSON.parse(i):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),a=new Function("return ".concat(r))(),o={js:a,css:a.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Fs(n),htmlTpl:Ts("")},i=Is("react"),s=Is("reactDOM");return o.jsLib.unshift(i,s),o}(o,i):"vanilla"===s?Ds(o,i):Os(o,i),p=js("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(p),p.addEventListener("click",$s.bind(null,p,l,e,r)),Is("jsfiddle")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,a=n.jsLib,o=n.cssLib,i=a.concat(o).concat(Is("cssLib")).concat(Is("jsLib")).join(",");return js("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:i}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),Is("codepen")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,a=n.jsLib,o=n.cssLib,i=JSON.stringify({css:e,html:t,js:r,js_external:a.concat(Is("jsLib")).join(";"),css_external:o.concat(Is("cssLib")).join(";"),layout:Is("codepenLayout"),js_pre_processor:Is("codepenJsProcessor"),editors:Is("codepenEditors")});return js("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:i}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==i.horizontal?i.horizontal:Is("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var u=e.firstChild.cloneNode(!0);u.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(u)}if(c.css&&function(n){if(!ks[n]){var e=js("style",{innerHTML:n});document.body.appendChild(e),ks[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),a);else if("vue"===s){var d=(new(Vue.extend(c.script))).$mount();a.appendChild(d.$el)}else"vanilla"===s&&(a.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Us()}),300)}function $s(n,e,t,r){var a="1"!==n.dataset.isExpand;t.style.height=a?"".concat(e,"px"):0,a?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=a?"1":"0"}var Ls={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Us()},updated:function(){Us()}},Rs="auto",Ms="zoom-in",Ns="zoom-out",Vs="grab",Hs="move";function qs(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a={passive:!1};r?n.addEventListener(e,t,a):n.removeEventListener(e,t,a)}function Ks(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Xs(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Zs(n,e,t){!function(n){var e=Ws,t=Gs;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var a=n.transform;delete n.transform,n[t]=a}}(e);var r=n.style,a={};for(var o in e)t&&(a[o]=r[o]||""),r[o]=e[o];return a}var Ws="transition",Gs="transform",Js="transform",Ys="transitionend";var Qs=function(){},nl={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Qs,onClose:Qs,onGrab:Qs,onMove:Qs,onRelease:Qs,onBeforeOpen:Qs,onBeforeClose:Qs,onBeforeGrab:Qs,onBeforeRelease:Qs,onImageLoading:Qs,onImageLoaded:Qs},el={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),rl(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,a=this.lastScrollPosition.y-t,o=this.options.scrollThreshold;(Math.abs(a)>=o||Math.abs(r)>=o)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(tl(n)&&!rl(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){tl(n)&&!rl(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function tl(n){return 0===n.button}function rl(n){return n.metaKey||n.ctrlKey}var al={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Zs(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),qs(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Zs(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},ol="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},il=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),sl=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},ll={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Xs(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,a=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Vs:Ns,transition:Js+"\n        "+r+"s\n        "+a,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Zs(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Zs(this.el,{transform:"none"})},grab:function(n,e,t){var r=cl(),a=r.x-n,o=r.y-e;Zs(this.el,{cursor:Hs,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=cl(),a=r.x-n,o=r.y-e;Zs(this.el,{transition:Js,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Zs(this.el,this.styleClose)},restoreOpenStyle:function(){Zs(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=cl(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,a=r.customSize,o=r.scaleBase;if(!a&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(a&&"object"===(void 0===a?"undefined":ol(a)))return{x:a.width/this.rect.width,y:a.height/this.rect.height};var i=this.rect.width/2,s=this.rect.height/2,l=cl(),c={x:l.x-i,y:l.y-s},p=c.x/i,u=c.y/s,d=o+Math.min(p,u);if(a&&"string"==typeof a){var f=t||this.el.naturalWidth,h=e||this.el.naturalHeight,m=parseFloat(a)*f/(100*this.rect.width),v=parseFloat(a)*h/(100*this.rect.height);if(d>m||d>v)return{x:m,y:v}}return{x:d,y:d}}};function cl(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function pl(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){qs(n,r,e[r],t)}))}var ul=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(ll),this.overlay=Object.create(al),this.handler=Object.create(el),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=sl({},nl,e),this.overlay.init(this),this.handler.init(this)}return il(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Ms,qs(n,"click",this.handler.click),this.options.preloadImage&&Ks(Xs(n)));return this}},{key:"config",value:function(n){return n?(sl(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var a=this.target.srcOriginal;null!=a&&(this.options.onImageLoading(r),Ks(a,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),qs(document,"scroll",this.handler.scroll),qs(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&qs(window,"resize",this.handler.resizeWindow);var o=function n(){qs(r,Ys,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&pl(document,e.handler,!0),t(r)};return qs(r,Ys,o),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Rs,this.overlay.fadeOut(),this.target.zoomOut(),qs(document,"scroll",this.handler.scroll,!1),qs(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&qs(window,"resize",this.handler.resizeWindow,!1);var r=function r(){qs(t,Ys,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&pl(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return qs(t,Ys,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var a=this.target.el;this.options.onBeforeGrab(a),this.released=!1,this.target.grab(n,e,t);var o=function n(){qs(a,Ys,n,!1),r(a)};return qs(a,Ys,o),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Hs,this.target.move(n,e,t);var a=this.target.el,o=function n(){qs(a,Ys,n,!1),r(a)};return qs(a,Ys,o),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Rs,this.target.restoreOpenStyle();var r=function r(){qs(t,Ys,r,!1),n.lock=!1,n.released=!0,e(t)};return qs(t,Ys,r),this}}}]),n}();const dl=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),fl=Number("500");class hl{constructor(){this.instance=new ul(dl)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=fl){setTimeout(()=>this.update(n),e)}}var ml=[vs,Bs,Cs,ws,Ls,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new hl,this.$vuepress.zooming.updateDelay()}}],vl={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return us("layout",n),Kt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},gl=t(7),bl=Object(gl.a)(vl,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(bl,"mixins",ml);const xl=[{name:"v-dac9f86c",path:"/pages/d1af54/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-dac9f86c").then(t)}},{path:"/pages/d1af54/index.html",redirect:"/pages/d1af54/"},{path:"/01.操作系统/02.第一章 操作系统引论/02.单道批处理.html",redirect:"/pages/d1af54/"},{name:"v-0547b318",path:"/pages/ed294b/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-0547b318").then(t)}},{path:"/pages/ed294b/index.html",redirect:"/pages/ed294b/"},{path:"/01.操作系统/02.第一章 操作系统引论/05.分时操作系统.html",redirect:"/pages/ed294b/"},{name:"v-511a7ce0",path:"/pages/5719ac/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-511a7ce0").then(t)}},{path:"/pages/5719ac/index.html",redirect:"/pages/5719ac/"},{path:"/01.操作系统/01.关于本文档/01.操作系统课程笔记.html",redirect:"/pages/5719ac/"},{name:"v-1bc65186",path:"/pages/f50a2e/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-1bc65186").then(t)}},{path:"/pages/f50a2e/index.html",redirect:"/pages/f50a2e/"},{path:"/01.操作系统/02.第一章 操作系统引论/06.实时操作系统.html",redirect:"/pages/f50a2e/"},{name:"v-b8115b44",path:"/pages/4722dd/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-b8115b44").then(t)}},{path:"/pages/4722dd/index.html",redirect:"/pages/4722dd/"},{path:"/01.操作系统/02.第一章 操作系统引论/03.多道批处理.html",redirect:"/pages/4722dd/"},{name:"v-694da75f",path:"/pages/bc61d3/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-694da75f").then(t)}},{path:"/pages/bc61d3/index.html",redirect:"/pages/bc61d3/"},{path:"/01.操作系统/02.第一章 操作系统引论/07.操作系统的四个基础特性.html",redirect:"/pages/bc61d3/"},{name:"v-ee7d4de2",path:"/pages/d4063c/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-ee7d4de2").then(t)}},{path:"/pages/d4063c/index.html",redirect:"/pages/d4063c/"},{path:"/01.操作系统/02.第一章 操作系统引论/04.并发与并行的区别.html",redirect:"/pages/d4063c/"},{name:"v-c926f994",path:"/pages/ebecb5/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-c926f994").then(t)}},{path:"/pages/ebecb5/index.html",redirect:"/pages/ebecb5/"},{path:"/01.操作系统/02.第一章 操作系统引论/09.作业1.html",redirect:"/pages/ebecb5/"},{name:"v-7d4e16c2",path:"/pages/4d01a9/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-7d4e16c2").then(t)}},{path:"/pages/4d01a9/index.html",redirect:"/pages/4d01a9/"},{path:"/01.操作系统/02.第一章 操作系统引论/08.现代OS的基本单位.html",redirect:"/pages/4d01a9/"},{name:"v-1df475c6",path:"/pages/5203e5/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-1df475c6").then(t)}},{path:"/pages/5203e5/index.html",redirect:"/pages/5203e5/"},{path:"/01.操作系统/02.第一章 操作系统引论/10.内核.html",redirect:"/pages/5203e5/"},{name:"v-7196114d",path:"/pages/ee322f/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-7196114d").then(t)}},{path:"/pages/ee322f/index.html",redirect:"/pages/ee322f/"},{path:"/01.操作系统/02.第一章 操作系统引论/11.中断和异常.html",redirect:"/pages/ee322f/"},{name:"v-32484570",path:"/pages/1fd856/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-32484570").then(t)}},{path:"/pages/1fd856/index.html",redirect:"/pages/1fd856/"},{path:"/01.操作系统/02.第一章 操作系统引论/13.冷启动和热启动.html",redirect:"/pages/1fd856/"},{name:"v-6d5faa60",path:"/pages/e900d8/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-6d5faa60").then(t)}},{path:"/pages/e900d8/index.html",redirect:"/pages/e900d8/"},{path:"/01.操作系统/02.第一章 操作系统引论/14.补充资料.html",redirect:"/pages/e900d8/"},{name:"v-20343e8e",path:"/pages/1501a6/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-20343e8e").then(t)}},{path:"/pages/1501a6/index.html",redirect:"/pages/1501a6/"},{path:"/01.操作系统/02.第一章 操作系统引论/12.系统调用.html",redirect:"/pages/1501a6/"},{name:"v-a0bcf658",path:"/pages/82c444/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-a0bcf658").then(t)}},{path:"/pages/82c444/index.html",redirect:"/pages/82c444/"},{path:"/01.操作系统/02.第一章 操作系统引论/16.附言.html",redirect:"/pages/82c444/"},{name:"v-4be611fe",path:"/pages/3f251a/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-4be611fe").then(t)}},{path:"/pages/3f251a/index.html",redirect:"/pages/3f251a/"},{path:"/01.操作系统/02.第一章 操作系统引论/15.作业2.html",redirect:"/pages/3f251a/"},{name:"v-6dc754d2",path:"/pages/1f0d42/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-6dc754d2").then(t)}},{path:"/pages/1f0d42/index.html",redirect:"/pages/1f0d42/"},{path:"/01.操作系统/03.第二章 进程的描述与控制/02.程序的基本概念.html",redirect:"/pages/1f0d42/"},{name:"v-072dd8ef",path:"/pages/a98e4b/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-072dd8ef").then(t)}},{path:"/pages/a98e4b/index.html",redirect:"/pages/a98e4b/"},{path:"/01.操作系统/03.第二章 进程的描述与控制/03.进程的基本概念.html",redirect:"/pages/a98e4b/"},{name:"v-a7225ce8",path:"/pages/ec4dab/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-a7225ce8").then(t)}},{path:"/pages/ec4dab/index.html",redirect:"/pages/ec4dab/"},{path:"/01.操作系统/03.第二章 进程的描述与控制/04.作业.html",redirect:"/pages/ec4dab/"},{name:"v-19dfd020",path:"/pages/d00b2a/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-19dfd020").then(t)}},{path:"/pages/d00b2a/index.html",redirect:"/pages/d00b2a/"},{path:"/01.操作系统/03.第二章 进程的描述与控制/05.进程控制.html",redirect:"/pages/d00b2a/"},{name:"v-8dbc2d50",path:"/pages/f0811a/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-8dbc2d50").then(t)}},{path:"/pages/f0811a/index.html",redirect:"/pages/f0811a/"},{path:"/01.操作系统/03.第二章 进程的描述与控制/06.进程的特征.html",redirect:"/pages/f0811a/"},{name:"v-c91c1caa",path:"/pages/8c5da1/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-c91c1caa").then(t)}},{path:"/pages/8c5da1/index.html",redirect:"/pages/8c5da1/"},{path:"/01.操作系统/03.第二章 进程的描述与控制/08.进程通信.html",redirect:"/pages/8c5da1/"},{name:"v-08eb3d76",path:"/pages/8676b4/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-08eb3d76").then(t)}},{path:"/pages/8676b4/index.html",redirect:"/pages/8676b4/"},{path:"/01.操作系统/03.第二章 进程的描述与控制/09.线程.html",redirect:"/pages/8676b4/"},{name:"v-21e297d6",path:"/pages/1da972/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-21e297d6").then(t)}},{path:"/pages/1da972/index.html",redirect:"/pages/1da972/"},{path:"/01.操作系统/03.第二章 进程的描述与控制/07.进程同步.html",redirect:"/pages/1da972/"},{name:"v-438f4343",path:"/pages/053628/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-438f4343").then(t)}},{path:"/pages/053628/index.html",redirect:"/pages/053628/"},{path:"/01.操作系统/04.第三章 处理机调度与死锁/03.队列调度模型.html",redirect:"/pages/053628/"},{name:"v-3decb41e",path:"/pages/9cf689/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-3decb41e").then(t)}},{path:"/pages/9cf689/index.html",redirect:"/pages/9cf689/"},{path:"/01.操作系统/04.第三章 处理机调度与死锁/02.处理机调度的层次.html",redirect:"/pages/9cf689/"},{name:"v-9583bd3c",path:"/pages/79d126/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-9583bd3c").then(t)}},{path:"/pages/79d126/index.html",redirect:"/pages/79d126/"},{path:"/01.操作系统/04.第三章 处理机调度与死锁/04.选择调度算法的原则.html",redirect:"/pages/79d126/"},{name:"v-60ef5aff",path:"/pages/e86493/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-60ef5aff").then(t)}},{path:"/pages/e86493/index.html",redirect:"/pages/e86493/"},{path:"/01.操作系统/04.第三章 处理机调度与死锁/05.调度算法.html",redirect:"/pages/e86493/"},{name:"v-8ecad5d0",path:"/pages/1253d7/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-8ecad5d0").then(t)}},{path:"/pages/1253d7/index.html",redirect:"/pages/1253d7/"},{path:"/01.操作系统/05.第四章 存储器管理/02.多级存储器结构.html",redirect:"/pages/1253d7/"},{name:"v-c81693ae",path:"/pages/ae65e4/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-c81693ae").then(t)}},{path:"/pages/ae65e4/index.html",redirect:"/pages/ae65e4/"},{path:"/01.操作系统/05.第四章 存储器管理/03.程序的装入与链接.html",redirect:"/pages/ae65e4/"},{name:"v-163d8114",path:"/pages/15347c/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-163d8114").then(t)}},{path:"/pages/15347c/index.html",redirect:"/pages/15347c/"},{path:"/01.操作系统/04.第三章 处理机调度与死锁/06.死锁.html",redirect:"/pages/15347c/"},{name:"v-a2241a92",path:"/pages/e66b46/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-a2241a92").then(t)}},{path:"/pages/e66b46/index.html",redirect:"/pages/e66b46/"},{path:"/01.操作系统/05.第四章 存储器管理/04.连续内存分配.html",redirect:"/pages/e66b46/"},{name:"v-95f67a58",path:"/pages/f6080a/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-95f67a58").then(t)}},{path:"/pages/f6080a/index.html",redirect:"/pages/f6080a/"},{path:"/01.操作系统/06.第五章 虚拟存储器/01.虚拟存储器概述.html",redirect:"/pages/f6080a/"},{name:"v-55469fce",path:"/pages/a8d561/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-55469fce").then(t)}},{path:"/pages/a8d561/index.html",redirect:"/pages/a8d561/"},{path:"/01.操作系统/05.第四章 存储器管理/05.非连续内存分配.html",redirect:"/pages/a8d561/"},{name:"v-10ced923",path:"/pages/9b0e23/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-10ced923").then(t)}},{path:"/pages/9b0e23/index.html",redirect:"/pages/9b0e23/"},{path:"/01.操作系统/06.第五章 虚拟存储器/02.请求分页存储管理方式.html",redirect:"/pages/9b0e23/"},{name:"v-ebc83474",path:"/pages/985167/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-ebc83474").then(t)}},{path:"/pages/985167/index.html",redirect:"/pages/985167/"},{path:"/01.操作系统/06.第五章 虚拟存储器/03.页面置换算法.html",redirect:"/pages/985167/"},{name:"v-64f88198",path:"/pages/3be910/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-64f88198").then(t)}},{path:"/pages/3be910/index.html",redirect:"/pages/3be910/"},{path:"/01.操作系统/06.第五章 虚拟存储器/04.内存分配策略和分配算法.html",redirect:"/pages/3be910/"},{name:"v-269b9ef7",path:"/pages/8b5fe6/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-269b9ef7").then(t)}},{path:"/pages/8b5fe6/index.html",redirect:"/pages/8b5fe6/"},{path:"/01.操作系统/06.第五章 虚拟存储器/05.抖动与工作集.html",redirect:"/pages/8b5fe6/"},{name:"v-71917082",path:"/pages/a80c85/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-71917082").then(t)}},{path:"/pages/a80c85/index.html",redirect:"/pages/a80c85/"},{path:"/01.操作系统/09.期末考试备考/01.考试题型.html",redirect:"/pages/a80c85/"},{name:"v-88e97502",path:"/asm-notes/shorthand/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-88e97502").then(t)}},{path:"/asm-notes/shorthand/index.html",redirect:"/asm-notes/shorthand/"},{path:"/02.汇编语言/01.汇编语言课程笔记/02.课堂速记.html",redirect:"/asm-notes/shorthand/"},{name:"v-cd163ea4",path:"/pages/ea8c9c/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-cd163ea4").then(t)}},{path:"/pages/ea8c9c/index.html",redirect:"/pages/ea8c9c/"},{path:"/02.汇编语言/02.《汇编语言》第三版阅读笔记/03.第二章 寄存器.html",redirect:"/pages/ea8c9c/"},{name:"v-bd5139f6",path:"/pages/e44e75/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-bd5139f6").then(t)}},{path:"/pages/e44e75/index.html",redirect:"/pages/e44e75/"},{path:"/02.汇编语言/02.《汇编语言》第三版阅读笔记/02.第一章 基础知识.html",redirect:"/pages/e44e75/"},{name:"v-64e50a5c",path:"/pages/252f3a/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-64e50a5c").then(t)}},{path:"/pages/252f3a/index.html",redirect:"/pages/252f3a/"},{path:"/02.汇编语言/02.《汇编语言》第三版阅读笔记/04.第三章 寄存器（内存访问）.html",redirect:"/pages/252f3a/"},{name:"v-424e13f0",path:"/pages/310d5a/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-424e13f0").then(t)}},{path:"/pages/310d5a/index.html",redirect:"/pages/310d5a/"},{path:"/02.汇编语言/02.《汇编语言》第三版阅读笔记/05.第四章 第一个程序.html",redirect:"/pages/310d5a/"},{name:"v-98f5d5a4",path:"/pages/a97f13/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-98f5d5a4").then(t)}},{path:"/pages/a97f13/index.html",redirect:"/pages/a97f13/"},{path:"/02.汇编语言/02.《汇编语言》第三版阅读笔记/06.第五章 [BX]和loop指令.html",redirect:"/pages/a97f13/"},{name:"v-e967490c",path:"/pages/f2f815/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-e967490c").then(t)}},{path:"/pages/f2f815/index.html",redirect:"/pages/f2f815/"},{path:"/02.汇编语言/02.《汇编语言》第三版阅读笔记/07.第六章 包含多个段的程序.html",redirect:"/pages/f2f815/"},{name:"v-2843adab",path:"/pages/a1378c/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-2843adab").then(t)}},{path:"/pages/a1378c/index.html",redirect:"/pages/a1378c/"},{path:"/02.汇编语言/02.《汇编语言》第三版阅读笔记/08.第七章 更灵活的定位内存地址的方法.html",redirect:"/pages/a1378c/"},{name:"v-47390ea0",path:"/pages/02c62b/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-47390ea0").then(t)}},{path:"/pages/02c62b/index.html",redirect:"/pages/02c62b/"},{path:"/02.汇编语言/02.《汇编语言》第三版阅读笔记/09.第八章 数据处理的两个基本问题.html",redirect:"/pages/02c62b/"},{name:"v-139c8f69",path:"/pages/83284e/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-139c8f69").then(t)}},{path:"/pages/83284e/index.html",redirect:"/pages/83284e/"},{path:"/02.汇编语言/02.《汇编语言》第三版阅读笔记/10.第九章 转移指令的原理.html",redirect:"/pages/83284e/"},{name:"v-8268a1fe",path:"/pages/a0c561/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-8268a1fe").then(t)}},{path:"/pages/a0c561/index.html",redirect:"/pages/a0c561/"},{path:"/02.汇编语言/02.《汇编语言》第三版阅读笔记/11.第十章 CALL和RET指令.html",redirect:"/pages/a0c561/"},{name:"v-31c3f598",path:"/pages/3d86c5/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-31c3f598").then(t)}},{path:"/pages/3d86c5/index.html",redirect:"/pages/3d86c5/"},{path:"/02.汇编语言/02.《汇编语言》第三版阅读笔记/12.第十一章 标志寄存器.html",redirect:"/pages/3d86c5/"},{name:"v-12cb66be",path:"/pages/27a5f0/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-12cb66be").then(t)}},{path:"/pages/27a5f0/index.html",redirect:"/pages/27a5f0/"},{path:"/02.汇编语言/02.《汇编语言》第三版阅读笔记/13.第十二章 内中断.html",redirect:"/pages/27a5f0/"},{name:"v-525139f4",path:"/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-525139f4").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-35d53af0",path:"/archives/",component:bl,beforeEnter:(n,e,t)=>{ps("Layout","v-35d53af0").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{path:"*",component:bl}],yl={title:"Pil0tXia 的书房",description:"我的学习笔记和技术分享",base:"/",headTags:[["link",{rel:"icon",href:"https://static.pil0txia.com/assets/favicon.ico"}],["meta",{name:"keywords",content:"pil0txia,it,docs,note,study"}],["meta",{name:"baidu-site-verification",content:"code-f37Lv9IIFX"}],["script",{async:!0,src:"https://www.googletagmanager.com/gtag/js?id=G-57XMHPB9DW"}],["script",{},["window.dataLayer = window.dataLayer || [];\nfunction gtag(){dataLayer.push(arguments);}\ngtag('js', new Date());\ngtag('config', 'G-57XMHPB9DW');"]]],pages:[{title:"单道批处理",frontmatter:{title:"单道批处理",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/d1af54/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02.%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/02.%E5%8D%95%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86.html",relativePath:"01.操作系统/02.第一章 操作系统引论/02.单道批处理.md",key:"v-dac9f86c",path:"/pages/d1af54/",headersStr:null,content:"# 单道批处理\n\n",normalizedContent:"# 单道批处理\n\n",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"分时操作系统",frontmatter:{title:"分时操作系统",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/ed294b/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02.%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/05.%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html",relativePath:"01.操作系统/02.第一章 操作系统引论/05.分时操作系统.md",key:"v-0547b318",path:"/pages/ed294b/",headersStr:null,content:"# 分时操作系统\n\n",normalizedContent:"# 分时操作系统\n\n",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"操作系统课程笔记",frontmatter:{title:"操作系统课程笔记",date:"2023-01-05T20:28:05.000Z",permalink:"/pages/5719ac/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/01.%E5%85%B3%E4%BA%8E%E6%9C%AC%E6%96%87%E6%A1%A3/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0.html",relativePath:"01.操作系统/01.关于本文档/01.操作系统课程笔记.md",key:"v-511a7ce0",path:"/pages/5719ac/",headersStr:null,content:"# 操作系统课程笔记\n\n本文档为 2022 年 9 月 8 日起，以 计算机操作系统（第四版） 汤小丹等著 西安电子科技大学出版社 为教材基础、以 南京信息工程大学赵晓平老师 课堂讲授为主体拓展的学习笔记。笔记内容参考了大量书本叙述，部分知识点与老师探讨得到验证。因包含个人理解，如有不当之处还望指出。\n\n> 本笔记首发于我的博客。\n\n> 因口罩原因，第一至四章于 12 月上旬讲完，第五章及后续于 2023 年 2 月补完。",normalizedContent:"# 操作系统课程笔记\n\n本文档为 2022 年 9 月 8 日起，以 计算机操作系统（第四版） 汤小丹等著 西安电子科技大学出版社 为教材基础、以 南京信息工程大学赵晓平老师 课堂讲授为主体拓展的学习笔记。笔记内容参考了大量书本叙述，部分知识点与老师探讨得到验证。因包含个人理解，如有不当之处还望指出。\n\n> 本笔记首发于我的博客。\n\n> 因口罩原因，第一至四章于 12 月上旬讲完，第五章及后续于 2023 年 2 月补完。",charsets:{cjk:!0}},{title:"实时操作系统",frontmatter:{title:"实时操作系统",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/f50a2e/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02.%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/06.%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html",relativePath:"01.操作系统/02.第一章 操作系统引论/06.实时操作系统.md",key:"v-1bc65186",path:"/pages/f50a2e/",headersStr:null,content:"# 实时操作系统\n\n\n\n",normalizedContent:"# 实时操作系统\n\n\n\n",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"多道批处理",frontmatter:{title:"多道批处理",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/4722dd/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02.%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/03.%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86.html",relativePath:"01.操作系统/02.第一章 操作系统引论/03.多道批处理.md",key:"v-b8115b44",path:"/pages/4722dd/",headersStr:null,content:"# 多道批处理\n\n多道批处理系统宏观上并行微观上串行的含义\n\n\n\n",normalizedContent:"# 多道批处理\n\n多道批处理系统宏观上并行微观上串行的含义\n\n\n\n",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"操作系统的四个基础特性",frontmatter:{title:"操作系统的四个基础特性",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/bc61d3/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02.%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/07.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7.html",relativePath:"01.操作系统/02.第一章 操作系统引论/07.操作系统的四个基础特性.md",key:"v-694da75f",path:"/pages/bc61d3/",headersStr:null,content:"# 操作系统的四个基础特性\n\n并发性，共享性，虚拟性，异步性\n\n异步性是指进程以不可预知的速度向前推进。内存中的每个进程何时执行，何时暂停，以怎样的速度向前推进，每道程序总共需要多少时间才能完成等，都是不可预知的。",normalizedContent:"# 操作系统的四个基础特性\n\n并发性，共享性，虚拟性，异步性\n\n异步性是指进程以不可预知的速度向前推进。内存中的每个进程何时执行，何时暂停，以怎样的速度向前推进，每道程序总共需要多少时间才能完成等，都是不可预知的。",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"并发与并行的区别",frontmatter:{title:"并发与并行的区别",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/d4063c/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02.%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/04.%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB.html",relativePath:"01.操作系统/02.第一章 操作系统引论/04.并发与并行的区别.md",key:"v-ee7d4de2",path:"/pages/d4063c/",headersStr:null,content:"# 并发与并行的区别\n\n一个宏观的时间段内，单 CPU 核心处理多个进程任务，称为并发；多 CPU 核心在同一时间处理多个进程任务，称为并行。",normalizedContent:"# 并发与并行的区别\n\n一个宏观的时间段内，单 cpu 核心处理多个进程任务，称为并发；多 cpu 核心在同一时间处理多个进程任务，称为并行。",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"作业1",frontmatter:{title:"作业1",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/ebecb5/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02.%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/09.%E4%BD%9C%E4%B8%9A1.html",relativePath:"01.操作系统/02.第一章 操作系统引论/09.作业1.md",key:"v-c926f994",path:"/pages/ebecb5/",headersStr:null,content:"# 作业 1\n\n\n\nFocus on FE learning 操作系统学习笔记 - 2：体系结构设计和运行机制\n\n《王道考研 操作系统》学习笔记汇总",normalizedContent:"# 作业 1\n\n\n\nfocus on fe learning 操作系统学习笔记 - 2：体系结构设计和运行机制\n\n《王道考研 操作系统》学习笔记汇总",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"现代OS的基本单位",frontmatter:{title:"现代OS的基本单位",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/4d01a9/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02.%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/08.%E7%8E%B0%E4%BB%A3OS%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D.html",relativePath:"01.操作系统/02.第一章 操作系统引论/08.现代OS的基本单位.md",key:"v-7d4e16c2",path:"/pages/4d01a9/",headersStr:null,content:"# 现代 OS 的基本单位\n\n内核、进程、线程、类程、管程",normalizedContent:"# 现代 os 的基本单位\n\n内核、进程、线程、类程、管程",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"内核",frontmatter:{title:"内核",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/5203e5/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02.%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/10.%E5%86%85%E6%A0%B8.html",relativePath:"01.操作系统/02.第一章 操作系统引论/10.内核.md",key:"v-1df475c6",path:"/pages/5203e5/",headersStr:null,content:"# 内核\n\n\n\n微内核中，应用程序与 OS 内核的通信：系统调用；非内核功能（用户空间的 OS）和 OS 内核的通信：消息传递；非内核功能之间的通信：直接调用。\n\n用户态切换到内核态的 3 种方式：系统调用、异常、外围设备的中断\n\n内核态切换到用户态的方式：特权指令，设置程序状态字为 PSW",normalizedContent:"# 内核\n\n\n\n微内核中，应用程序与 os 内核的通信：系统调用；非内核功能（用户空间的 os）和 os 内核的通信：消息传递；非内核功能之间的通信：直接调用。\n\n用户态切换到内核态的 3 种方式：系统调用、异常、外围设备的中断\n\n内核态切换到用户态的方式：特权指令，设置程序状态字为 psw",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"中断和异常",frontmatter:{title:"中断和异常",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/ee322f/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02.%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/11.%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8.html",relativePath:"01.操作系统/02.第一章 操作系统引论/11.中断和异常.md",key:"v-7196114d",path:"/pages/ee322f/",headersStr:null,content:'# 中断和异常\n\n中断的类型：内中断（也称为 “异常”、例外）；外中断（也称为 “中断 "）\n\n内中断的案例：非法指令；应用程序请求操作系统时发出 “陷入指令”，该指令会引发一个内部中断指令，意味着应用程序主动将 CPU 控制权还给 OS。“系统调用” 就是通过陷入指令完成。\n\n中断处理程序一定是内核程序，需要运行在 “内核态”。',normalizedContent:'# 中断和异常\n\n中断的类型：内中断（也称为 “异常”、例外）；外中断（也称为 “中断 "）\n\n内中断的案例：非法指令；应用程序请求操作系统时发出 “陷入指令”，该指令会引发一个内部中断指令，意味着应用程序主动将 cpu 控制权还给 os。“系统调用” 就是通过陷入指令完成。\n\n中断处理程序一定是内核程序，需要运行在 “内核态”。',charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"冷启动和热启动",frontmatter:{title:"冷启动和热启动",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/1fd856/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02.%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/13.%E5%86%B7%E5%90%AF%E5%8A%A8%E5%92%8C%E7%83%AD%E5%90%AF%E5%8A%A8.html",relativePath:"01.操作系统/02.第一章 操作系统引论/13.冷启动和热启动.md",key:"v-32484570",path:"/pages/1fd856/",headersStr:null,content:"# 冷启动和热启动\n\n\n\n冷启动\n\n（1）开机执行 BIOS 引导程序，标识和配置所有的即插即用设备，并配置 DMA 通道\n\n（2）完成加电自检，测试内存，端口，键盘，视频适配器，磁盘驱动器等基本设备，及 CD-ROM 驱动器。\n\n（3）对引导驱动器引导分区定位：在 CMOS 中，可以自行设置引导顺序，一般顺序是软盘，磁盘，光驱；\n\n（4）加载主引导记录以及引导驱动器的分区表，执行主引导记录 MBR。\n\n（5）装入操作系统\n\n热启动\n\n（1）BOOT 被自动执行，指引 CPU 把操作系统从大容量存储器中传送到主存储器的易失区；\n\n（2）BOOT 要求 CPU 执行一条转移指令，转到这个存储区域；此时，操作系统接管并且开始控制整个机器的活动。",normalizedContent:"# 冷启动和热启动\n\n\n\n冷启动\n\n（1）开机执行 bios 引导程序，标识和配置所有的即插即用设备，并配置 dma 通道\n\n（2）完成加电自检，测试内存，端口，键盘，视频适配器，磁盘驱动器等基本设备，及 cd-rom 驱动器。\n\n（3）对引导驱动器引导分区定位：在 cmos 中，可以自行设置引导顺序，一般顺序是软盘，磁盘，光驱；\n\n（4）加载主引导记录以及引导驱动器的分区表，执行主引导记录 mbr。\n\n（5）装入操作系统\n\n热启动\n\n（1）boot 被自动执行，指引 cpu 把操作系统从大容量存储器中传送到主存储器的易失区；\n\n（2）boot 要求 cpu 执行一条转移指令，转到这个存储区域；此时，操作系统接管并且开始控制整个机器的活动。",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"补充资料",frontmatter:{title:"补充资料",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/e900d8/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02.%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/14.%E8%A1%A5%E5%85%85%E8%B5%84%E6%96%99.html",relativePath:"01.操作系统/02.第一章 操作系统引论/14.补充资料.md",key:"v-6d5faa60",path:"/pages/e900d8/",headersStr:null,content:"# 补充资料\n\n为什么说直到出现中断和通道技术后，多道程序概念才变为有用的？\n\n采用多道程序设计减少了 CPU 时间的浪费，增加了系统吞吐量，提高了系统的效率。. 多道程序并发执行是指有的程序正在 CPU 上执行，而另一些程序正在 I/O 设备上进行传输，即通过 CPU 操作与外设传输在时间上的重叠减少 CPU 时间的浪费，并提高了系统的效率。实现 CPU 操作与外设传输在时间上的重叠必须有中断和通道技术支持，其原因如下：\n\n（1）通道是一种控制一台或多台外部设备的硬件机构，它一旦被启动就独立与 CPU 运行，因而做到了输入输出操作与 CPU 并行工作。但早期 CPU 与通道的联络方法是由 CPU 向通道发出询问指令来了解通道工作是否完成。若未完成，则主机就循环询问直到通道工作结束为止。因此，这种询问方式是无法真正做到 CPU 与 I/O 设备并行工作的。\n\n（2）在硬件上引入了中断技术。所谓中断，就是在输入输出结束时，或硬件发生某种故障时，由相应硬件（即中断机构）向 CPU 发出信号。这时 CPU 立即停下手头的工作而转向处理中断请求，道处理完中断后再继续原来手头的工作。因此，通道技术和中断技术结合起来就可实现 CPU 与 I/O 设备并行工作，即 CPU 启动通道传输数据后便去执行其他程序的计算工作，而通道则进行输入输出操作；当通道工作结束时，再通过中断机构向 CPU 发出中断请求，CPU 则暂停正在执行的操作，对出现的中断进行处理，处理完后则继续原来的工作。这样，就真正做到了 CPU 与 I/O 设备并行工作。此时，多道程序的概念才变为现实。",normalizedContent:"# 补充资料\n\n为什么说直到出现中断和通道技术后，多道程序概念才变为有用的？\n\n采用多道程序设计减少了 cpu 时间的浪费，增加了系统吞吐量，提高了系统的效率。. 多道程序并发执行是指有的程序正在 cpu 上执行，而另一些程序正在 i/o 设备上进行传输，即通过 cpu 操作与外设传输在时间上的重叠减少 cpu 时间的浪费，并提高了系统的效率。实现 cpu 操作与外设传输在时间上的重叠必须有中断和通道技术支持，其原因如下：\n\n（1）通道是一种控制一台或多台外部设备的硬件机构，它一旦被启动就独立与 cpu 运行，因而做到了输入输出操作与 cpu 并行工作。但早期 cpu 与通道的联络方法是由 cpu 向通道发出询问指令来了解通道工作是否完成。若未完成，则主机就循环询问直到通道工作结束为止。因此，这种询问方式是无法真正做到 cpu 与 i/o 设备并行工作的。\n\n（2）在硬件上引入了中断技术。所谓中断，就是在输入输出结束时，或硬件发生某种故障时，由相应硬件（即中断机构）向 cpu 发出信号。这时 cpu 立即停下手头的工作而转向处理中断请求，道处理完中断后再继续原来手头的工作。因此，通道技术和中断技术结合起来就可实现 cpu 与 i/o 设备并行工作，即 cpu 启动通道传输数据后便去执行其他程序的计算工作，而通道则进行输入输出操作；当通道工作结束时，再通过中断机构向 cpu 发出中断请求，cpu 则暂停正在执行的操作，对出现的中断进行处理，处理完后则继续原来的工作。这样，就真正做到了 cpu 与 i/o 设备并行工作。此时，多道程序的概念才变为现实。",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"系统调用",frontmatter:{title:"系统调用",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/1501a6/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02.%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/12.%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.html",relativePath:"01.操作系统/02.第一章 操作系统引论/12.系统调用.md",key:"v-20343e8e",path:"/pages/1501a6/",headers:[{level:2,title:"系统调用的方式",slug:"系统调用的方式",normalizedTitle:"系统调用的方式",charIndex:66},{level:2,title:"系统调用与库函数的区别",slug:"系统调用与库函数的区别",normalizedTitle:"系统调用与库函数的区别",charIndex:225}],headersStr:"系统调用的方式 系统调用与库函数的区别",content:"# 系统调用\n\n系统调用是应用程序获得 OS 服务的唯一途径。内核的主体是系统调用的集合，内核可以看成是特殊的公共子程序。\n\n\n# 系统调用的方式\n\n用户 -> 应用程序 -> 系统调用（系统调用组成了程序接口 API，每一个系统调用都是一个完成特定功能的子程序）->OS 内核（裸机）\n\n用户 -> 图形窗口 ->OS 内核（裸机）\n\n用户 -> 操作命令 -> 系统程序（操作接口由一组控制命令和作业控制语句组成）->OS 内核（裸机）\n\n\n# 系统调用与库函数的区别\n\n应用程序不可以直接调用系统调用，是通过库函数调用系统调用的。\n\n",normalizedContent:"# 系统调用\n\n系统调用是应用程序获得 os 服务的唯一途径。内核的主体是系统调用的集合，内核可以看成是特殊的公共子程序。\n\n\n# 系统调用的方式\n\n用户 -> 应用程序 -> 系统调用（系统调用组成了程序接口 api，每一个系统调用都是一个完成特定功能的子程序）->os 内核（裸机）\n\n用户 -> 图形窗口 ->os 内核（裸机）\n\n用户 -> 操作命令 -> 系统程序（操作接口由一组控制命令和作业控制语句组成）->os 内核（裸机）\n\n\n# 系统调用与库函数的区别\n\n应用程序不可以直接调用系统调用，是通过库函数调用系统调用的。\n\n",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"附言",frontmatter:{title:"附言",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/82c444/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02.%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/16.%E9%99%84%E8%A8%80.html",relativePath:"01.操作系统/02.第一章 操作系统引论/16.附言.md",key:"v-a0bcf658",path:"/pages/82c444/",headersStr:null,content:"# 附言\n\n最近我的操作系统老师和软件工程老师都在上课时讲鸿蒙 OS 有多么多么划时代，可事实上并非如此。我一问才知道，是华为有人找他们合作，让他们上课时多放入一点鸿蒙的知识。我理解鸿蒙是一个较为优秀的国产定制系统，但是把它等同于目前所有系统、实时操作系统的下一代系统，实在太误人子弟。\n\n19 年鸿蒙说是要完全自主开发内核，22 年现在却在用 AOSP Andriod Open Source Project ；“分布式” 有两个，真正意义上的分布式可以同步两台设备上同一版本软件的操作，目前还停留在 SDK 阶段，大肆宣传的那个分布式不过是投屏罢了。\n\n要说怪谁，只能怪一开始饼画太大，缺口已经补不上了。其实按照开源协议使用开源代码不丢人，丢人的是欲盖弥彰啊。",normalizedContent:"# 附言\n\n最近我的操作系统老师和软件工程老师都在上课时讲鸿蒙 os 有多么多么划时代，可事实上并非如此。我一问才知道，是华为有人找他们合作，让他们上课时多放入一点鸿蒙的知识。我理解鸿蒙是一个较为优秀的国产定制系统，但是把它等同于目前所有系统、实时操作系统的下一代系统，实在太误人子弟。\n\n19 年鸿蒙说是要完全自主开发内核，22 年现在却在用 aosp andriod open source project ；“分布式” 有两个，真正意义上的分布式可以同步两台设备上同一版本软件的操作，目前还停留在 sdk 阶段，大肆宣传的那个分布式不过是投屏罢了。\n\n要说怪谁，只能怪一开始饼画太大，缺口已经补不上了。其实按照开源协议使用开源代码不丢人，丢人的是欲盖弥彰啊。",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"作业2",frontmatter:{title:"作业2",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/3f251a/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02.%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/15.%E4%BD%9C%E4%B8%9A2.html",relativePath:"01.操作系统/02.第一章 操作系统引论/15.作业2.md",key:"v-4be611fe",path:"/pages/3f251a/",headersStr:null,content:"# 作业 2\n\n> 书面版进行了概括\n\n 1. 设计现代 OS 的主要目标是什么？\n    \n    方便性，有效性，可扩充性，开放性\n\n 2. 试从交互性、及时性以及可靠性方面将分时系统与实时系统进行比较。\n    \n    （1）及时性：实时信息处理系统对实时性的要求与分时系统类似，都是以人所能接受的等待时间来确定；而实时控制系统的及时性，是以控制对象所要求的开始截止时间或完成截止时间来确定的，一般为秒级到毫秒级，甚至有的要低于 100 微秒。\n    \n    （2）交互性：实时信息处理系统具有交互性，但实时终端设备只是作为执行装置或咨询装置，人与系统的交互仅限于访问系统中某些特定的专用服务程序。分时系统的用户可以与系统进行人机交互，包括在终端上可以直接调试自己的程序，系统能向终端用户提供数据和资源共享等服务。\n    \n    （3）可靠性：分时系统也要求系统可靠，但相比之下，实时系统则要求系统具有高度的可靠性。因为任何差错都可能带来巨大的经济损失，甚至是灾难性后果，所以在实时系统中，往往都采取了多级容错措施保障系统的安全性及数据的安全性。\n\n 3. 在多道程序技术的 OS 环境下的资源共享与一般情况下的资源共享有何不同？对独占资源应采取何种共享方式？\n    \n    （1）OS 环境下与一般情况下的资源共享间的不同点\n    \n    ①一般情况下的共享\n    \n    一般情况下的共享只是说明某种资源能被大家使用，对于这样的资源共享方式，只要通过适当的安排，用户之间并不会产生对资源的竞争，因此资源管理是比较简单的。\n    \n    ②OS 环境下的共享\n    \n    OS 环境下的资源共享或称为资源复用，是指系统中的资源可供内存中多个并发执行的进程共同使用。这里在宏观上既限定了时间（进程在内存期间），也限定了地点（内存）。对于这种资源共享方式，其管理就要复杂得多，因为系统中的资源少于多道程序需求的总和，会形成它们对共享资源的争夺。所以，系统必须对资源共享进行妥善管理。\n    \n    （2）独占资源应采取的共享方式\n    \n    对独占资源应采用互斥共享方式，该共享方式仅当占有该资源的进程访问并释放资源后，才允许另一进程对该资源进行访问。\n\n 4. 什么是时分复用技术？举例说明它能提高资源利用率的根本原因是什么。\n    \n    （1）时分复用技术的定义 时分复用技术是将不同的信号相互交织在不同的时间段内，沿着同一个信道传输；在接收端再用某种方法，将各个时间段内的信号提取出来还原成原始信号的通信技术。这种技术可以在同一个信道上传输多路信号。 （2）时分复用技术能提高资源利用率的根本原因 时分复用技术能提高资源利用率的根本原因在于，它利用某设备为一用户服务的空闲时间，又转去为其他用户服务使设备得到最充分的利用。\n\n 5. 何谓微内核技术？在基于微内核结构的 OS 中，应用了哪些新技术？在微内核中通常提供了哪些功能？\n    \n    （1）把操作系统中更多的成分和功能放到更高的层次 (即用户模式) 中去运行，而留下一个尽量小的内核，用它来完成操作系统最基本的核心功能，称这种技术为微内核技术。\n    \n    （2）面向对象的程序设计技术。\n    \n    （3）在微内核中通常提供了进程 (线程) 管理、低级存储器管理、中断和陷入处理等功能。",normalizedContent:"# 作业 2\n\n> 书面版进行了概括\n\n 1. 设计现代 os 的主要目标是什么？\n    \n    方便性，有效性，可扩充性，开放性\n\n 2. 试从交互性、及时性以及可靠性方面将分时系统与实时系统进行比较。\n    \n    （1）及时性：实时信息处理系统对实时性的要求与分时系统类似，都是以人所能接受的等待时间来确定；而实时控制系统的及时性，是以控制对象所要求的开始截止时间或完成截止时间来确定的，一般为秒级到毫秒级，甚至有的要低于 100 微秒。\n    \n    （2）交互性：实时信息处理系统具有交互性，但实时终端设备只是作为执行装置或咨询装置，人与系统的交互仅限于访问系统中某些特定的专用服务程序。分时系统的用户可以与系统进行人机交互，包括在终端上可以直接调试自己的程序，系统能向终端用户提供数据和资源共享等服务。\n    \n    （3）可靠性：分时系统也要求系统可靠，但相比之下，实时系统则要求系统具有高度的可靠性。因为任何差错都可能带来巨大的经济损失，甚至是灾难性后果，所以在实时系统中，往往都采取了多级容错措施保障系统的安全性及数据的安全性。\n\n 3. 在多道程序技术的 os 环境下的资源共享与一般情况下的资源共享有何不同？对独占资源应采取何种共享方式？\n    \n    （1）os 环境下与一般情况下的资源共享间的不同点\n    \n    ①一般情况下的共享\n    \n    一般情况下的共享只是说明某种资源能被大家使用，对于这样的资源共享方式，只要通过适当的安排，用户之间并不会产生对资源的竞争，因此资源管理是比较简单的。\n    \n    ②os 环境下的共享\n    \n    os 环境下的资源共享或称为资源复用，是指系统中的资源可供内存中多个并发执行的进程共同使用。这里在宏观上既限定了时间（进程在内存期间），也限定了地点（内存）。对于这种资源共享方式，其管理就要复杂得多，因为系统中的资源少于多道程序需求的总和，会形成它们对共享资源的争夺。所以，系统必须对资源共享进行妥善管理。\n    \n    （2）独占资源应采取的共享方式\n    \n    对独占资源应采用互斥共享方式，该共享方式仅当占有该资源的进程访问并释放资源后，才允许另一进程对该资源进行访问。\n\n 4. 什么是时分复用技术？举例说明它能提高资源利用率的根本原因是什么。\n    \n    （1）时分复用技术的定义 时分复用技术是将不同的信号相互交织在不同的时间段内，沿着同一个信道传输；在接收端再用某种方法，将各个时间段内的信号提取出来还原成原始信号的通信技术。这种技术可以在同一个信道上传输多路信号。 （2）时分复用技术能提高资源利用率的根本原因 时分复用技术能提高资源利用率的根本原因在于，它利用某设备为一用户服务的空闲时间，又转去为其他用户服务使设备得到最充分的利用。\n\n 5. 何谓微内核技术？在基于微内核结构的 os 中，应用了哪些新技术？在微内核中通常提供了哪些功能？\n    \n    （1）把操作系统中更多的成分和功能放到更高的层次 (即用户模式) 中去运行，而留下一个尽量小的内核，用它来完成操作系统最基本的核心功能，称这种技术为微内核技术。\n    \n    （2）面向对象的程序设计技术。\n    \n    （3）在微内核中通常提供了进程 (线程) 管理、低级存储器管理、中断和陷入处理等功能。",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"程序的基本概念",frontmatter:{title:"程序的基本概念",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/1f0d42/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/03.%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/02.%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html",relativePath:"01.操作系统/03.第二章 进程的描述与控制/02.程序的基本概念.md",key:"v-6dc754d2",path:"/pages/1f0d42/",headers:[{level:2,title:"为什么程序不能调度？",slug:"为什么程序不能调度",normalizedTitle:"为什么程序不能调度？",charIndex:28},{level:2,title:"判断程序是否可以并发",slug:"判断程序是否可以并发",normalizedTitle:"判断程序是否可以并发",charIndex:136}],headersStr:"为什么程序不能调度？ 判断程序是否可以并发",content:"# 程序的基本概念\n\n\n\n> 可在现性可再现性\n\n\n# 为什么程序不能调度？\n\n程序具有独立性，结果再现。如果程序执行过程中，出现结果无法再现的情况，则程序肯定有问题。如果要让程序被调度，必须满足 Berstein 条件（任意两条读写的交集不能为空，很难实现）。\n\n\n# 判断程序是否可以并发\n\n\n\n\n\n（1）程序顺序执行，因为某一时段独占全机，所以结果可再现。\n\n（2）程序并发执行，若不满足 Bernstein 条件，则结果不再现。\n\n总之，程序不可以并发执行。",normalizedContent:"# 程序的基本概念\n\n\n\n> 可在现性可再现性\n\n\n# 为什么程序不能调度？\n\n程序具有独立性，结果再现。如果程序执行过程中，出现结果无法再现的情况，则程序肯定有问题。如果要让程序被调度，必须满足 berstein 条件（任意两条读写的交集不能为空，很难实现）。\n\n\n# 判断程序是否可以并发\n\n\n\n\n\n（1）程序顺序执行，因为某一时段独占全机，所以结果可再现。\n\n（2）程序并发执行，若不满足 bernstein 条件，则结果不再现。\n\n总之，程序不可以并发执行。",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"进程的基本概念",frontmatter:{title:"进程的基本概念",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/a98e4b/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/03.%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/03.%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html",relativePath:"01.操作系统/03.第二章 进程的描述与控制/03.进程的基本概念.md",key:"v-072dd8ef",path:"/pages/a98e4b/",headers:[{level:2,title:"进程控制块PCB",slug:"进程控制块pcb",normalizedTitle:"进程控制块 pcb",charIndex:98},{level:2,title:"进程控制块PCB的组织方式",slug:"进程控制块pcb的组织方式",normalizedTitle:"进程控制块 pcb 的组织方式",charIndex:479}],headersStr:"进程控制块PCB 进程控制块PCB的组织方式",content:"# 进程的基本概念\n\n进程是可并发执行的程序在某个数据集合上的一次计算活动，也是操作系统进行资源分配和保护的基本单位。进程是一个既能用来共享资源，又能描述程序并发执行过程的一个基本单位。\n\n\n# 进程控制块 PCB\n\n\n\n正是因为有了 PCB，可以记录任意时刻下进程的状态。所谓的调度就是进程在运行中被中断，但 PCB 可以记录此时进程的状态。所以进程是 “动态” 的。\n\n> 简答题 “程序为什么不能被调度 + 进程为什么可以并发执行” 是捆绑在一起的。\n\n父 / 子标识指向父 / 子进程的 PID\n\n * 进程调度信息\n\n进程的状态：三态、五态、七态\n\n进程的优先级：一个整数\n\n进程调度需要的信息：如等待 CPU 的时间、执行 CPU 的时间等等，是调度的一个参考。\n\n阻塞原因：执行 -> 阻塞状态转换发生的事件\n\n * 进程的控制信息\n\n程序和数据在内存、外存的地址\n\n进程同步和通信机制\n\n资源清单：列出除了 CPU 以外进程所需资源和已经拿到的资源。\n\n链接指针：指出本进程的 pcb 在 pcb 队列中下一个进程的 pcb 首地址\n\n\n# 进程控制块 PCB 的组织方式\n\n\n\n",normalizedContent:"# 进程的基本概念\n\n进程是可并发执行的程序在某个数据集合上的一次计算活动，也是操作系统进行资源分配和保护的基本单位。进程是一个既能用来共享资源，又能描述程序并发执行过程的一个基本单位。\n\n\n# 进程控制块 pcb\n\n\n\n正是因为有了 pcb，可以记录任意时刻下进程的状态。所谓的调度就是进程在运行中被中断，但 pcb 可以记录此时进程的状态。所以进程是 “动态” 的。\n\n> 简答题 “程序为什么不能被调度 + 进程为什么可以并发执行” 是捆绑在一起的。\n\n父 / 子标识指向父 / 子进程的 pid\n\n * 进程调度信息\n\n进程的状态：三态、五态、七态\n\n进程的优先级：一个整数\n\n进程调度需要的信息：如等待 cpu 的时间、执行 cpu 的时间等等，是调度的一个参考。\n\n阻塞原因：执行 -> 阻塞状态转换发生的事件\n\n * 进程的控制信息\n\n程序和数据在内存、外存的地址\n\n进程同步和通信机制\n\n资源清单：列出除了 cpu 以外进程所需资源和已经拿到的资源。\n\n链接指针：指出本进程的 pcb 在 pcb 队列中下一个进程的 pcb 首地址\n\n\n# 进程控制块 pcb 的组织方式\n\n\n\n",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"作业",frontmatter:{title:"作业",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/ec4dab/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/03.%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/04.%E4%BD%9C%E4%B8%9A.html",relativePath:"01.操作系统/03.第二章 进程的描述与控制/04.作业.md",key:"v-a7225ce8",path:"/pages/ec4dab/",headersStr:null,content:"# 作业\n\n> 为什么程序不能被调度？为什么要引入进程？\n\n为什么程序不能调度？\n\n为什么程序不能并发？\n\n为什么要引入进程？",normalizedContent:"# 作业\n\n> 为什么程序不能被调度？为什么要引入进程？\n\n为什么程序不能调度？\n\n为什么程序不能并发？\n\n为什么要引入进程？",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"进程控制",frontmatter:{title:"进程控制",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/d00b2a/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/03.%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/05.%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6.html",relativePath:"01.操作系统/03.第二章 进程的描述与控制/05.进程控制.md",key:"v-19dfd020",path:"/pages/d00b2a/",headers:[{level:2,title:"进程的状态转换",slug:"进程的状态转换",normalizedTitle:"进程的状态转换",charIndex:287},{level:3,title:"三态",slug:"三态",normalizedTitle:"三态",charIndex:299},{level:3,title:"五态",slug:"五态",normalizedTitle:"五态",charIndex:355},{level:3,title:"七态（重要，在后面的章节会有所拓展）",slug:"七态-重要-在后面的章节会有所拓展",normalizedTitle:"七态（重要，在后面的章节会有所拓展）",charIndex:382},{level:4,title:"静止阻塞/就绪队列的理解",slug:"静止阻塞-就绪队列的理解",normalizedTitle:"静止阻塞 / 就绪队列的理解",charIndex:406},{level:4,title:"挂起的原因",slug:"挂起的原因",normalizedTitle:"挂起的原因",charIndex:638},{level:4,title:"挂起的特征",slug:"挂起的特征",normalizedTitle:"挂起的特征",charIndex:678},{level:4,title:"状态转换的汇总",slug:"状态转换的汇总",normalizedTitle:"状态转换的汇总",charIndex:813},{level:2,title:"进程的创建（创建原语）",slug:"进程的创建-创建原语",normalizedTitle:"进程的创建（创建原语）",charIndex:1427},{level:2,title:"进程的终止（撤销原语）",slug:"进程的终止-撤销原语",normalizedTitle:"进程的终止（撤销原语）",charIndex:1574},{level:2,title:"进程的阻塞（阻塞原语block）",slug:"进程的阻塞-阻塞原语block",normalizedTitle:"进程的阻塞（阻塞原语 block）",charIndex:1816},{level:2,title:"进程的唤醒（唤醒原语wake up）",slug:"进程的唤醒-唤醒原语wake-up",normalizedTitle:"进程的唤醒（唤醒原语 wake up）",charIndex:2096},{level:2,title:"进程的切换（切换原语）",slug:"进程的切换-切换原语",normalizedTitle:"进程的切换（切换原语）",charIndex:2302},{level:2,title:"进程的挂起（挂起原语suspend和激活原语active）",slug:"进程的挂起-挂起原语suspend和激活原语active",normalizedTitle:"进程的挂起（挂起原语 suspend 和激活原语 active）",charIndex:2623}],headersStr:"进程的状态转换 三态 五态 七态（重要，在后面的章节会有所拓展） 静止阻塞/就绪队列的理解 挂起的原因 挂起的特征 状态转换的汇总 进程的创建（创建原语） 进程的终止（撤销原语） 进程的阻塞（阻塞原语block） 进程的唤醒（唤醒原语wake up） 进程的切换（切换原语） 进程的挂起（挂起原语suspend和激活原语active）",content:"# 进程控制\n\n进程控制由 “原语” 实现。原语具有 “原子性”，要么不被执行，一旦被执行，不可以被中断。\n\n在关中断指令下，即使有中断信号发射过来，也不会调用中断处理程序去处理中断，这就保证了原语操作不会被打断。而在开中断指令下，才会去处理中断。\n\n原语的基本操作包括：\n\n * 更新 PCB 中的信息（修改进程状态标志、保存当前运行环境到 PCB、从 PCB 中恢复运行环境）\n * 将 PCB 插入到合适的队列\n * 分配 / 回收资源\n\n创建原语和撤销原语配对，阻塞原语和唤醒原语配对。\n\n\n\n\n\n进程的执行是 “异步” 的，进程的控制是 “原子性” 的。\n\n\n# 进程的状态转换\n\n\n# 三态\n\n\n\n阻塞态的进程不会立即转为执行态。阻塞态和就绪态的进程在内存中，执行态的进程在 CPU 中。\n\n\n# 五态\n\n\n\n\n\n创建进程的过程在内存里完成。\n\n\n# 七态（重要，在后面的章节会有所拓展）\n\n\n\n# 静止阻塞 / 就绪队列的理解\n\n当我们把作业从外存拿到内存时，这个过程叫做高级调度。\n\n进程 PCB 被创建后，PCB 存在内存中，创建的过程在内存中实现；进程创建完成后，如果所需的资源除了内存之外都满足，则进程被对换到静止就绪队列，不参与调度，此时进程创建工作完成。\n\n如果静止阻塞队列中的进程，内存资源得到满足，但是阻塞的原因仍未解除，则从静止阻塞队列进入活动阻塞队列。\n\n如果静止就绪队列中的进程，内存资源得到满足，则从静止就绪队列进入活动就绪队列。\n\n# 挂起的原因\n\n负荷调节的需要、终端用户的请求、父进程请求、操作系统的需要\n\n# 挂起的特征\n\n * 该进程不能立即被执行\n * 挂起进程可能会等待事件，但所等待事件是独立于挂起条件的，事件结束并不能导致进程具备执行条件\n * 进程进入挂起状态是由于操作系统父进程或进程本身阻止它的运行\n * 结束进程挂起状态的命令只能通过操作系统或父进程发出\n\n# 状态转换的汇总\n\n状态              解释\n活动就绪态 → 静止就绪态   操作系统根据当前资源状况和性能要求，可能会把活动就绪态对换出去，成为静止就绪态。处于静止就绪态的进程不再被调度执行；\n静止就绪态 → 活动就绪态   内存中没有进程处于活动就绪态，或者处于静止就绪态的进程具有更高的优先级，那么静止就绪态就会被对换回来，此时才可能被调度执行\n活动阻塞态→ 静止阻塞态    操作系统根据当前资源状况和性能要求，可能会把活动阻塞态对换出去，成为静止阻塞态。\n静止阻塞态→ 静止就绪态    常见的情况是，引起进程等待的事件发生之后，相应的静止阻塞态进程将转换为静止就绪态\n静止阻塞态→ 活动阻塞态    但有时候，如果静止阻塞态进程的优先级高于静止就绪队列中的任何进程、并且系统有把握它等待的事件即将完成，那么就会激活为活动阻塞态\n运行态→ 静止就绪态      优先级较高的静止阻塞态在等待的事件完成后，可能会抢占 CPU，若此时资源不够，则可能导致正在运行的进程挂起为静止就绪态\n创建态→ 静止就绪态      操作系统根据当前资源状况和性能要求，可能会在进程创建完就把它对换到外存\n\n进程一旦被挂起，就意味着它被对换到了外存中，此时该进程无法再被 CPU 直接调度，除非它被对换回内存中，回到活动就绪态。比如静止就绪态、静止阻塞态，最后要得到 CPU 的调度，都必须经历回归到活动就绪态的过程。\n\n\n# 进程的创建（创建原语）\n\n\n\n 1. 申请空白 PCB\n 2. 为新进程分配其运行所需的资源\n 3. 初始化 PCB\n 4. 如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。如果是三态或五态，进程转入就绪态；如果是七态，储存在内存中的为活动就绪态，储存在外存中的为静止就绪态。\n\n\n# 进程的终止（撤销原语）\n\n引起进程终止的事件包括正常结束、异常结束和外界干预。\n\n终止进程的过程包括：从 PCB 集合中找到终止进程的 PCB，如果进程正在运行，则立即将它的 CPU 使用权移交给其它进程。接着终止它的所有子进程，将该进程的资源还给父进程或者操作系统，最后再删除 PCB。\n\n\n\n 1. 进入终止态的进程不能再执行\n 2. OS 中保留其记录（状态码 + 计时统计数据），供其他进程收集\n 3. 一旦其他进程完成了对终止状态进程的信息提取，OS 将删除该进程\n\n\n# 进程的阻塞（阻塞原语 block）\n\n阻塞进程的过程包括：找到要阻塞的进程的 PCB，保存当前运行环境到 PCB（方便后续恢复），修改 PCB 状态信息。接着暂停进程的运行，将 PCB 插入相应事件的阻塞队列（即改变它的链接地址）。\n\n引起进程阻塞的事件一般是：\n\n * 请求系统分配共享资源失败（系统已无足够的资源）\n * 等待某种操作的完成。如请求系统某些服务（比如打印服务）和启动某种操作（比如 I/O 操作）\n * 新数据尚未到达\n * 等待新任务的到达\n\n> 进程从运行态切换到阻塞态是一种主动行为，这个主动体现在是进程自己调用了阻塞原语。\n\n\n# 进程的唤醒（唤醒原语 wake up）\n\n唤醒进程的过程包括：在事件阻塞队列中找到 PCB 并将进程移出队列，修改 PCB 的状态信息，再将 PCB 插入到就绪队列。\n\n一般在等待的事件发生时，进程就会被唤醒。\n\n> 阻塞原语和唤醒原语是一对作用刚好相反的原语，必须成对使用。进程从阻塞态切换到运行态，是一个被动的过程，这个被动体现在并不是进程自己调用了唤醒原语，而是 “合作” 或相关进程进行了调用。\n\n\n# 进程的切换（切换原语）\n\n前面的原语主要都是操作一个进程，而切换原语同时操作到了两个进程。\n\n切换原语负责让当前运行的进程从 A 切换为 B，具体包括：\n\n * 一方面，将 A 的运行环境保存到 PCB 中，再将其 PCB 移入到相应的队列（如果当前进程是从运行态到阻塞态，那么就进入阻塞队列；如果是从运行态到就绪态，那么就进入就绪队列）\n * 另一方面，选择 B 进程运行，更新其 PCB，同时可能会恢复其运行环境（考虑到 B 进程此前可能曾处于阻塞态）\n\n引起进程切换的事件一般有四种：\n\n * 当前进程的时间片被消耗完\n * 有更高优先级的进程到达，抢占了当前进程正在使用的 CPU\n * 当前进程主动阻塞\n * 当前进程终止\n\n\n# 进程的挂起（挂起原语 suspend 和激活原语 active）\n\n挂起原语：\n\n将进程从内存对换到外存，具体包括：找到需要挂起的进程的 PCB，检查它的状态并做相应操作（活动就绪态 -> 静止就绪态，活动阻塞态 -> 静止阻塞态），之后将该 PCB 复制到指定的内存区域。若被挂起的进程正在执行，则转向调度程序重新调度。\n\n引起进程挂起的事件，比如用户进程请求将自己挂起，或父进程请求将自己的某个子进程挂起。\n\n激活原语：\n\n将进程从外存对换回内存，检查该进程的现行状态并进行相应操作（静止就绪态 -> 活动就绪态，静止阻塞 -> 活动阻塞态）。\n\n引起进程激活的事件，比如，父进程或用户进程请求激活指定进程，或者是某个进程驻留在外存而内存中已有足够的空间。",normalizedContent:"# 进程控制\n\n进程控制由 “原语” 实现。原语具有 “原子性”，要么不被执行，一旦被执行，不可以被中断。\n\n在关中断指令下，即使有中断信号发射过来，也不会调用中断处理程序去处理中断，这就保证了原语操作不会被打断。而在开中断指令下，才会去处理中断。\n\n原语的基本操作包括：\n\n * 更新 pcb 中的信息（修改进程状态标志、保存当前运行环境到 pcb、从 pcb 中恢复运行环境）\n * 将 pcb 插入到合适的队列\n * 分配 / 回收资源\n\n创建原语和撤销原语配对，阻塞原语和唤醒原语配对。\n\n\n\n\n\n进程的执行是 “异步” 的，进程的控制是 “原子性” 的。\n\n\n# 进程的状态转换\n\n\n# 三态\n\n\n\n阻塞态的进程不会立即转为执行态。阻塞态和就绪态的进程在内存中，执行态的进程在 cpu 中。\n\n\n# 五态\n\n\n\n\n\n创建进程的过程在内存里完成。\n\n\n# 七态（重要，在后面的章节会有所拓展）\n\n\n\n# 静止阻塞 / 就绪队列的理解\n\n当我们把作业从外存拿到内存时，这个过程叫做高级调度。\n\n进程 pcb 被创建后，pcb 存在内存中，创建的过程在内存中实现；进程创建完成后，如果所需的资源除了内存之外都满足，则进程被对换到静止就绪队列，不参与调度，此时进程创建工作完成。\n\n如果静止阻塞队列中的进程，内存资源得到满足，但是阻塞的原因仍未解除，则从静止阻塞队列进入活动阻塞队列。\n\n如果静止就绪队列中的进程，内存资源得到满足，则从静止就绪队列进入活动就绪队列。\n\n# 挂起的原因\n\n负荷调节的需要、终端用户的请求、父进程请求、操作系统的需要\n\n# 挂起的特征\n\n * 该进程不能立即被执行\n * 挂起进程可能会等待事件，但所等待事件是独立于挂起条件的，事件结束并不能导致进程具备执行条件\n * 进程进入挂起状态是由于操作系统父进程或进程本身阻止它的运行\n * 结束进程挂起状态的命令只能通过操作系统或父进程发出\n\n# 状态转换的汇总\n\n状态              解释\n活动就绪态 → 静止就绪态   操作系统根据当前资源状况和性能要求，可能会把活动就绪态对换出去，成为静止就绪态。处于静止就绪态的进程不再被调度执行；\n静止就绪态 → 活动就绪态   内存中没有进程处于活动就绪态，或者处于静止就绪态的进程具有更高的优先级，那么静止就绪态就会被对换回来，此时才可能被调度执行\n活动阻塞态→ 静止阻塞态    操作系统根据当前资源状况和性能要求，可能会把活动阻塞态对换出去，成为静止阻塞态。\n静止阻塞态→ 静止就绪态    常见的情况是，引起进程等待的事件发生之后，相应的静止阻塞态进程将转换为静止就绪态\n静止阻塞态→ 活动阻塞态    但有时候，如果静止阻塞态进程的优先级高于静止就绪队列中的任何进程、并且系统有把握它等待的事件即将完成，那么就会激活为活动阻塞态\n运行态→ 静止就绪态      优先级较高的静止阻塞态在等待的事件完成后，可能会抢占 cpu，若此时资源不够，则可能导致正在运行的进程挂起为静止就绪态\n创建态→ 静止就绪态      操作系统根据当前资源状况和性能要求，可能会在进程创建完就把它对换到外存\n\n进程一旦被挂起，就意味着它被对换到了外存中，此时该进程无法再被 cpu 直接调度，除非它被对换回内存中，回到活动就绪态。比如静止就绪态、静止阻塞态，最后要得到 cpu 的调度，都必须经历回归到活动就绪态的过程。\n\n\n# 进程的创建（创建原语）\n\n\n\n 1. 申请空白 pcb\n 2. 为新进程分配其运行所需的资源\n 3. 初始化 pcb\n 4. 如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。如果是三态或五态，进程转入就绪态；如果是七态，储存在内存中的为活动就绪态，储存在外存中的为静止就绪态。\n\n\n# 进程的终止（撤销原语）\n\n引起进程终止的事件包括正常结束、异常结束和外界干预。\n\n终止进程的过程包括：从 pcb 集合中找到终止进程的 pcb，如果进程正在运行，则立即将它的 cpu 使用权移交给其它进程。接着终止它的所有子进程，将该进程的资源还给父进程或者操作系统，最后再删除 pcb。\n\n\n\n 1. 进入终止态的进程不能再执行\n 2. os 中保留其记录（状态码 + 计时统计数据），供其他进程收集\n 3. 一旦其他进程完成了对终止状态进程的信息提取，os 将删除该进程\n\n\n# 进程的阻塞（阻塞原语 block）\n\n阻塞进程的过程包括：找到要阻塞的进程的 pcb，保存当前运行环境到 pcb（方便后续恢复），修改 pcb 状态信息。接着暂停进程的运行，将 pcb 插入相应事件的阻塞队列（即改变它的链接地址）。\n\n引起进程阻塞的事件一般是：\n\n * 请求系统分配共享资源失败（系统已无足够的资源）\n * 等待某种操作的完成。如请求系统某些服务（比如打印服务）和启动某种操作（比如 i/o 操作）\n * 新数据尚未到达\n * 等待新任务的到达\n\n> 进程从运行态切换到阻塞态是一种主动行为，这个主动体现在是进程自己调用了阻塞原语。\n\n\n# 进程的唤醒（唤醒原语 wake up）\n\n唤醒进程的过程包括：在事件阻塞队列中找到 pcb 并将进程移出队列，修改 pcb 的状态信息，再将 pcb 插入到就绪队列。\n\n一般在等待的事件发生时，进程就会被唤醒。\n\n> 阻塞原语和唤醒原语是一对作用刚好相反的原语，必须成对使用。进程从阻塞态切换到运行态，是一个被动的过程，这个被动体现在并不是进程自己调用了唤醒原语，而是 “合作” 或相关进程进行了调用。\n\n\n# 进程的切换（切换原语）\n\n前面的原语主要都是操作一个进程，而切换原语同时操作到了两个进程。\n\n切换原语负责让当前运行的进程从 a 切换为 b，具体包括：\n\n * 一方面，将 a 的运行环境保存到 pcb 中，再将其 pcb 移入到相应的队列（如果当前进程是从运行态到阻塞态，那么就进入阻塞队列；如果是从运行态到就绪态，那么就进入就绪队列）\n * 另一方面，选择 b 进程运行，更新其 pcb，同时可能会恢复其运行环境（考虑到 b 进程此前可能曾处于阻塞态）\n\n引起进程切换的事件一般有四种：\n\n * 当前进程的时间片被消耗完\n * 有更高优先级的进程到达，抢占了当前进程正在使用的 cpu\n * 当前进程主动阻塞\n * 当前进程终止\n\n\n# 进程的挂起（挂起原语 suspend 和激活原语 active）\n\n挂起原语：\n\n将进程从内存对换到外存，具体包括：找到需要挂起的进程的 pcb，检查它的状态并做相应操作（活动就绪态 -> 静止就绪态，活动阻塞态 -> 静止阻塞态），之后将该 pcb 复制到指定的内存区域。若被挂起的进程正在执行，则转向调度程序重新调度。\n\n引起进程挂起的事件，比如用户进程请求将自己挂起，或父进程请求将自己的某个子进程挂起。\n\n激活原语：\n\n将进程从外存对换回内存，检查该进程的现行状态并进行相应操作（静止就绪态 -> 活动就绪态，静止阻塞 -> 活动阻塞态）。\n\n引起进程激活的事件，比如，父进程或用户进程请求激活指定进程，或者是某个进程驻留在外存而内存中已有足够的空间。",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"进程的特征",frontmatter:{title:"进程的特征",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/f0811a/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/03.%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/06.%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81.html",relativePath:"01.操作系统/03.第二章 进程的描述与控制/06.进程的特征.md",key:"v-8dbc2d50",path:"/pages/f0811a/",headersStr:null,content:"# 进程的特征\n\n结构性：程序块、数据块、进程控制块 PCB\n\n动态性：进程是程序在数据集合上的一次执行过程，有生命周期（由创建而产生、由调度而执行、由事件而等待、由撤销而消亡）\n\n并发性：多个进程实体同时存在在内存中，能在一段时间内同时运行，是进程的重要特征\n\n独立性：进程是独立运行、独立获取资源、独立接受调度的基本单位 -> 线程就不独立，它没有资源，依赖于 fork 的进程的资源\n\n异步性：进程按各自独立的、不可预知的速度向前推进。OS 要根据 “进程同步机制” 来解决异步问题。\n\n操作系统的 “虚拟性” 是进程所没有的。",normalizedContent:"# 进程的特征\n\n结构性：程序块、数据块、进程控制块 pcb\n\n动态性：进程是程序在数据集合上的一次执行过程，有生命周期（由创建而产生、由调度而执行、由事件而等待、由撤销而消亡）\n\n并发性：多个进程实体同时存在在内存中，能在一段时间内同时运行，是进程的重要特征\n\n独立性：进程是独立运行、独立获取资源、独立接受调度的基本单位 -> 线程就不独立，它没有资源，依赖于 fork 的进程的资源\n\n异步性：进程按各自独立的、不可预知的速度向前推进。os 要根据 “进程同步机制” 来解决异步问题。\n\n操作系统的 “虚拟性” 是进程所没有的。",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"进程通信",frontmatter:{title:"进程通信",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/8c5da1/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/03.%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/08.%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1.html",relativePath:"01.操作系统/03.第二章 进程的描述与控制/08.进程通信.md",key:"v-c91c1caa",path:"/pages/8c5da1/",headers:[{level:2,title:"进程通信的概念",slug:"进程通信的概念",normalizedTitle:"进程通信的概念",charIndex:11},{level:2,title:"共享存储",slug:"共享存储",normalizedTitle:"共享存储",charIndex:42},{level:2,title:"管道通信",slug:"管道通信",normalizedTitle:"管道通信",charIndex:184},{level:2,title:"消息传递",slug:"消息传递",normalizedTitle:"消息传递",charIndex:228},{level:3,title:"直接通信方式",slug:"直接通信方式",normalizedTitle:"直接通信方式",charIndex:255},{level:3,title:"间接通信方式",slug:"间接通信方式",normalizedTitle:"间接通信方式",charIndex:377}],headersStr:"进程通信的概念 共享存储 管道通信 消息传递 直接通信方式 间接通信方式",content:"# 进程通信\n\n\n# 进程通信的概念\n\n\n\n任何时候都不能直接访问临界资源\n\n\n# 共享存储\n\n共享空间是临界区，P1 和 P2 互斥访问（PV 操作）\n\n共享方式上，共享存储分为基于数据结构的共享（较为低级，速度慢限制多，例如开辟一个数组）和基于存储区的共享（高级通信方式，速度快，在内存中划出一块共享存储区，数据结构和存放位置都由进程控制，而不是 OS）\n\n\n# 管道通信\n\n\n\n从 P2 传回给 P1 时，必须再开辟一个管道，以实现全双工。\n\n\n# 消息传递\n\n回顾第一章消息传递等通信方式\n\n\n> # 直接通信方式\n> \n> 发送进程发送消息之前，首先申请一个缓冲区，之后把消息复制到缓冲区，再通过发送原语把缓冲区发送给接受进程，缓冲区首先到达接受进程的消息缓冲队列队尾。接受进程通过接受原语读取队列消息，并复制到本地变量。\n> \n> \n> # 间接通信方式\n> \n> 也叫做信箱通信。发送进程发送的消息首先到达一个消息容器，接受进程再从消息容器中接受消息。",normalizedContent:"# 进程通信\n\n\n# 进程通信的概念\n\n\n\n任何时候都不能直接访问临界资源\n\n\n# 共享存储\n\n共享空间是临界区，p1 和 p2 互斥访问（pv 操作）\n\n共享方式上，共享存储分为基于数据结构的共享（较为低级，速度慢限制多，例如开辟一个数组）和基于存储区的共享（高级通信方式，速度快，在内存中划出一块共享存储区，数据结构和存放位置都由进程控制，而不是 os）\n\n\n# 管道通信\n\n\n\n从 p2 传回给 p1 时，必须再开辟一个管道，以实现全双工。\n\n\n# 消息传递\n\n回顾第一章消息传递等通信方式\n\n\n> # 直接通信方式\n> \n> 发送进程发送消息之前，首先申请一个缓冲区，之后把消息复制到缓冲区，再通过发送原语把缓冲区发送给接受进程，缓冲区首先到达接受进程的消息缓冲队列队尾。接受进程通过接受原语读取队列消息，并复制到本地变量。\n> \n> \n> # 间接通信方式\n> \n> 也叫做信箱通信。发送进程发送的消息首先到达一个消息容器，接受进程再从消息容器中接受消息。",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"线程",frontmatter:{title:"线程",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/8676b4/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/03.%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/09.%E7%BA%BF%E7%A8%8B.html",relativePath:"01.操作系统/03.第二章 进程的描述与控制/09.线程.md",key:"v-08eb3d76",path:"/pages/8676b4/",headers:[{level:2,title:"引入线程",slug:"引入线程",normalizedTitle:"引入线程",charIndex:9},{level:2,title:"线程与进程",slug:"线程与进程",normalizedTitle:"线程与进程",charIndex:376},{level:2,title:"线程的状态",slug:"线程的状态",normalizedTitle:"线程的状态",charIndex:1139}],headersStr:"引入线程 线程与进程 线程的状态",content:"# 线程\n\n\n# 引入线程\n\n首先回忆一下为什么会有进程 —— 在以前，程序是串行执行的，为了让多道程序并发执行，引入了进程。进程虽然显著提高了资源利用率和系统吞吐量，满足了并发的需求，但是这种并发能不能做得更好呢？事实上，进程既是一个携带资源的独立单位，也是独立调度的基本单位，因此，在进程的创建、撤销和切换时，系统必须为之付出较大的时间空间开销。鉴于此，系统不宜设置过多的进程，也不宜频繁地切换进程，这对于并发来说是一种限制。\n\n如何解决这个问题呢？可以把进程看作是管理初创公司的老板，一开始人手不足，老板既要管理公司，也要四处奔跑沟通业务；但是一旦人手充足，那么老板仍然可以管理公司，只是沟通业务的工作就可以交给手下人去执行了。同理，我们可以考虑依然让进程作为拥有资源的独立单位，但是独立调度的基本单位则不再是进程，而是新引入的线程了。\n\n\n# 线程与进程\n\n调度的基本单位\n\n引入线程后，调度的基本单位不再是进程，而是线程。线程能够独立运行，且切换的时候，代价远远小于进程切换的代价。同一进程不同线程的切换，不会引起进程的切换。\n\n执行的基本单位\n\n我们可以说进程处于 “执行” 状态，但其实指的是该进程的某个线程正在执行；可以说进程处于 “挂起” 状态，但其实指的是该进程的所有线程都被挂起。但我们不能说 “挂起线程”，只能说 “挂起进程”，因为我们只有在无法为进程分配资源时才会将其挂起，而线程并不携带资源，“挂起线程” 没有意义。\n\n并发性\n\n进程间仍然能够并发，不仅如此，同一进程内不需要切换进程运行环境和内存地址空间，一个进程中的多个线程间也能并发，不同进程中的线程也能够并发，系统并发性提升。\n\n资源\n\n资源由进程携带。为了性能考虑，线程仅占有一点必不可少的资源（比如 TCB，程序计数器等）。虽然线程不携带资源，但它可以使用 fork 的进程的资源，即同一进程的线程共享该进程所拥有的资源。另外，这些线程还共享同一片内存地址空间，所以也可以方便地进行通信。\n\n系统开销\n\n在创建和撤销进程时，系统需要分配或者回收 PCB，分配或者回收资源，所以需要付出一定的时空开销；但是同一进程下的各个线程共享内存空间，线程的创建、撤销和通信的时空开销则小很多。\n\n> 独立性\n> \n> 同一进程中的线程间独立性要比不同进程间独立性低很多。前者独立性高，因为要防止进程之间彼此干扰和破坏；后者独立性低，因为同一进程的多个线程通常需要协作完成任务，互相之间可访问程度相对来说会比较高。\n> \n> 支持多处理机系统\n> \n> 传统的单线程进程，即使处理机再多，一个进程也只能运行在一个处理机上；但是引入了线程后，一个进程的多个线程可以分配到多个处理机上、并行执行。\n\n\n# 线程的状态\n\n线程的状态有：运行、就绪和阻塞，线程的状态转换也类似于进程。",normalizedContent:"# 线程\n\n\n# 引入线程\n\n首先回忆一下为什么会有进程 —— 在以前，程序是串行执行的，为了让多道程序并发执行，引入了进程。进程虽然显著提高了资源利用率和系统吞吐量，满足了并发的需求，但是这种并发能不能做得更好呢？事实上，进程既是一个携带资源的独立单位，也是独立调度的基本单位，因此，在进程的创建、撤销和切换时，系统必须为之付出较大的时间空间开销。鉴于此，系统不宜设置过多的进程，也不宜频繁地切换进程，这对于并发来说是一种限制。\n\n如何解决这个问题呢？可以把进程看作是管理初创公司的老板，一开始人手不足，老板既要管理公司，也要四处奔跑沟通业务；但是一旦人手充足，那么老板仍然可以管理公司，只是沟通业务的工作就可以交给手下人去执行了。同理，我们可以考虑依然让进程作为拥有资源的独立单位，但是独立调度的基本单位则不再是进程，而是新引入的线程了。\n\n\n# 线程与进程\n\n调度的基本单位\n\n引入线程后，调度的基本单位不再是进程，而是线程。线程能够独立运行，且切换的时候，代价远远小于进程切换的代价。同一进程不同线程的切换，不会引起进程的切换。\n\n执行的基本单位\n\n我们可以说进程处于 “执行” 状态，但其实指的是该进程的某个线程正在执行；可以说进程处于 “挂起” 状态，但其实指的是该进程的所有线程都被挂起。但我们不能说 “挂起线程”，只能说 “挂起进程”，因为我们只有在无法为进程分配资源时才会将其挂起，而线程并不携带资源，“挂起线程” 没有意义。\n\n并发性\n\n进程间仍然能够并发，不仅如此，同一进程内不需要切换进程运行环境和内存地址空间，一个进程中的多个线程间也能并发，不同进程中的线程也能够并发，系统并发性提升。\n\n资源\n\n资源由进程携带。为了性能考虑，线程仅占有一点必不可少的资源（比如 tcb，程序计数器等）。虽然线程不携带资源，但它可以使用 fork 的进程的资源，即同一进程的线程共享该进程所拥有的资源。另外，这些线程还共享同一片内存地址空间，所以也可以方便地进行通信。\n\n系统开销\n\n在创建和撤销进程时，系统需要分配或者回收 pcb，分配或者回收资源，所以需要付出一定的时空开销；但是同一进程下的各个线程共享内存空间，线程的创建、撤销和通信的时空开销则小很多。\n\n> 独立性\n> \n> 同一进程中的线程间独立性要比不同进程间独立性低很多。前者独立性高，因为要防止进程之间彼此干扰和破坏；后者独立性低，因为同一进程的多个线程通常需要协作完成任务，互相之间可访问程度相对来说会比较高。\n> \n> 支持多处理机系统\n> \n> 传统的单线程进程，即使处理机再多，一个进程也只能运行在一个处理机上；但是引入了线程后，一个进程的多个线程可以分配到多个处理机上、并行执行。\n\n\n# 线程的状态\n\n线程的状态有：运行、就绪和阻塞，线程的状态转换也类似于进程。",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"进程同步",frontmatter:{title:"进程同步",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/1da972/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/03.%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/07.%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5.html",relativePath:"01.操作系统/03.第二章 进程的描述与控制/07.进程同步.md",key:"v-21e297d6",path:"/pages/1da972/",headers:[{level:2,title:"基本概念",slug:"基本概念",normalizedTitle:"基本概念",charIndex:11},{level:3,title:"进程互斥的基本实现逻辑",slug:"进程互斥的基本实现逻辑",normalizedTitle:"进程互斥的基本实现逻辑",charIndex:355},{level:3,title:"同步机制应遵循的原则",slug:"同步机制应遵循的原则",normalizedTitle:"同步机制应遵循的原则",charIndex:812},{level:2,title:"信号量和PV操作",slug:"信号量和pv操作",normalizedTitle:"信号量和 pv 操作",charIndex:978},{level:3,title:"信号量机制",slug:"信号量机制",normalizedTitle:"信号量机制",charIndex:993},{level:4,title:"整型信号量",slug:"整型信号量",normalizedTitle:"整型信号量",charIndex:1161},{level:4,title:"记录型信号量",slug:"记录型信号量",normalizedTitle:"记录型信号量",charIndex:2068},{level:3,title:"信号量机制实现",slug:"信号量机制实现",normalizedTitle:"信号量机制实现",charIndex:4517},{level:4,title:"进程互斥",slug:"进程互斥",normalizedTitle:"进程互斥",charIndex:212},{level:4,title:"进程同步",slug:"进程同步-2",normalizedTitle:"进程同步",charIndex:2},{level:4,title:"前驱关系",slug:"前驱关系",normalizedTitle:"前驱关系",charIndex:6161},{level:2,title:"信号量和PV操作解决进程同步问题",slug:"信号量和pv操作解决进程同步问题",normalizedTitle:"信号量和 pv 操作解决进程同步问题",charIndex:7761},{level:3,title:"生产者-消费者",slug:"生产者-消费者",normalizedTitle:"生产者 - 消费者",charIndex:7784},{level:3,title:"苹果橘子问题",slug:"苹果橘子问题",normalizedTitle:"苹果橘子问题",charIndex:11698},{level:3,title:"银行问题",slug:"银行问题",normalizedTitle:"银行问题",charIndex:12440},{level:3,title:"五个哲学家进餐问题",slug:"五个哲学家进餐问题",normalizedTitle:"五个哲学家进餐问题",charIndex:12513},{level:4,title:"实现原子操作",slug:"实现原子操作",normalizedTitle:"实现原子操作",charIndex:12864},{level:4,title:"只有四个人参与这个过程",slug:"只有四个人参与这个过程",normalizedTitle:"只有四个人参与这个过程",charIndex:13687},{level:4,title:"奇数拿左边，偶数拿右边",slug:"奇数拿左边-偶数拿右边",normalizedTitle:"奇数拿左边，偶数拿右边",charIndex:14348},{level:2,title:"管程",slug:"管程",normalizedTitle:"管程",charIndex:15404},{level:3,title:"管程的基本思想",slug:"管程的基本思想",normalizedTitle:"管程的基本思想",charIndex:15433}],headersStr:"基本概念 进程互斥的基本实现逻辑 同步机制应遵循的原则 信号量和PV操作 信号量机制 整型信号量 记录型信号量 信号量机制实现 进程互斥 进程同步 前驱关系 信号量和PV操作解决进程同步问题 生产者-消费者 苹果橘子问题 银行问题 五个哲学家进餐问题 实现原子操作 只有四个人参与这个过程 奇数拿左边，偶数拿右边 管程 管程的基本思想",content:"# 进程同步\n\n\n# 基本概念\n\n> 在多道批处理系统中，多个进程是并发执行的，而并发执行的进程不可避免地需要共享一些系统资源（比如内存、打印机、摄像头等）。然而，有些资源在一个时间段内只允许一个进程使用，诸如各种物理设备、变量、数据、内存缓冲区等，这些称之为临界资源 —— 也就是说，一方面，并发执行的进程需要共享资源；另一方面，临界资源的访问又必须是互斥地进行（不能同时共享），很显然，这会导致资源访问上的矛盾。我们通过进程互斥来解决此类问题。\n\n进程同步：指多个相关进程在执行次序上的协调\n\n进程互斥：指在多道程序环境下，每次只允许一个进程对临界资源进行访问\n\n临界资源：一次仅供一个进程使用的资源\n\n临界区：在进程中涉及到临界资源的程序段叫临界区\n\n相关临界区：多个进程的临界区称为相关临界区\n\n\n# 进程互斥的基本实现逻辑\n\n为了实现临界资源的互斥访问，可以在逻辑上将一个进程对临界资源的访问过程分为四个部分：\n\ndo {\n    extry section;       // 进入区\n    critical section;    // 临界区\n    exit section;        // 退出区\n    remainder section;   // 剩余区\n} while(true)\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n * 进入区：A 进程想要访问临界资源，首先会在进入区检查是否可以进入，由于此时没有其它进程占用临界资源，所以检查通过，同时它设置了一个 Flag 标志当前自己正在访问临界资源；\n * 临界区：实际访问临界资源的那段代码\n * 退出区：负责解除之前的 Flag\n * 剩余区：其它处理\n\n对于 B 进程，如果此时它也想要访问这个资源，同样就会在进入区做一个检查，它知道了 A 进程正在访问，所以自己就不能访问了。这样就实现了资源访问的互斥。\n\n\n# 同步机制应遵循的原则\n\n空闲让进：临界区空闲时，应该让想要进入临界区的进程立刻进来\n\n忙则等待：同一时刻只允许一个进程进入临界区\n\n有限等待：要求访问临界资源的进程，应该保证在有限时间内进入临界区\n\n让权等待：当 A 进程进入临界区而导致 B 进程不能进入自己的临界区时，应该立刻释放处理机，防止进程陷入 “忙等” 状态。\n\n\n# 信号量和 PV 操作\n\n\n# 信号量机制\n\n信号量机制可以让用户通过使用操作系统提供的一对原语来对信号量进行操作，从而方便地实现进程互斥和进程同步。信号量（Semaphore）其实就是一个变量，它可以记录系统中某个资源的数量，而原语指的是 wait(S) 原语和 signal(S) 原语（或者说是 P 操作和 V 操作，即通过和释放），可以看作是两个函数。\n\n# 整型信号量\n\n信号量如果单纯是一个整数型的变量，那么就称为整型信号量，它的值记录了系统中某种资源的数量。在使用整型信号量的情况下，P 、V 操作是类似这样的：\n\nint S = 1;\nwait(int S)               \n{                       \n    while(S <= 0)\t\t\t\n    S = S-1              \n}\nsignal(int S)\n{\n    S = S+1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n同样以进程 P0，P1 为例进行说明：\n\nP0：                   P1:\nwait(S)                wait(S)            // 进入区\ncritical section       critical section   // 临界区\nsignal(S)              signal(S)          // 退出区 \n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n假定 P0 想要进入临界区，那么它就会在进入区申请资源：执行 P 操作，进行 “检查” 和 “上锁”，由于 S 一开始是 1（表示目前有一个资源可以使用），所以 P0 可以跳过循环，成功申请到资源。此后，S 减一变为 0，代表已经没有可用资源了 —— 这一步也相当于上锁；对于 P1，当他想要申请资源的时候，同样先来到进入区执行 P 操作，由于 S = 0，所以此时 P1 陷入了死循环；再回到 P0 ，他完成任务后会在退出区释放资源，S 加一变为 1，这时候 P1 才有机会退出循环，进而申请资源。\n\n整个过程其实和之前介绍的方法是很类似的，但是由于这次，“检查” 和 “上锁” 两个操作被封装在一个原语里，所以这两个操作必定是一气呵成、无法被打断的，这就避免了某个进程钻空子的现象。但是同时我们也发现，在 P0 时间片用完后，P1 仍然会占用处理机进行没有意义的死循环，也就是仍然违背了 “让权等待” 的原则。\n\n于是在此基础上，又出现了记录型信号量\n\n# 记录型信号量\n\n与整型信号量仅用一个单一变量记录可用资源数不同，记录型信号量的数据结构类似于一个结构体，它不仅记录了可用资源数 value ，而且还提供了一个等待队列 L 。\n\n记录型信号量的思想其实是，如果由于 P0 在使用临界资源而导致 P1 暂时无法使用，那么干脆就不给 P1 陷入循环的机会，直接让它自己去阻塞队列，这样 P1 在被唤醒之前，永远无法占用处理机，也自然就不可能出现白白占用处理机的情况。而在 P0 释放资源后，我们才来考虑唤醒 P1。\n\n记录型信号量的结构如下所示：\n\ntypedef struct {\n    int value\n    sturct process *L\n} semaphore\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n同时，记录型信号量的 P、V 操作也有所不同，如下所示：\n\nwait (semaphore S){\n    S.value--\n    if(S.value < 0){\n        block(S.L)\n    }\n}\nsignal(semaphore S){\n    S.value++\n    if(S.value <= 0){\n        wakeup(S.L)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 这里要注意的第一个地方是， value 是可用的资源数，当它大于 0 的时候自然是存在可用资源（供大于求），当它小于 0 的时候，则说明不仅无可用资源而且有其他进程等着用（供不应求）。\n * 第二个地方是，在进入区 value 一定会减一，表示申请到了资源，或者表示存在着某个进程有想要申请资源的意愿\n * 执行 ++ 或 -- 前， S.value 为正值时代表可利用的物理资源数； S.value 为负值时，其绝对值代表阻塞队列中等待的进程数。\n\n下面我们用例子来说明记录型信号量工作的过程，为了加深记忆，这里用四个进程来说明：\n\nPO:            P1              P2           P3\nwait(S)        wait(S)         wait(S)      wait(S)\n临界区          临界区           临界区        临界区\nsignal(S)      signal(S)       signal(S)    signal(S)\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n假设计算机中有两台可用的打印机 A 和 B（也就是说，value = 2），有四个进程需要用到打印机资源。\n\n一开始假定是 P0 先占有处理机，那么 P0 就会在进入区申请资源 。由于 value 一开始是 2，所以 P0 成功申请到资源 A，之后 value 数量减一变为 1，同时来到临界区开始 “干活”；在 P0 的时间片完了之后，P1 占有处理机，此时同样申请到资源 B，value 由 1 变为 0，之后来到临界区 “干活”。自此，两个打印机都被占用了。\n\n在 P1 的时间片完了之后，P2 占有处理机，value 由 0 变为 -1 < 0，前面我们说过，value < 0 说明无可用资源，所以此时 P2 将自己主动送到了阻塞队列。接着来到了 P3，value 由 -1 变为 -2，P3 同样进入阻塞队列。P2，P3 都从运行态转为阻塞态。\n\n处理机又来到 P0，P0 很快执行完了，于是在退出区执行 P 操作释放资源，将 value 加一变为 -1，之后由于通过 if 检测到阻塞队列中有进程等着用资源，所以马上唤醒了队头的 P2 ，P2 从阻塞态回到就绪态，并直接进入临界区开始自己的工作，在完成后同样来到退出区释放资源，value 由 -1 变为 0，但是在 if 中还是检测到了队列中仍然有进程等着用资源，于是马上把队头的 P3 唤醒，P3 回到就绪态，并直接进入临界区开始工作，此后，value 由 0 变为 1，此时 if 不通过，说明队列中再也没有其它进程等着了，该拿到资源的进程都拿到了。自此，P0，P2，P3 都拿到了 A 资源，而 P1 也在不久后完成工作，在退出区释放资源 B，此时 value 从 1 变回最初的 2 ，代表占用的资源已经全数归还。\n\n当然，实际情况还可能是，P2 拿到了 A 资源，P3 拿到了 B 资源，但分析过程也是大同小异的。\n\n显然，记录型信号量与前面介绍的所有方法最大的区别就在于，不会再有进程白白占用处理机进行没有意义的循环 —— 相反地，这些进程非常 “老实” 地把自己送到了阻塞队列，选择在那里慢慢地等待，等待其它进程完成后将自己唤醒，这种做法 “既方便了别人，也方便了自己”。这就正好与我们多次强调的 “让权等待” 非常契合了。\n\n> 记录型信号量明显优于整型信号量，所以在提到 PV 操作的时候，一般默认指的都是记录型信号量。\n\n我们通过几道题加深一下印象：\n\n * n 个并发进程，信号量初始值为 1，当 n 个进程都执行 P 操作后，信号量的值为多少？\n * 信号量初值为 4，多次 PV 操作后变为 -2，那么获得资源的进程数目是多少？\n * 5 个并发进程，信号量初始值为 3，那么信号量取值范围是多少？\n\n（1）每执行一次 P 操作，信号量就会减一，所以对于 n 个并发进程，共需要执行 n 次 P 操作，所以此后信号量的值是 1-n\n\n（2）信号量值为 -2，说明有两个进程位于阻塞队列，说明暂无空闲资源可用，换句话说，四个资源都被占用了，所以共有四个进程获得资源\n\n（3）信号量初始值为 3，所以最大值为 3，如果 5 个进程都执行 P 操作，那么信号量会变成 3-5 = -2，即最小值为 -2，所以取值范围 -2 ~ 3。\n\n\n# 信号量机制实现\n\n# 进程互斥\n\n其实上面讲的例子就已经很好地实现了进程互斥，但是我们可以简化一下写法，如下：\n\nsemaphore mutex = 1;\nP0(){\n    P(mutex) //使用临界资源前需要加锁\n    critical section //临界区代码段\n    V(mutex) //使用临界资源前需要解锁\n}\nP1(){\n    P(mutex)\n    critical section //临界区代码段\n    V(mutex)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n我们默认已经定义了 semaphore 的结构体，并用互斥信号量 mutex 记录可用资源的个数（进入临界区的名额），初始值为 1。要实现互斥，关键就是要在临界区之前使用 P 操作进行上锁，在临界区之后使用 V 操作进行解锁。\n\nPV 操作要成对出现，但不一定要在同一个进程中。不同的临界资源设置不同的互斥信号量。记录型信号量有时需要自己定义。\n\n# 进程同步\n\n多个进程（如 P1、P2）一起完成某项任务的时候，如何确保它们按照一定的先后顺序（先 P1 后 P2）有秩序地执行呢？信号量机制也可以很好地实现进程同步。它有三个关键步骤：\n\n * 设置同步信号量初始值为 0\n * 在 “前操作” 之后执行 V (S)\n * 在 “后操作” 之前执行 P (S)\n\n首先，0 是一个非常关键的 “分水岭”，大于 0 的时候不会发生阻塞，小于 0 则会发生阻塞。\n\n我们要确保 “前操作” 在前面，“后操作” 在后面，实际上只要做到三件事：V 在 “前操作” 后面、P 在 “后操作” 前面、V 在 P 前面。第一个和第二个条件都是可以通过实际书写代码来做到的，而要达到第三个条件 —— V 在 P 前面，就有必要让信号量初始值为 0，因为一旦初始值为 0，则每当 P 想要 “违规” 抢先于 V 执行的时候，都会由于首先执行信号量自减的操作而导致当前所在进程进入阻塞队列 ，也就是说：\n\nP 先于 V 执行 => P 所在进程会被阻塞 => ” 后操作 “始终无法执行\n\n所以，在这种情况下，就只能转而执行 V 所在的进程了。在这个进程里，由于 V 在 “前操作” 后面，所以一定是 “前操作” 执行完了再去执行 V。而执行 V 就会自增信号量，同时唤醒对方进程，对方进程再去顺序执行 P 操作 —— 虽然此时信号量又自减，但是是在加一的基础上自减，所以并不会导致再次阻塞，所以 P 执行完后就顺序执行 “后操作”。由此，我们确保了两个操作一定是严格按照先后顺序执行的。\n\n来看下面的例子：\n\n// 顺序应该是：code1,code2,code4\nP0：                 P1:\ncode 1               P(S)\ncode 2               code 4\nV(S)                 code 5\ncode 3               code 6\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n我们设想比较差的情况 —— P1 想要抢先执行 code 4，看看会发生什么。假设是 P1 首先占用处理机，那么就会执行 P 操作，这个操作使得信号量由 0 变成 -1，进而进入 if 代码块，使得 P1 进程阻塞；这之后，处理机来到 P0，执行 code1，code2，V 操作，使得信号量由 -1 变成 0，同时唤醒 P1 进程；P1 进程被唤醒后从 P 操作之后的断点继续执行（P1 被唤醒后不会重新再执行一遍 P 操作，否则会再次进入阻塞。与七态中进程所需资源得到满足后会从阻塞队列转入就绪队列相同，P1 会接着之前停下的地方继续），来到 code4。以上，整个过程确保了按照 code1，code2，code4 的顺序执行。\n\n# 前驱关系\n\n前面描述的都是两个进程的同步问题，但有时候也可能出现像下图这样多个进程互相依赖、有序运行的情况。其中，code 语句仍然是前操作或者后操作，P1 进程有 code1 语句，P2 进程有 code2 语句… 以此类推，这里要求六个进程必须按照箭头所指方向有序运行。\n\n\n\n其实这种情况就是把多个同步问题结合起来，我们仍然可以用信号量机制来实现：\n\n * 每一个前驱关系都是一个同步问题，要保证一前一后的操作\n * 为每一个前驱关系各设置一个同步信号量\n * 在 “前操作” 之后对相应的同步信号量执行 V 操作\n * 在 “后操作” 之前对相应的同步信号量执行 P 操作\n\n代码大概如下：\n\nP1:          P2:          P3:          P4:        \ncode1        P(signal1)   P(signal2)   P(signal3)\nV(signal1)   code2        code3        code4 \nV(signal2)   V(signal3)   V(signal7)   V(signal5)\n             V(signal4)\nP5:          P6:         \nP(signal4)   P(signal5)   \ncode5        P(signal6) \nV(signal6)   P(signal7)\n             code6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n可以观察到，除了 P1 进程之外，其它进程首先执行的都是 P 操作，所以一旦这些进程之一首先拿到处理机使用权，都无一例外地会进入阻塞队列。由于情况很多，这里我们试着只分析某一种情况 ——\n\n假设一开始是 P2 占有处理机，那么由于 signal1 初始为 0，导致了 P2 进队列，此后处理机来到 P3，P3 同样进队列… 以此类推，阻塞队列就会变成：\n\n\n\n随后总算来到 P1 进程了，P1 进程作为一切的开始，特殊之处就在于它不是以 P 操作开始的，P1 会首先执行 V (signal1)，这一步把 signal1 加一，同时唤醒 P2 进程，P2 进程进入就绪队列：\n\n\n\n再之后，P1 执行 V (signal2)，这一步把 signal2 加一，同时唤醒 P3 进程，P3 进程也进入就绪队列。\n\n\n\nP1 执行完之后，就绪队列队头的 P2 进入运行态，执行到 V (signal3) 的时候，signal3 加一，同时唤醒 P4 进程，P4 进程进入就绪队列，\n\n\n\n再之后，P2 执行 V (signal4)，这一步把 signal4 加一，同时唤醒 P5 进程，P5 进程也进入就绪队列。\n\n\n\nP2 执行完之后，处理机调度就绪队列队头的 P3 开始执行，P3 执行到 V (signal7) 的时候，signal7 加一，注意这一步没有唤醒任何进程\n\n\n\nP3 执行完之后，处理机调度就绪队列队头的 P4 开始执行，P4 执行到 V (signal5) 的时候，signal5 加一，同时唤醒 P6 进程，P6 进程进入就绪队列\n\n\n\nP4 执行完之后，处理机调度就绪队列队头的 P5 开始执行，P5 执行到 V (signal6) 的时候，signal6 加一，注意这一步没有唤醒任何进程（阻塞队列已经没有进程了）\n\n\n\nP5 执行完之后，处理机调度就绪队列队头的 P6 开始执行，P6 的 signal6 、signal7 在前面已经得到加一操作，所以此时绝对不会在这里卡住，可以顺利执行，直到结束。\n\n\n\n这样基本就把整个流程过了一遍，当然，经过排列组合之后，分析过程都是大同小异的。\n\n\n# 信号量和 PV 操作解决进程同步问题\n\n\n# 生产者 - 消费者\n\n生产者 - 消费者问题是系统中并发进程内在关系的一种抽象，是典型的进程同步问题。生产者进程 P1 可以是计算进程、发送进程；而消费者进程 P2 可以是打印进程、接收进程等等。\n\n> 有界缓冲：\n> \n>  * 一个生产者一次放入缓冲区一个产品，且无限次循环\n>  * 一个消费者一次取出缓冲区一个产品，且无限次循环\n>  * 两个进程独立\n> \n> 要解决的问题：\n> \n>  * 缓冲池满生产者不能放产品\n>  * 缓冲池空消费者不能取产品\n>  * 只能一个生产者或者消费者对缓冲区进行操作\n\n进程个数：2\n\n关系分析：\n\n * 互斥关系 P1、P2 互斥访问缓冲区\n * 同步关系 P1 生产后 P2 才能消费\n\n信号量设置：\n\n * 互斥信号量 mutex = 1 ，实现对缓冲区这个资源的互斥访问\n * 同步信号量 empty = n ，表示空闲缓冲区的数量\n * 同步信号量 full = 0 ，表示非空闲缓冲区的数量，也即产品数量\n\n产品： P1 V P2 P （V 增加，P 锁定，生产者放入产品，消费者取出产品）\n\n空间： P1 P P2 V\n\n先考虑对互斥关系的实现。这里的临界资源是缓冲区，生产者进程把产品放进去，消费者进程从里面取走产品，这两者不能同时进行，所以这里是互斥的关系。P1、P2 都各有一对 PV 操作，用以实现对缓冲区资源的访问。另外，生产者在进行 PV 操作之前，必定要先生产产品；而消费者在进行 PV 操作之后，必定要使用产品。这时候，初步的伪代码是这样的：\n\nproducer(){                         consumer(){\n    while(1){                           while(1){\n        生产产品                              P(mutex)\n        P(mutex)                             从缓冲区中取走产品 \n\t\t把产品放入缓冲区                       V(mutex)\n        V(mutex)                             使用产品 \n    }                                   }\n}                                   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n接着考虑第一个同步关系，关注空缓冲区。先释放缓冲区，后使用缓冲区，且缓冲区满不再放入产品，所以这里 “前操作” 是消费者释放缓冲区，“后操作” 是生产者占用缓冲区，根据 “前 V 后 P”，我们需要在 “前操作” 之后针对 empty 这个信号量进行一次 V 操作，需要在 “后操作” 之前针对 empty 进行一次 P 操作。生产者执行 P 操作检查是否还有空缓冲区时，若缓冲区已满，将进入阻塞。所以，这时候代码变成：\n\nproducer(){                         consumer(){\n    while(1){                           while(1){\n        生产产品                             P(mutex)\n        P(empty)                            从缓冲区中取走产品 \n\t\tP(mutex)                            V(mutex)\n        把产品放入缓冲区                      V(empty)  \n        V(mutex)                            使用产品 \n    }                                   }     \n}                                   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n再考虑第二个同步关系，关注产品。先生产产品并将其放入缓冲区，后从缓冲区取出产品并使用。这里划分出前后两个操作，所以再安排一对 PV 操作：\n\nproducer(){                         consumer(){\n    while(1){                           while(1){\n        生产产品                            P(full)\n        P(empty)                           P(mutex)\n\t\tP(mutex)                           从缓冲区中取走产品 \n        把产品放入缓冲区                     V(mutex) \n        V(mutex)                           V(empty)  \n        V(full)                            使用产品 \n    }                                   }     \n}                                   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这就是最后的代码了。现在我们试着跑一下流程：初始的时候 empty = n，表示所有缓冲区都是空闲的，同时 full = 0，表示一个产品都没生产出来。假如处理机首先来到 consumer 进程，那么就会通过 P(full) 检查是否有产品，这里当然是没有，所以它只能进行等待；处理机来到 producer，首先通过 P(empty) 检查是否有空闲缓冲区，这里当然有，于是它开始把生产的产品放入缓冲区，随后记录产品的数量，这个过程可以反复进行，直到所有缓冲区都被占用了，此时 producer 就会进入等待状态，等待 consumer 进程取出产品、释放缓冲区；当然还有可能的情况是，producer 尚未占用完所有缓冲区，进程就切换到 consumer 了，那么这时候 consumer 因为检查到有产品，所以也会取出产品、释放缓冲区。\n\n> P 操作不可以随意对调位置，V 操作可以。\n\n这里要注意可能会引起 “死锁” 现象的一种写法。如下所示：\n\nproducer(){                         consumer(){\n    while(1){                           while(1){\n        生产产品                            P(mutex)\n        P(mutex)                           P(full)\n\t\tP(empty)                           从缓冲区中取走产品 \n        把产品放入缓冲区                     V(mutex) \n        V(mutex)                           V(empty)  \n        V(full)                            使用产品 \n    }                                   }     \n}                                   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这个写法的问题在于，还没有先检查缓冲区是否没满或者是否非空，就强行进行互斥的 “上锁”。假如还是按照前面的流程，一开始处理机在 consumer 这里，那么 consumer 实际上在没有检查缓冲区是否非空的情况下就直接 “上锁” 了，这导致它在 P(full) 这一步的时候被卡住，只能等待，而在之后切换到 producer 的时候，正常情况下他应该生产可供对方消费的产品，但是由于对方已经上了锁，所以 producer 在 P(mutex) 这一步也被卡住了，只能进行等待。这也就是说，producer 等待 consumer 释放临界区，而 consumer 等待 producer 使用缓冲区，双方陷入循环等待，造成了 “死锁”。\n\n另一种情况，我们也可以设想一开始处理机是在 producer 这里，依然会导致 “死锁”。按照这种情况正常用完全部缓冲区之后，如果处理机还是在 producer 这里，那么 producer 在检查缓冲区是否已满之前也会将自己提前上锁，在 P(empty) 这一步陷入等待，之后即使进程切换到 consumer 这里，它也会因为对方提前上锁，而导致自己在 P(mutex) 这一步陷入等待。也就是说，这不过是前面那种” 死锁 “现象的翻版。\n\n总之，关键就在于不管是消费者进程，还是生产者进程，都不能先上锁再检查，否则就有可能发生死锁。\n\n\n# 苹果橘子问题\n\n盘子 缓冲区\n\n2 水果 2 产品\n\n爸爸 妈妈 2 生产者，P1 P2\n\n儿子 女儿 2 消费者，C1 C2\n\n进程个数：4\n\n关系分析：\n\n * 互斥关系 P1、P2、C1、C2 互斥访问缓冲区\n * 同步关系 P1 生产后 C1 才能消费，P2 生产后 C2 才能消费\n\n信号量设置：\n\n * 互斥信号量 mutex = 1 ，实现对缓冲区这个资源的互斥访问\n * 同步信号量 apple = 0 ，表示苹果的数量\n * 同步信号量 orange = 0 ，表示橘子的数量\n\n产品： P1 P2 V C1 C2 P （V 增加，P 锁定，生产者放入产品，消费者取出产品）\n\n空间： P1 P2 P C1 C2 V\n\nP1(){\n  while(1){\n      P(mutex)\n      把苹果放入盘子\n      V(apple)\n  }\n}\nP2(){\n  while(1){\n      P(mutex)\n      把橘子放入盘子\n      V(orange)\n  }\n}\nC1(){\n   while(1){\n       P(apple)\n       从盘子中取走苹果\n       V(mutex)\n }\nC2(){\n  while(1){\n       P(orange)\n       从盘子中取走橘子\n       V(mutex)\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 银行问题\n\n\n\n顾客的 V (full) 与 P (service) 应调换位置，并去除 “获取服务”\n\nservice 默认值应为 1\n\n\n# 五个哲学家进餐问题\n\n一张圆桌，五个哲学家，五支筷子（每两个哲学家中间会有一支筷子），哲学家要么思考，要么吃饭，吃饭前会拿起左右两边的筷子，吃饭后会放下筷子。如果筷子被其它哲学家拿走，则自己需要等待。我们的目的很简单：保证所有哲学家都有机会吃上饭，不能让一个或者多个哲学家始终无法吃饭。\n\n\n\n\n\n如果哲学家 0 号拿起左右筷子后，进程切换到哲学家 1 号，那么 1 号是会被阻塞的，所以这样相邻的哲学家中有一个可以吃饭。但是，如果 0 号拿起左筷子后进程切换到 1 号，1 号也拿起自己的左筷子，以此类推，所有的哲学家都只有左筷子，这导致了所有的哲学家都被阻塞，没有任何哲学家能够吃饭，也没有人可以释放筷子，使这些哲学家都陷入无限的等待中，造成 “死锁” 的发生。\n\n解决这个问题有三个方法：\n\n# 实现原子操作\n\n很容易想到，拿起左筷子和拿起右筷子并不是一个原子操作。准备一个互斥信号量 mutex = 1 ，并把拿筷子的操作封装在一个 PV 操作里。代码如下：\n\nPi(){\n    while(1){\n        P(mutex)\n        P(chopstick[i])\n        P(chopstick[(i+1)%5])\n        V(mutex)\n        eat()\n        V(chopstick[i])\n        V(chopstick[(i+1)%5])\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在 0 号哲学家拿起左筷子之后，即使发生进程切换，1 号进程也会被卡在 mutex 的 P 操作，被送往阻塞队列，其它进程也同理。所以最后再次来到 0 号进程时便可以顺利拿起右筷子。这种做法保证了有一个哲学家是可以吃饭的。\n\n> 这里涉及到了一个进程需要一次性两个资源才能完成任务的问题，也可以使用 AND 信号量集机制。AND 信号量集机制的 P 操作是一个相对苛刻的操作，要求一个进程要么拿到全部资源，要么一个资源也拿不到。一开始筷子数量足够，所以 0 号在一开始就可以一次性拿到左右筷子。同理，在释放筷子的时候，也是一次性释放两支筷子。代码如下：\n> \n> Pi(){\n>     while(1){\n>         Swait(chopstick[(i+1)%5],chopstick[i]);\n>         eat()\n>         Ssignal(chopstick[(i+1)%5],chopstick[i]);\n>     }\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n\n# 只有四个人参与这个过程\n\n之前的情况是五个哲学家，五支筷子，所以容易出现谁也无法吃饭的情况，但是如果规定整个过程最多只有四个哲学家参与，即使这四个哲学家每个人都拿走了一支筷子，也还剩下一支筷子可以分配给某个哲学家。\n\n如何限定 “最多四个人可以参与这个过程” 呢？准备一个互斥信号量 count ，但是这个信号量初值不再是 1 ，而是 4，表示最多允许四个哲学家参与过程。当 count 减少到 -1 的时候，就不能再让哲学家进来了。代码如下：\n\nPi(){\n    while(1){\n        P(count)\n        P(chopstick[i])\n        P(chopstick[(i+1)%5])\n        eat()\n        V(chopstick[i])\n        V(chopstick[(i+1)%5])\n        V(count)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n再来演示前面发生 “死锁” 的过程。假如从 0 号进程开始，在他拿到左筷子之后，进程切换到 1 号进程，由于 count 数量充足，所以它不会阻塞，而是同样拿到了左筷子… 以此类推，到了 4 号哲学家的时候，由于 count = -1 < 0 ，所以它此时无法进来。 4 号哲学家左边的筷子在第一轮谁也没拿到，第二轮轮到 3 号哲学家时，就可以拿到这支筷子了。总会存在至少一个进程可以吃到饭。\n\n# 奇数拿左边，偶数拿右边\n\n还可以考虑对拿筷子的优先顺序进行调整。规定对于奇数哲学家，总是先拿左筷子再拿右筷子；对于偶数哲学家，总是先拿右筷子再拿左筷子。那么 0 号哲学家和 1 号哲学家就会争夺 1 号筷子，而 2 号哲学家和 3 号哲学家就会争夺 3 号筷子。如图所示：\n\n\n\n伪代码如下：\n\nPi(){\n    while(1)\n\t{\n\t\tif(i%2 == 0) // 偶数哲学家，先右后左。\n\t\t{\n\t\t\tP(chopstick[(i + 1)%5]) ;\n\t\t\tP(chopstick[i]) ;\n\t\t\teat();\n\t\t\tV(chopstick[(i + 1)%5]) ;\n\t\t\tV(chopstick[i]) ;\n\t\t}\n\t\telse   //奇数哲学家，先左后右。\n\t\t{\n\t\t\tP(chopstick[i]) ;\n\t\t\tP(chopstick[(i + 1)%5]) ;\n\t\t\teat();\n\t\t\tV(chopstick[i]) ;\n\t\t\tV(chopstick[(i + 1)%5]) ;\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n假如从 0 号进程开始，很显然 0 号先拿到 1 号筷子，所以在之后切换进程的时候，1 号进程就会直接被阻塞。接着来到 2 号进程，显然他先拿到 3 号筷子，所以之后轮到 3 号进程的时候，3 号进程直接被阻塞。现在轮到 4 号进程，它优先拿到右边的 0 号筷子，之后进程又切换到其它地方。但是，由于先前 3 号进程已经被阻塞，所以在再次轮到 4 号进程的时候，并没有人和他一起争夺 4 号筷子，换言之，4 号进程可以拿到 4 号筷子，再加上之前优先拿到的 0 号筷子，4 号进程现在就可以吃饭了。\n\n这只是其中一种情况，但无论是哪一种，在一对进程的争抢中必然有一个进程首先被送到阻塞队列，因此这个 “被淘汰的” 进程很难再去影响其它进程，相当于间接提高了其它进程拿到筷子的可能性。就像我们上面的例子一样，一下子 “淘汰了” 1 号和 3 号两个进程，并且这两个进程当时并没有带着筷子进入阻塞队列，所以对于其它进程 2 号、4 号、 0 号来说，再次拿到一支筷子的可能性就大大提高了。所以，我们还是能够达到最初的目的，也就是至少让一个哲学家吃上饭。\n\n\n# 管程\n\n> 信号量机制效率低，且通信对用户不透明\n\n\n# 管程的基本思想\n\n管程 = 共享资源 + 同步操作\n\n\n\n进入管程无法直接访问临界资源，而是通过管程的方法来访问临界资源：\n\n",normalizedContent:"# 进程同步\n\n\n# 基本概念\n\n> 在多道批处理系统中，多个进程是并发执行的，而并发执行的进程不可避免地需要共享一些系统资源（比如内存、打印机、摄像头等）。然而，有些资源在一个时间段内只允许一个进程使用，诸如各种物理设备、变量、数据、内存缓冲区等，这些称之为临界资源 —— 也就是说，一方面，并发执行的进程需要共享资源；另一方面，临界资源的访问又必须是互斥地进行（不能同时共享），很显然，这会导致资源访问上的矛盾。我们通过进程互斥来解决此类问题。\n\n进程同步：指多个相关进程在执行次序上的协调\n\n进程互斥：指在多道程序环境下，每次只允许一个进程对临界资源进行访问\n\n临界资源：一次仅供一个进程使用的资源\n\n临界区：在进程中涉及到临界资源的程序段叫临界区\n\n相关临界区：多个进程的临界区称为相关临界区\n\n\n# 进程互斥的基本实现逻辑\n\n为了实现临界资源的互斥访问，可以在逻辑上将一个进程对临界资源的访问过程分为四个部分：\n\ndo {\n    extry section;       // 进入区\n    critical section;    // 临界区\n    exit section;        // 退出区\n    remainder section;   // 剩余区\n} while(true)\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n * 进入区：a 进程想要访问临界资源，首先会在进入区检查是否可以进入，由于此时没有其它进程占用临界资源，所以检查通过，同时它设置了一个 flag 标志当前自己正在访问临界资源；\n * 临界区：实际访问临界资源的那段代码\n * 退出区：负责解除之前的 flag\n * 剩余区：其它处理\n\n对于 b 进程，如果此时它也想要访问这个资源，同样就会在进入区做一个检查，它知道了 a 进程正在访问，所以自己就不能访问了。这样就实现了资源访问的互斥。\n\n\n# 同步机制应遵循的原则\n\n空闲让进：临界区空闲时，应该让想要进入临界区的进程立刻进来\n\n忙则等待：同一时刻只允许一个进程进入临界区\n\n有限等待：要求访问临界资源的进程，应该保证在有限时间内进入临界区\n\n让权等待：当 a 进程进入临界区而导致 b 进程不能进入自己的临界区时，应该立刻释放处理机，防止进程陷入 “忙等” 状态。\n\n\n# 信号量和 pv 操作\n\n\n# 信号量机制\n\n信号量机制可以让用户通过使用操作系统提供的一对原语来对信号量进行操作，从而方便地实现进程互斥和进程同步。信号量（semaphore）其实就是一个变量，它可以记录系统中某个资源的数量，而原语指的是 wait(s) 原语和 signal(s) 原语（或者说是 p 操作和 v 操作，即通过和释放），可以看作是两个函数。\n\n# 整型信号量\n\n信号量如果单纯是一个整数型的变量，那么就称为整型信号量，它的值记录了系统中某种资源的数量。在使用整型信号量的情况下，p 、v 操作是类似这样的：\n\nint s = 1;\nwait(int s)               \n{                       \n    while(s <= 0)\t\t\t\n    s = s-1              \n}\nsignal(int s)\n{\n    s = s+1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n同样以进程 p0，p1 为例进行说明：\n\np0：                   p1:\nwait(s)                wait(s)            // 进入区\ncritical section       critical section   // 临界区\nsignal(s)              signal(s)          // 退出区 \n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n假定 p0 想要进入临界区，那么它就会在进入区申请资源：执行 p 操作，进行 “检查” 和 “上锁”，由于 s 一开始是 1（表示目前有一个资源可以使用），所以 p0 可以跳过循环，成功申请到资源。此后，s 减一变为 0，代表已经没有可用资源了 —— 这一步也相当于上锁；对于 p1，当他想要申请资源的时候，同样先来到进入区执行 p 操作，由于 s = 0，所以此时 p1 陷入了死循环；再回到 p0 ，他完成任务后会在退出区释放资源，s 加一变为 1，这时候 p1 才有机会退出循环，进而申请资源。\n\n整个过程其实和之前介绍的方法是很类似的，但是由于这次，“检查” 和 “上锁” 两个操作被封装在一个原语里，所以这两个操作必定是一气呵成、无法被打断的，这就避免了某个进程钻空子的现象。但是同时我们也发现，在 p0 时间片用完后，p1 仍然会占用处理机进行没有意义的死循环，也就是仍然违背了 “让权等待” 的原则。\n\n于是在此基础上，又出现了记录型信号量\n\n# 记录型信号量\n\n与整型信号量仅用一个单一变量记录可用资源数不同，记录型信号量的数据结构类似于一个结构体，它不仅记录了可用资源数 value ，而且还提供了一个等待队列 l 。\n\n记录型信号量的思想其实是，如果由于 p0 在使用临界资源而导致 p1 暂时无法使用，那么干脆就不给 p1 陷入循环的机会，直接让它自己去阻塞队列，这样 p1 在被唤醒之前，永远无法占用处理机，也自然就不可能出现白白占用处理机的情况。而在 p0 释放资源后，我们才来考虑唤醒 p1。\n\n记录型信号量的结构如下所示：\n\ntypedef struct {\n    int value\n    sturct process *l\n} semaphore\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n同时，记录型信号量的 p、v 操作也有所不同，如下所示：\n\nwait (semaphore s){\n    s.value--\n    if(s.value < 0){\n        block(s.l)\n    }\n}\nsignal(semaphore s){\n    s.value++\n    if(s.value <= 0){\n        wakeup(s.l)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * 这里要注意的第一个地方是， value 是可用的资源数，当它大于 0 的时候自然是存在可用资源（供大于求），当它小于 0 的时候，则说明不仅无可用资源而且有其他进程等着用（供不应求）。\n * 第二个地方是，在进入区 value 一定会减一，表示申请到了资源，或者表示存在着某个进程有想要申请资源的意愿\n * 执行 ++ 或 -- 前， s.value 为正值时代表可利用的物理资源数； s.value 为负值时，其绝对值代表阻塞队列中等待的进程数。\n\n下面我们用例子来说明记录型信号量工作的过程，为了加深记忆，这里用四个进程来说明：\n\npo:            p1              p2           p3\nwait(s)        wait(s)         wait(s)      wait(s)\n临界区          临界区           临界区        临界区\nsignal(s)      signal(s)       signal(s)    signal(s)\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n假设计算机中有两台可用的打印机 a 和 b（也就是说，value = 2），有四个进程需要用到打印机资源。\n\n一开始假定是 p0 先占有处理机，那么 p0 就会在进入区申请资源 。由于 value 一开始是 2，所以 p0 成功申请到资源 a，之后 value 数量减一变为 1，同时来到临界区开始 “干活”；在 p0 的时间片完了之后，p1 占有处理机，此时同样申请到资源 b，value 由 1 变为 0，之后来到临界区 “干活”。自此，两个打印机都被占用了。\n\n在 p1 的时间片完了之后，p2 占有处理机，value 由 0 变为 -1 < 0，前面我们说过，value < 0 说明无可用资源，所以此时 p2 将自己主动送到了阻塞队列。接着来到了 p3，value 由 -1 变为 -2，p3 同样进入阻塞队列。p2，p3 都从运行态转为阻塞态。\n\n处理机又来到 p0，p0 很快执行完了，于是在退出区执行 p 操作释放资源，将 value 加一变为 -1，之后由于通过 if 检测到阻塞队列中有进程等着用资源，所以马上唤醒了队头的 p2 ，p2 从阻塞态回到就绪态，并直接进入临界区开始自己的工作，在完成后同样来到退出区释放资源，value 由 -1 变为 0，但是在 if 中还是检测到了队列中仍然有进程等着用资源，于是马上把队头的 p3 唤醒，p3 回到就绪态，并直接进入临界区开始工作，此后，value 由 0 变为 1，此时 if 不通过，说明队列中再也没有其它进程等着了，该拿到资源的进程都拿到了。自此，p0，p2，p3 都拿到了 a 资源，而 p1 也在不久后完成工作，在退出区释放资源 b，此时 value 从 1 变回最初的 2 ，代表占用的资源已经全数归还。\n\n当然，实际情况还可能是，p2 拿到了 a 资源，p3 拿到了 b 资源，但分析过程也是大同小异的。\n\n显然，记录型信号量与前面介绍的所有方法最大的区别就在于，不会再有进程白白占用处理机进行没有意义的循环 —— 相反地，这些进程非常 “老实” 地把自己送到了阻塞队列，选择在那里慢慢地等待，等待其它进程完成后将自己唤醒，这种做法 “既方便了别人，也方便了自己”。这就正好与我们多次强调的 “让权等待” 非常契合了。\n\n> 记录型信号量明显优于整型信号量，所以在提到 pv 操作的时候，一般默认指的都是记录型信号量。\n\n我们通过几道题加深一下印象：\n\n * n 个并发进程，信号量初始值为 1，当 n 个进程都执行 p 操作后，信号量的值为多少？\n * 信号量初值为 4，多次 pv 操作后变为 -2，那么获得资源的进程数目是多少？\n * 5 个并发进程，信号量初始值为 3，那么信号量取值范围是多少？\n\n（1）每执行一次 p 操作，信号量就会减一，所以对于 n 个并发进程，共需要执行 n 次 p 操作，所以此后信号量的值是 1-n\n\n（2）信号量值为 -2，说明有两个进程位于阻塞队列，说明暂无空闲资源可用，换句话说，四个资源都被占用了，所以共有四个进程获得资源\n\n（3）信号量初始值为 3，所以最大值为 3，如果 5 个进程都执行 p 操作，那么信号量会变成 3-5 = -2，即最小值为 -2，所以取值范围 -2 ~ 3。\n\n\n# 信号量机制实现\n\n# 进程互斥\n\n其实上面讲的例子就已经很好地实现了进程互斥，但是我们可以简化一下写法，如下：\n\nsemaphore mutex = 1;\np0(){\n    p(mutex) //使用临界资源前需要加锁\n    critical section //临界区代码段\n    v(mutex) //使用临界资源前需要解锁\n}\np1(){\n    p(mutex)\n    critical section //临界区代码段\n    v(mutex)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n我们默认已经定义了 semaphore 的结构体，并用互斥信号量 mutex 记录可用资源的个数（进入临界区的名额），初始值为 1。要实现互斥，关键就是要在临界区之前使用 p 操作进行上锁，在临界区之后使用 v 操作进行解锁。\n\npv 操作要成对出现，但不一定要在同一个进程中。不同的临界资源设置不同的互斥信号量。记录型信号量有时需要自己定义。\n\n# 进程同步\n\n多个进程（如 p1、p2）一起完成某项任务的时候，如何确保它们按照一定的先后顺序（先 p1 后 p2）有秩序地执行呢？信号量机制也可以很好地实现进程同步。它有三个关键步骤：\n\n * 设置同步信号量初始值为 0\n * 在 “前操作” 之后执行 v (s)\n * 在 “后操作” 之前执行 p (s)\n\n首先，0 是一个非常关键的 “分水岭”，大于 0 的时候不会发生阻塞，小于 0 则会发生阻塞。\n\n我们要确保 “前操作” 在前面，“后操作” 在后面，实际上只要做到三件事：v 在 “前操作” 后面、p 在 “后操作” 前面、v 在 p 前面。第一个和第二个条件都是可以通过实际书写代码来做到的，而要达到第三个条件 —— v 在 p 前面，就有必要让信号量初始值为 0，因为一旦初始值为 0，则每当 p 想要 “违规” 抢先于 v 执行的时候，都会由于首先执行信号量自减的操作而导致当前所在进程进入阻塞队列 ，也就是说：\n\np 先于 v 执行 => p 所在进程会被阻塞 => ” 后操作 “始终无法执行\n\n所以，在这种情况下，就只能转而执行 v 所在的进程了。在这个进程里，由于 v 在 “前操作” 后面，所以一定是 “前操作” 执行完了再去执行 v。而执行 v 就会自增信号量，同时唤醒对方进程，对方进程再去顺序执行 p 操作 —— 虽然此时信号量又自减，但是是在加一的基础上自减，所以并不会导致再次阻塞，所以 p 执行完后就顺序执行 “后操作”。由此，我们确保了两个操作一定是严格按照先后顺序执行的。\n\n来看下面的例子：\n\n// 顺序应该是：code1,code2,code4\np0：                 p1:\ncode 1               p(s)\ncode 2               code 4\nv(s)                 code 5\ncode 3               code 6\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n我们设想比较差的情况 —— p1 想要抢先执行 code 4，看看会发生什么。假设是 p1 首先占用处理机，那么就会执行 p 操作，这个操作使得信号量由 0 变成 -1，进而进入 if 代码块，使得 p1 进程阻塞；这之后，处理机来到 p0，执行 code1，code2，v 操作，使得信号量由 -1 变成 0，同时唤醒 p1 进程；p1 进程被唤醒后从 p 操作之后的断点继续执行（p1 被唤醒后不会重新再执行一遍 p 操作，否则会再次进入阻塞。与七态中进程所需资源得到满足后会从阻塞队列转入就绪队列相同，p1 会接着之前停下的地方继续），来到 code4。以上，整个过程确保了按照 code1，code2，code4 的顺序执行。\n\n# 前驱关系\n\n前面描述的都是两个进程的同步问题，但有时候也可能出现像下图这样多个进程互相依赖、有序运行的情况。其中，code 语句仍然是前操作或者后操作，p1 进程有 code1 语句，p2 进程有 code2 语句… 以此类推，这里要求六个进程必须按照箭头所指方向有序运行。\n\n\n\n其实这种情况就是把多个同步问题结合起来，我们仍然可以用信号量机制来实现：\n\n * 每一个前驱关系都是一个同步问题，要保证一前一后的操作\n * 为每一个前驱关系各设置一个同步信号量\n * 在 “前操作” 之后对相应的同步信号量执行 v 操作\n * 在 “后操作” 之前对相应的同步信号量执行 p 操作\n\n代码大概如下：\n\np1:          p2:          p3:          p4:        \ncode1        p(signal1)   p(signal2)   p(signal3)\nv(signal1)   code2        code3        code4 \nv(signal2)   v(signal3)   v(signal7)   v(signal5)\n             v(signal4)\np5:          p6:         \np(signal4)   p(signal5)   \ncode5        p(signal6) \nv(signal6)   p(signal7)\n             code6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n可以观察到，除了 p1 进程之外，其它进程首先执行的都是 p 操作，所以一旦这些进程之一首先拿到处理机使用权，都无一例外地会进入阻塞队列。由于情况很多，这里我们试着只分析某一种情况 ——\n\n假设一开始是 p2 占有处理机，那么由于 signal1 初始为 0，导致了 p2 进队列，此后处理机来到 p3，p3 同样进队列… 以此类推，阻塞队列就会变成：\n\n\n\n随后总算来到 p1 进程了，p1 进程作为一切的开始，特殊之处就在于它不是以 p 操作开始的，p1 会首先执行 v (signal1)，这一步把 signal1 加一，同时唤醒 p2 进程，p2 进程进入就绪队列：\n\n\n\n再之后，p1 执行 v (signal2)，这一步把 signal2 加一，同时唤醒 p3 进程，p3 进程也进入就绪队列。\n\n\n\np1 执行完之后，就绪队列队头的 p2 进入运行态，执行到 v (signal3) 的时候，signal3 加一，同时唤醒 p4 进程，p4 进程进入就绪队列，\n\n\n\n再之后，p2 执行 v (signal4)，这一步把 signal4 加一，同时唤醒 p5 进程，p5 进程也进入就绪队列。\n\n\n\np2 执行完之后，处理机调度就绪队列队头的 p3 开始执行，p3 执行到 v (signal7) 的时候，signal7 加一，注意这一步没有唤醒任何进程\n\n\n\np3 执行完之后，处理机调度就绪队列队头的 p4 开始执行，p4 执行到 v (signal5) 的时候，signal5 加一，同时唤醒 p6 进程，p6 进程进入就绪队列\n\n\n\np4 执行完之后，处理机调度就绪队列队头的 p5 开始执行，p5 执行到 v (signal6) 的时候，signal6 加一，注意这一步没有唤醒任何进程（阻塞队列已经没有进程了）\n\n\n\np5 执行完之后，处理机调度就绪队列队头的 p6 开始执行，p6 的 signal6 、signal7 在前面已经得到加一操作，所以此时绝对不会在这里卡住，可以顺利执行，直到结束。\n\n\n\n这样基本就把整个流程过了一遍，当然，经过排列组合之后，分析过程都是大同小异的。\n\n\n# 信号量和 pv 操作解决进程同步问题\n\n\n# 生产者 - 消费者\n\n生产者 - 消费者问题是系统中并发进程内在关系的一种抽象，是典型的进程同步问题。生产者进程 p1 可以是计算进程、发送进程；而消费者进程 p2 可以是打印进程、接收进程等等。\n\n> 有界缓冲：\n> \n>  * 一个生产者一次放入缓冲区一个产品，且无限次循环\n>  * 一个消费者一次取出缓冲区一个产品，且无限次循环\n>  * 两个进程独立\n> \n> 要解决的问题：\n> \n>  * 缓冲池满生产者不能放产品\n>  * 缓冲池空消费者不能取产品\n>  * 只能一个生产者或者消费者对缓冲区进行操作\n\n进程个数：2\n\n关系分析：\n\n * 互斥关系 p1、p2 互斥访问缓冲区\n * 同步关系 p1 生产后 p2 才能消费\n\n信号量设置：\n\n * 互斥信号量 mutex = 1 ，实现对缓冲区这个资源的互斥访问\n * 同步信号量 empty = n ，表示空闲缓冲区的数量\n * 同步信号量 full = 0 ，表示非空闲缓冲区的数量，也即产品数量\n\n产品： p1 v p2 p （v 增加，p 锁定，生产者放入产品，消费者取出产品）\n\n空间： p1 p p2 v\n\n先考虑对互斥关系的实现。这里的临界资源是缓冲区，生产者进程把产品放进去，消费者进程从里面取走产品，这两者不能同时进行，所以这里是互斥的关系。p1、p2 都各有一对 pv 操作，用以实现对缓冲区资源的访问。另外，生产者在进行 pv 操作之前，必定要先生产产品；而消费者在进行 pv 操作之后，必定要使用产品。这时候，初步的伪代码是这样的：\n\nproducer(){                         consumer(){\n    while(1){                           while(1){\n        生产产品                              p(mutex)\n        p(mutex)                             从缓冲区中取走产品 \n\t\t把产品放入缓冲区                       v(mutex)\n        v(mutex)                             使用产品 \n    }                                   }\n}                                   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n接着考虑第一个同步关系，关注空缓冲区。先释放缓冲区，后使用缓冲区，且缓冲区满不再放入产品，所以这里 “前操作” 是消费者释放缓冲区，“后操作” 是生产者占用缓冲区，根据 “前 v 后 p”，我们需要在 “前操作” 之后针对 empty 这个信号量进行一次 v 操作，需要在 “后操作” 之前针对 empty 进行一次 p 操作。生产者执行 p 操作检查是否还有空缓冲区时，若缓冲区已满，将进入阻塞。所以，这时候代码变成：\n\nproducer(){                         consumer(){\n    while(1){                           while(1){\n        生产产品                             p(mutex)\n        p(empty)                            从缓冲区中取走产品 \n\t\tp(mutex)                            v(mutex)\n        把产品放入缓冲区                      v(empty)  \n        v(mutex)                            使用产品 \n    }                                   }     \n}                                   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n再考虑第二个同步关系，关注产品。先生产产品并将其放入缓冲区，后从缓冲区取出产品并使用。这里划分出前后两个操作，所以再安排一对 pv 操作：\n\nproducer(){                         consumer(){\n    while(1){                           while(1){\n        生产产品                            p(full)\n        p(empty)                           p(mutex)\n\t\tp(mutex)                           从缓冲区中取走产品 \n        把产品放入缓冲区                     v(mutex) \n        v(mutex)                           v(empty)  \n        v(full)                            使用产品 \n    }                                   }     \n}                                   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这就是最后的代码了。现在我们试着跑一下流程：初始的时候 empty = n，表示所有缓冲区都是空闲的，同时 full = 0，表示一个产品都没生产出来。假如处理机首先来到 consumer 进程，那么就会通过 p(full) 检查是否有产品，这里当然是没有，所以它只能进行等待；处理机来到 producer，首先通过 p(empty) 检查是否有空闲缓冲区，这里当然有，于是它开始把生产的产品放入缓冲区，随后记录产品的数量，这个过程可以反复进行，直到所有缓冲区都被占用了，此时 producer 就会进入等待状态，等待 consumer 进程取出产品、释放缓冲区；当然还有可能的情况是，producer 尚未占用完所有缓冲区，进程就切换到 consumer 了，那么这时候 consumer 因为检查到有产品，所以也会取出产品、释放缓冲区。\n\n> p 操作不可以随意对调位置，v 操作可以。\n\n这里要注意可能会引起 “死锁” 现象的一种写法。如下所示：\n\nproducer(){                         consumer(){\n    while(1){                           while(1){\n        生产产品                            p(mutex)\n        p(mutex)                           p(full)\n\t\tp(empty)                           从缓冲区中取走产品 \n        把产品放入缓冲区                     v(mutex) \n        v(mutex)                           v(empty)  \n        v(full)                            使用产品 \n    }                                   }     \n}                                   }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这个写法的问题在于，还没有先检查缓冲区是否没满或者是否非空，就强行进行互斥的 “上锁”。假如还是按照前面的流程，一开始处理机在 consumer 这里，那么 consumer 实际上在没有检查缓冲区是否非空的情况下就直接 “上锁” 了，这导致它在 p(full) 这一步的时候被卡住，只能等待，而在之后切换到 producer 的时候，正常情况下他应该生产可供对方消费的产品，但是由于对方已经上了锁，所以 producer 在 p(mutex) 这一步也被卡住了，只能进行等待。这也就是说，producer 等待 consumer 释放临界区，而 consumer 等待 producer 使用缓冲区，双方陷入循环等待，造成了 “死锁”。\n\n另一种情况，我们也可以设想一开始处理机是在 producer 这里，依然会导致 “死锁”。按照这种情况正常用完全部缓冲区之后，如果处理机还是在 producer 这里，那么 producer 在检查缓冲区是否已满之前也会将自己提前上锁，在 p(empty) 这一步陷入等待，之后即使进程切换到 consumer 这里，它也会因为对方提前上锁，而导致自己在 p(mutex) 这一步陷入等待。也就是说，这不过是前面那种” 死锁 “现象的翻版。\n\n总之，关键就在于不管是消费者进程，还是生产者进程，都不能先上锁再检查，否则就有可能发生死锁。\n\n\n# 苹果橘子问题\n\n盘子 缓冲区\n\n2 水果 2 产品\n\n爸爸 妈妈 2 生产者，p1 p2\n\n儿子 女儿 2 消费者，c1 c2\n\n进程个数：4\n\n关系分析：\n\n * 互斥关系 p1、p2、c1、c2 互斥访问缓冲区\n * 同步关系 p1 生产后 c1 才能消费，p2 生产后 c2 才能消费\n\n信号量设置：\n\n * 互斥信号量 mutex = 1 ，实现对缓冲区这个资源的互斥访问\n * 同步信号量 apple = 0 ，表示苹果的数量\n * 同步信号量 orange = 0 ，表示橘子的数量\n\n产品： p1 p2 v c1 c2 p （v 增加，p 锁定，生产者放入产品，消费者取出产品）\n\n空间： p1 p2 p c1 c2 v\n\np1(){\n  while(1){\n      p(mutex)\n      把苹果放入盘子\n      v(apple)\n  }\n}\np2(){\n  while(1){\n      p(mutex)\n      把橘子放入盘子\n      v(orange)\n  }\n}\nc1(){\n   while(1){\n       p(apple)\n       从盘子中取走苹果\n       v(mutex)\n }\nc2(){\n  while(1){\n       p(orange)\n       从盘子中取走橘子\n       v(mutex)\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 银行问题\n\n\n\n顾客的 v (full) 与 p (service) 应调换位置，并去除 “获取服务”\n\nservice 默认值应为 1\n\n\n# 五个哲学家进餐问题\n\n一张圆桌，五个哲学家，五支筷子（每两个哲学家中间会有一支筷子），哲学家要么思考，要么吃饭，吃饭前会拿起左右两边的筷子，吃饭后会放下筷子。如果筷子被其它哲学家拿走，则自己需要等待。我们的目的很简单：保证所有哲学家都有机会吃上饭，不能让一个或者多个哲学家始终无法吃饭。\n\n\n\n\n\n如果哲学家 0 号拿起左右筷子后，进程切换到哲学家 1 号，那么 1 号是会被阻塞的，所以这样相邻的哲学家中有一个可以吃饭。但是，如果 0 号拿起左筷子后进程切换到 1 号，1 号也拿起自己的左筷子，以此类推，所有的哲学家都只有左筷子，这导致了所有的哲学家都被阻塞，没有任何哲学家能够吃饭，也没有人可以释放筷子，使这些哲学家都陷入无限的等待中，造成 “死锁” 的发生。\n\n解决这个问题有三个方法：\n\n# 实现原子操作\n\n很容易想到，拿起左筷子和拿起右筷子并不是一个原子操作。准备一个互斥信号量 mutex = 1 ，并把拿筷子的操作封装在一个 pv 操作里。代码如下：\n\npi(){\n    while(1){\n        p(mutex)\n        p(chopstick[i])\n        p(chopstick[(i+1)%5])\n        v(mutex)\n        eat()\n        v(chopstick[i])\n        v(chopstick[(i+1)%5])\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在 0 号哲学家拿起左筷子之后，即使发生进程切换，1 号进程也会被卡在 mutex 的 p 操作，被送往阻塞队列，其它进程也同理。所以最后再次来到 0 号进程时便可以顺利拿起右筷子。这种做法保证了有一个哲学家是可以吃饭的。\n\n> 这里涉及到了一个进程需要一次性两个资源才能完成任务的问题，也可以使用 and 信号量集机制。and 信号量集机制的 p 操作是一个相对苛刻的操作，要求一个进程要么拿到全部资源，要么一个资源也拿不到。一开始筷子数量足够，所以 0 号在一开始就可以一次性拿到左右筷子。同理，在释放筷子的时候，也是一次性释放两支筷子。代码如下：\n> \n> pi(){\n>     while(1){\n>         swait(chopstick[(i+1)%5],chopstick[i]);\n>         eat()\n>         ssignal(chopstick[(i+1)%5],chopstick[i]);\n>     }\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n\n# 只有四个人参与这个过程\n\n之前的情况是五个哲学家，五支筷子，所以容易出现谁也无法吃饭的情况，但是如果规定整个过程最多只有四个哲学家参与，即使这四个哲学家每个人都拿走了一支筷子，也还剩下一支筷子可以分配给某个哲学家。\n\n如何限定 “最多四个人可以参与这个过程” 呢？准备一个互斥信号量 count ，但是这个信号量初值不再是 1 ，而是 4，表示最多允许四个哲学家参与过程。当 count 减少到 -1 的时候，就不能再让哲学家进来了。代码如下：\n\npi(){\n    while(1){\n        p(count)\n        p(chopstick[i])\n        p(chopstick[(i+1)%5])\n        eat()\n        v(chopstick[i])\n        v(chopstick[(i+1)%5])\n        v(count)\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n再来演示前面发生 “死锁” 的过程。假如从 0 号进程开始，在他拿到左筷子之后，进程切换到 1 号进程，由于 count 数量充足，所以它不会阻塞，而是同样拿到了左筷子… 以此类推，到了 4 号哲学家的时候，由于 count = -1 < 0 ，所以它此时无法进来。 4 号哲学家左边的筷子在第一轮谁也没拿到，第二轮轮到 3 号哲学家时，就可以拿到这支筷子了。总会存在至少一个进程可以吃到饭。\n\n# 奇数拿左边，偶数拿右边\n\n还可以考虑对拿筷子的优先顺序进行调整。规定对于奇数哲学家，总是先拿左筷子再拿右筷子；对于偶数哲学家，总是先拿右筷子再拿左筷子。那么 0 号哲学家和 1 号哲学家就会争夺 1 号筷子，而 2 号哲学家和 3 号哲学家就会争夺 3 号筷子。如图所示：\n\n\n\n伪代码如下：\n\npi(){\n    while(1)\n\t{\n\t\tif(i%2 == 0) // 偶数哲学家，先右后左。\n\t\t{\n\t\t\tp(chopstick[(i + 1)%5]) ;\n\t\t\tp(chopstick[i]) ;\n\t\t\teat();\n\t\t\tv(chopstick[(i + 1)%5]) ;\n\t\t\tv(chopstick[i]) ;\n\t\t}\n\t\telse   //奇数哲学家，先左后右。\n\t\t{\n\t\t\tp(chopstick[i]) ;\n\t\t\tp(chopstick[(i + 1)%5]) ;\n\t\t\teat();\n\t\t\tv(chopstick[i]) ;\n\t\t\tv(chopstick[(i + 1)%5]) ;\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n假如从 0 号进程开始，很显然 0 号先拿到 1 号筷子，所以在之后切换进程的时候，1 号进程就会直接被阻塞。接着来到 2 号进程，显然他先拿到 3 号筷子，所以之后轮到 3 号进程的时候，3 号进程直接被阻塞。现在轮到 4 号进程，它优先拿到右边的 0 号筷子，之后进程又切换到其它地方。但是，由于先前 3 号进程已经被阻塞，所以在再次轮到 4 号进程的时候，并没有人和他一起争夺 4 号筷子，换言之，4 号进程可以拿到 4 号筷子，再加上之前优先拿到的 0 号筷子，4 号进程现在就可以吃饭了。\n\n这只是其中一种情况，但无论是哪一种，在一对进程的争抢中必然有一个进程首先被送到阻塞队列，因此这个 “被淘汰的” 进程很难再去影响其它进程，相当于间接提高了其它进程拿到筷子的可能性。就像我们上面的例子一样，一下子 “淘汰了” 1 号和 3 号两个进程，并且这两个进程当时并没有带着筷子进入阻塞队列，所以对于其它进程 2 号、4 号、 0 号来说，再次拿到一支筷子的可能性就大大提高了。所以，我们还是能够达到最初的目的，也就是至少让一个哲学家吃上饭。\n\n\n# 管程\n\n> 信号量机制效率低，且通信对用户不透明\n\n\n# 管程的基本思想\n\n管程 = 共享资源 + 同步操作\n\n\n\n进入管程无法直接访问临界资源，而是通过管程的方法来访问临界资源：\n\n",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"队列调度模型",frontmatter:{title:"队列调度模型",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/053628/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/04.%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/03.%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B.html",relativePath:"01.操作系统/04.第三章 处理机调度与死锁/03.队列调度模型.md",key:"v-438f4343",path:"/pages/053628/",headers:[{level:2,title:"仅有进程调度的队列模型",slug:"仅有进程调度的队列模型",normalizedTitle:"仅有进程调度的队列模型",charIndex:13},{level:2,title:"具有高级调度和低级调度的调度队列模型",slug:"具有高级调度和低级调度的调度队列模型",normalizedTitle:"具有高级调度和低级调度的调度队列模型",charIndex:126},{level:2,title:"具有三级调度的调度队列模型",slug:"具有三级调度的调度队列模型",normalizedTitle:"具有三级调度的调度队列模型",charIndex:166}],headersStr:"仅有进程调度的队列模型 具有高级调度和低级调度的调度队列模型 具有三级调度的调度队列模型",content:"# 队列调度模型\n\n\n# 仅有进程调度的队列模型\n\n\n\n分时操作系统没有后备作业队列，所以没有高级调度；又因为此系统的应用范围大多只是查询，分配的任务比较简单，以时间片轮转的方式执行终端的任务，所以没有中级调度。也即分时操作系统只有低级调度。\n\n\n# 具有高级调度和低级调度的调度队列模型\n\n\n\n看到这张图，要想到五态转换\n\n\n# 具有三级调度的调度队列模型\n\n\n\n看到这张图，要想到七态转换",normalizedContent:"# 队列调度模型\n\n\n# 仅有进程调度的队列模型\n\n\n\n分时操作系统没有后备作业队列，所以没有高级调度；又因为此系统的应用范围大多只是查询，分配的任务比较简单，以时间片轮转的方式执行终端的任务，所以没有中级调度。也即分时操作系统只有低级调度。\n\n\n# 具有高级调度和低级调度的调度队列模型\n\n\n\n看到这张图，要想到五态转换\n\n\n# 具有三级调度的调度队列模型\n\n\n\n看到这张图，要想到七态转换",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"处理机调度的层次",frontmatter:{title:"处理机调度的层次",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/9cf689/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/04.%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/02.%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1.html",relativePath:"01.操作系统/04.第三章 处理机调度与死锁/02.处理机调度的层次.md",key:"v-3decb41e",path:"/pages/9cf689/",headers:[{level:2,title:"三级调度",slug:"三级调度",normalizedTitle:"三级调度",charIndex:17},{level:3,title:"作业调度",slug:"作业调度",normalizedTitle:"作业调度",charIndex:26},{level:3,title:"内存调度",slug:"内存调度",normalizedTitle:"内存调度",charIndex:167},{level:3,title:"进程调度",slug:"进程调度",normalizedTitle:"进程调度",charIndex:360}],headersStr:"三级调度 作业调度 内存调度 进程调度",content:"# 处理机调度的层次\n\n\n\n\n# 三级调度\n\n\n# 作业调度\n\n作业调度也即高级调度，这个阶段可以看作是准备阶段。主要任务是根据某种算法从外存上处于后备队列的作业中挑选一个或多个作业，为其分配内存，建立 PCB（进程） 等，使它们具备竞争处理机的能力。\n\n这个阶段进程的状态变化是：无 --\x3e 创建态 --\x3e 就绪态\n\n> \n\n\n# 内存调度\n\n内存调度也即中级调度，这个阶段可以看作是优化阶段。主要任务是将暂时不能运行的进程对换到外存（虚拟内存）中，使它们挂起；而当挂起的进程具备运行条件时，它们会被重新对换回内存，得到激活。引入中级调度的主要目的是提高内存利用率和系统吞吐量，它实际上就是存储器管理中的对换功能。\n\n这个阶段进程的状态变化是： 静止就绪态 --\x3e 活动就绪态，静止阻塞态 --\x3e 活动阻塞态\n\n\n# 进程调度\n\n进程调度即低级调度，这个阶段让进程真正运行起来。主要任务是按照某种算法，从就绪队列中选取一个进程（内核级线程），分配处理机给它。进程调度是最基本、次数最频繁的阶段。\n\n这个阶段进程的状态变化是： 就绪态 --\x3e 活动态\n\n> 根据进程运行的过程中，处理机能否被其它进程抢占，将调度分为两种方式：非抢占式和抢占式，为抢占式时，抢占原则有：优先权原则、短作业（进程）优先原则、时间片原则。\n> \n> 抢占式的缺点在于进程切换频繁发生，系统开销大。优点在于对短作业而言能更及时的得到调度。",normalizedContent:"# 处理机调度的层次\n\n\n\n\n# 三级调度\n\n\n# 作业调度\n\n作业调度也即高级调度，这个阶段可以看作是准备阶段。主要任务是根据某种算法从外存上处于后备队列的作业中挑选一个或多个作业，为其分配内存，建立 pcb（进程） 等，使它们具备竞争处理机的能力。\n\n这个阶段进程的状态变化是：无 --\x3e 创建态 --\x3e 就绪态\n\n> \n\n\n# 内存调度\n\n内存调度也即中级调度，这个阶段可以看作是优化阶段。主要任务是将暂时不能运行的进程对换到外存（虚拟内存）中，使它们挂起；而当挂起的进程具备运行条件时，它们会被重新对换回内存，得到激活。引入中级调度的主要目的是提高内存利用率和系统吞吐量，它实际上就是存储器管理中的对换功能。\n\n这个阶段进程的状态变化是： 静止就绪态 --\x3e 活动就绪态，静止阻塞态 --\x3e 活动阻塞态\n\n\n# 进程调度\n\n进程调度即低级调度，这个阶段让进程真正运行起来。主要任务是按照某种算法，从就绪队列中选取一个进程（内核级线程），分配处理机给它。进程调度是最基本、次数最频繁的阶段。\n\n这个阶段进程的状态变化是： 就绪态 --\x3e 活动态\n\n> 根据进程运行的过程中，处理机能否被其它进程抢占，将调度分为两种方式：非抢占式和抢占式，为抢占式时，抢占原则有：优先权原则、短作业（进程）优先原则、时间片原则。\n> \n> 抢占式的缺点在于进程切换频繁发生，系统开销大。优点在于对短作业而言能更及时的得到调度。",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"选择调度算法的原则",frontmatter:{title:"选择调度算法的原则",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/79d126/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/04.%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/04.%E9%80%89%E6%8B%A9%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E5%88%99.html",relativePath:"01.操作系统/04.第三章 处理机调度与死锁/04.选择调度算法的原则.md",key:"v-9583bd3c",path:"/pages/79d126/",headers:[{level:2,title:"面向用户的准则",slug:"面向用户的准则",normalizedTitle:"面向用户的准则",charIndex:16},{level:3,title:"周转时间",slug:"周转时间",normalizedTitle:"周转时间",charIndex:28},{level:3,title:"响应时间",slug:"响应时间",normalizedTitle:"响应时间",charIndex:300},{level:3,title:"截止时间",slug:"截止时间",normalizedTitle:"截止时间",charIndex:428},{level:3,title:"优先权准则",slug:"优先权准则",normalizedTitle:"优先权准则",charIndex:479},{level:2,title:"面向系统的准则",slug:"面向系统的准则",normalizedTitle:"面向系统的准则",charIndex:489}],headersStr:"面向用户的准则 周转时间 响应时间 截止时间 优先权准则 面向系统的准则",content:"# 选择调度算法的原则\n\n\n# 面向用户的准则\n\n\n# 周转时间\n\n面向批处理 OS\n\n周转时间： 作业完成时刻 - 作业提交时刻 = 作业实际运行的时间 + 等待时间\n\n> 等待时间包括在后备队列上等待作业调度的时间、进程在就绪队列上等待进程调度的时间、等待 I/O 操作完成的时间。作业实际运行的时间即进程在 CPU 上执行的时间。周转时间是衡量批处理 OS 性能的重要指标。\n\n平均周转时间： 各作业周转时间之和 / 作业数\n\n带权周转时间： 周转时间 / 作业实际运行的时间 （>=1，比周转时间更能衡量一个调度算法的优劣）\n\n平均带权周转时间： 各作业带权周转时间之和 / 作业数\n\n\n# 响应时间\n\n面向分时 OS\n\n响应时间：从用户提交请求到首次产生响应所用的时间，或者说，直到屏幕上显示出结果为止的一段时间间隔。包括从键盘输入的请求信息传送到处理机的时间、处理机对请求信息进行处理的时间、将所形成的响应时间回送到终端显示器的时间。\n\n\n# 截止时间\n\n面向实时 OS\n\n截止时间：指某任务必须开始执行的最迟时间，或必须完成的最迟时间\n\n\n# 优先权准则\n\n\n# 面向系统的准则\n\n系统吞吐量： 完成作业量 / 总时间\n\nCPU 利用率： 忙碌的时间 / 总时间\n\n公平性：确保每个用户每个进程获得合理的 CPU 份额，不会出现饿死情况。",normalizedContent:"# 选择调度算法的原则\n\n\n# 面向用户的准则\n\n\n# 周转时间\n\n面向批处理 os\n\n周转时间： 作业完成时刻 - 作业提交时刻 = 作业实际运行的时间 + 等待时间\n\n> 等待时间包括在后备队列上等待作业调度的时间、进程在就绪队列上等待进程调度的时间、等待 i/o 操作完成的时间。作业实际运行的时间即进程在 cpu 上执行的时间。周转时间是衡量批处理 os 性能的重要指标。\n\n平均周转时间： 各作业周转时间之和 / 作业数\n\n带权周转时间： 周转时间 / 作业实际运行的时间 （>=1，比周转时间更能衡量一个调度算法的优劣）\n\n平均带权周转时间： 各作业带权周转时间之和 / 作业数\n\n\n# 响应时间\n\n面向分时 os\n\n响应时间：从用户提交请求到首次产生响应所用的时间，或者说，直到屏幕上显示出结果为止的一段时间间隔。包括从键盘输入的请求信息传送到处理机的时间、处理机对请求信息进行处理的时间、将所形成的响应时间回送到终端显示器的时间。\n\n\n# 截止时间\n\n面向实时 os\n\n截止时间：指某任务必须开始执行的最迟时间，或必须完成的最迟时间\n\n\n# 优先权准则\n\n\n# 面向系统的准则\n\n系统吞吐量： 完成作业量 / 总时间\n\ncpu 利用率： 忙碌的时间 / 总时间\n\n公平性：确保每个用户每个进程获得合理的 cpu 份额，不会出现饿死情况。",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"调度算法",frontmatter:{title:"调度算法",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/e86493/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/04.%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/05.%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.html",relativePath:"01.操作系统/04.第三章 处理机调度与死锁/05.调度算法.md",key:"v-60ef5aff",path:"/pages/e86493/",headers:[{level:2,title:"先来先服务(FCFS)调度算法（作业调度+进程调度）",slug:"先来先服务-fcfs-调度算法-作业调度-进程调度",normalizedTitle:"先来先服务 (fcfs) 调度算法（作业调度 + 进程调度）",charIndex:11},{level:2,title:"最短作业(SJF)调度算法（作业调度+进程调度）",slug:"最短作业-sjf-调度算法-作业调度-进程调度",normalizedTitle:"最短作业 (sjf) 调度算法（作业调度 + 进程调度）",charIndex:133},{level:2,title:"高响应比优先(HRRN)调度算法（作业调度+进程调度）",slug:"高响应比优先-hrrn-调度算法-作业调度-进程调度",normalizedTitle:"高响应比优先 (hrrn) 调度算法（作业调度 + 进程调度）",charIndex:439},{level:3,title:"例题1",slug:"例题1",normalizedTitle:"例题 1",charIndex:887},{level:3,title:"例题2",slug:"例题2",normalizedTitle:"例题 2",charIndex:1076},{level:2,title:"高优先权(FPF)调度算法（作业调度+进程调度）",slug:"高优先权-fpf-调度算法-作业调度-进程调度",normalizedTitle:"高优先权 (fpf) 调度算法（作业调度 + 进程调度）",charIndex:1599},{level:3,title:"非抢占式优先权算法",slug:"非抢占式优先权算法",normalizedTitle:"非抢占式优先权算法",charIndex:1632},{level:3,title:"抢占式优先权算法",slug:"抢占式优先权算法",normalizedTitle:"抢占式优先权算法",charIndex:1633},{level:3,title:"静态优先权",slug:"静态优先权",normalizedTitle:"静态优先权",charIndex:1791},{level:3,title:"动态优先权",slug:"动态优先权",normalizedTitle:"动态优先权",charIndex:1893},{level:3,title:"例题1",slug:"例题1-2",normalizedTitle:"例题 1",charIndex:887},{level:2,title:"时间片轮转(RR)调度算法（进程调度）",slug:"时间片轮转-rr-调度算法-进程调度",normalizedTitle:"时间片轮转 (rr) 调度算法（进程调度）",charIndex:2492},{level:3,title:"例题1",slug:"例题1-3",normalizedTitle:"例题 1",charIndex:887},{level:2,title:"多级反馈调度算法（进程调度）",slug:"多级反馈调度算法-进程调度",normalizedTitle:"多级反馈调度算法（进程调度）",charIndex:2924},{level:3,title:"例题1",slug:"例题1-4",normalizedTitle:"例题 1",charIndex:887},{level:3,title:"例题2（只有3个就绪队列的例题1）",slug:"例题2-只有3个就绪队列的例题1",normalizedTitle:"例题 2（只有 3 个就绪队列的例题 1）",charIndex:3727}],headersStr:"先来先服务(FCFS)调度算法（作业调度+进程调度） 最短作业(SJF)调度算法（作业调度+进程调度） 高响应比优先(HRRN)调度算法（作业调度+进程调度） 例题1 例题2 高优先权(FPF)调度算法（作业调度+进程调度） 非抢占式优先权算法 抢占式优先权算法 静态优先权 动态优先权 例题1 时间片轮转(RR)调度算法（进程调度） 例题1 多级反馈调度算法（进程调度） 例题1 例题2（只有3个就绪队列的例题1）",content:"# 调度算法\n\n\n# 先来先服务 (FCFS) 调度算法（作业调度 + 进程调度）\n\n\n\n> 周转时间 = 完成时间 - 到达时间\n> \n> 带权周转时间 = 周转时间 / 服务时间\n\n\n\nFCFS 算法对长作业（CPU 时间长的作业）有利，对短作业不利。\n\n\n# 最短作业 (SJF) 调度算法（作业调度 + 进程调度）\n\n\n\n对这个情况而言，SJF 比 FCFS 更好，尤其是 C。\n\nSJF 调度算法也存在不容忽视的缺点：\n\n * 该算法对长作业不利，更严重的是，如果有一长作业（进程）进入系统的后备队列（就绪队列），由于调度程序总是优先调度那些（即使是后进来的）短作业（进程），将导致长作业（进程）长期不被调度。\n * 该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业（进程）会被及时处理。\n * 由于作业（进程）的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。\n\n\n# 高响应比优先 (HRRN) 调度算法（作业调度 + 进程调度）\n\n> HRRN (Highest Response Ratio Next) = HRRF (Highest Response Ratio First)\n> \n> NUIST 老师习惯用 HRRF，我觉得 HRRN 更合适\n\nFCFS 与 SJF 是片面的调度算法。FCFS 只考虑作业等候时间而忽视了作业的计算时间问题；SJF 只考虑用户估计的作业计算时间而忽视了作业等待时间。\n\nHRRN 是介乎这两者之间的非剥夺式算法，既考虑作业等待时间，又考虑作业的运行时间，既照顾短作业又不使长作业的等待时间过长，改进了调度性能。\n\n响应比（带权周转时间） = 作业周转时间 / 作业处理时间 = （作业等待时间 + 作业处理时间） / 作业处理时间 = 1 + 作业等待时间 / 作业处理时间\n\n * 短作业容易得到较高响应比（分母小）\n * 长作业等待时间足够长后，也将获得足够高的响应比（分子足够大）\n * 饥饿现象不会发生\n\n\n# 例题 1\n\n\n\n首先调度 J1，然后计算响应比：\n\nJ2 1+15/15=2\nJ3 1+10/5=3\nJ4 1+5/10=1.5\n\n\n1\n2\n3\n\n1\n2\n3\n\n\nJ3 的响应比最大，调度 J3。随后计算 J3 完成后的响应比：\n\nt=20+5\nJ2 1+20/15=2.3\nJ4 1+10/10=2\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n所以调用 J2，最后调用 J4。\n\n\n# 例题 2\n\n\n\nFCFS J1 2 3 4\n8 10 2 1\n10 10.5 1.5+1/6 (1.5+1/6)/0.5=3.3\n10.5 10.6 1.6 1.6/0.1=16\n10.6 10.8 0.8+2/3 (0.8+2/3)/0.2=7.3\n(2+1.5+1/6+1.6+0.8+2/3)/4=1.68\n(1+(1.5+1/6)/0.5+1.6/0.1+(0.8+2/3)/0.2)/4=6.92\nSJF J1 3 4 2\n8 10 2 1\n10.3 10.8 1.8+1/6 (1.8+1/6)/0.5=3.93\n10 10.1 1.1 1.1/0.1=11\n10.1 10.3 0.3+2/3 (0.3+2/3)/0.2=4.83\n(2+1.8+1/6+1.1+0.3+2/3)/4=1.51\n(1+(1.8+1/6)/0.5+1.1/0.1+(0.3+2/3)/0.2)/4=5.19\nHRRF J1 \n8 10 2 1\n(10) J2 未完成\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 高优先权 (FPF) 调度算法（作业调度 + 进程调度）\n\n\n# 非抢占式优先权算法\n\n和 HRRN 算法很像，进程会正常运行，直到结束之后才发生调度，在调度的时候会选择队列中优先级最高的进程。\n\n\n# 抢占式优先权算法\n\n除了正常运行结束会发生调度之外，每次就绪队列有新的进程到达时还会做一次检查，如果新到达进程优先级高于正在运行进程的优先级，那么新到达进程会抢占处理机。\n\n\n# 静态优先权\n\n静态优先级，指的是进程的优先级在它创建的时候就确定了，此后一直不会改变。一般认为系统进程优先级要高于用户进程优先级；前台进程优先级高于后台进程优先级；I/O 型进程优先级会比较高。\n\n\n# 动态优先权\n\n动态优先级，会尽量遵循公平的原则。也就是说，如果某个进程实在等得太久，那么不妨提高它的优先级，让他有机会被调度；反之，如果某个进程占用处理机时间过长，那么就要考虑降低它的优先级，不要让他一直 “霸占” 处理机了。另外，之前说过 I/O 型进程的优先级会很高，所以如果某个进程频繁进行 I/O 操作，也可以考虑提高它的优先级。\n\n优先级算法的优点在于区分了各个进程的紧急程度，比较紧急重要的进程会优先得到处理，因此它适用于实时操作系统。另外，由于动态优先级的存在，使得它对进程的调度相对灵活很多。缺点则是，如果源源不断进来了一些高优先级的进程，那么优先级相对较低的进程可能一直无法执行，进而导致饥饿现象的发生。这点和 HRRN 算法也是很像的。（其实也可以把 HRRN 算法看作优先级算法的一种特殊情况，将响应比作为优先级评判的标准）\n\n\n# 例题 1\n\n\n\n可剥夺：\n\n开始执行时间:进程 0:P1 3:P2 5:P3 10:P4 20:P3 21:P1 23:DONE\n进程 周转时间 带权周转时间\nP1 23-0=23 23/5=4.6\nP2 5-3=2 2/2=1\nP3 21-5=16 16/6=2.67\nP4 20-10=10 10/10=1\n平均周转时间：12.75\n带权周转时间：2.32\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 时间片轮转 (RR) 调度算法（进程调度）\n\nRR 算法的特点则在于 “公平分配”，按照进程到达就绪队列的顺序，轮流让每个进程执行一个相等长度的时间片，若在自己的时间片内没有执行完，则进程自动进入就绪队列队尾，并调度队头进程运行。整体呈现出 “交替” 的特点。因为进程即使没运行完也会发生调度，所以这是一个抢占式的算法。\n\n> 答题需表格 + 执行顺序时间线\n\n\n# 例题 1\n\n\n\n开始执行时间:进程(剩余时间)：0:P1(33) 20:P2(0) 37:P3(48) 57:P4(4) 77:P1(13) 97:P3(28) 117:P4(0) 121:P1(0)  134:P3(8) 154:P3(0) 162:DONE\nP1 134 134/50\nP2 17 17/17\nP3 162 162/68\nP4 121 121/24\n平均周转时间：108.5\n带权平均周转时间：2.78\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 多级反馈调度算法（进程调度）\n\n\n\n * 有多个级别的就绪队列，各级队列优先级从高到低，时间片从小到大\n * 每次有新进程到达，都会首先进入第一级队列，并按 FCFS 算法被分配时间片。如果时间片用完了而进程还没执行完，那么该进程将被送到下一级队列队尾。如果当前已经是最后一级，则重新放回当前队列队尾\n * 当且仅当上层级别的队列为空时，下一级队列的进程才有机会被调度\n * 关于抢占：如果某个进程运行的时候，比它所在队列级别更高的队列中有新进程到达，则那个新进程会抢占处理机，而当前正在运行的进程会被送到当前队列队尾\n\n优点：\n\n * 对各类型进程相对公平（FCFS 的优点）：谁先进来，谁就会处于高级队列，优先得到服务\n * 每个新到达的进程都可以很快就得到响应（RR 的优点）：新到达的进程首先在高级队列，可以很快得到响应\n * 短进程只用较少的时间就可完成（SPF 的优点）：不需要经历过多的队列\n * 可灵活地调整对各类进程的偏好程度，比如 CPU 密集型进程、I/O 密集型进程（拓展：可以将因 I/O 而阻塞的进程重新放回原队列，这样 I/O 型进程就可以保持较高优先级）\n * 对各类型用户友好。对于终端型用户来说，他们提交的大多属于较小的交互型作业，系统只要能使这些作业在第一队列所规定的时间片内完成，便可使终端型作业用户都感到满意；对短批处理作业用户来说，只需在第一队列中执行一个时间片，或至多在第二和第三队列中各执行一个时间片即可完成；对长批处理作业用户来说，只要让作业依次在第 1, 2，… n 个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理。\n\n缺点：\n\n * 可能会导致饥饿。若有源源不断的短进程到达第一队列，那么这些进程会持续被调度，使得下面一级的那些进程一直得不到调度，导致饥饿现象的发生。\n\n\n# 例题 1\n\n\n\n> D 就绪队列 2 有误\n\n\n# 例题 2（只有 3 个就绪队列的例题 1）\n\n\n\nA 2-0=2 2/2\nB 22-2=20 20/6\nC 58-4=54 54/10\nD 66-6=60 60/14\nE 110-8=102 102/18\nF 118-10=108 108/22\nG 146-12=134 134/26\nH 154-14=140 140/30\nI 166-16=150 150/34\n平均周转时间：85.56\n带权平均周转时间：4.31\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n平均周转时间 = 结束时间 - 开始时间 ×，平均周转时间 = 结束时间 - 到达时间 √。若没有给到达时间，则默认所有任务一开始就同时到达。",normalizedContent:"# 调度算法\n\n\n# 先来先服务 (fcfs) 调度算法（作业调度 + 进程调度）\n\n\n\n> 周转时间 = 完成时间 - 到达时间\n> \n> 带权周转时间 = 周转时间 / 服务时间\n\n\n\nfcfs 算法对长作业（cpu 时间长的作业）有利，对短作业不利。\n\n\n# 最短作业 (sjf) 调度算法（作业调度 + 进程调度）\n\n\n\n对这个情况而言，sjf 比 fcfs 更好，尤其是 c。\n\nsjf 调度算法也存在不容忽视的缺点：\n\n * 该算法对长作业不利，更严重的是，如果有一长作业（进程）进入系统的后备队列（就绪队列），由于调度程序总是优先调度那些（即使是后进来的）短作业（进程），将导致长作业（进程）长期不被调度。\n * 该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业（进程）会被及时处理。\n * 由于作业（进程）的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。\n\n\n# 高响应比优先 (hrrn) 调度算法（作业调度 + 进程调度）\n\n> hrrn (highest response ratio next) = hrrf (highest response ratio first)\n> \n> nuist 老师习惯用 hrrf，我觉得 hrrn 更合适\n\nfcfs 与 sjf 是片面的调度算法。fcfs 只考虑作业等候时间而忽视了作业的计算时间问题；sjf 只考虑用户估计的作业计算时间而忽视了作业等待时间。\n\nhrrn 是介乎这两者之间的非剥夺式算法，既考虑作业等待时间，又考虑作业的运行时间，既照顾短作业又不使长作业的等待时间过长，改进了调度性能。\n\n响应比（带权周转时间） = 作业周转时间 / 作业处理时间 = （作业等待时间 + 作业处理时间） / 作业处理时间 = 1 + 作业等待时间 / 作业处理时间\n\n * 短作业容易得到较高响应比（分母小）\n * 长作业等待时间足够长后，也将获得足够高的响应比（分子足够大）\n * 饥饿现象不会发生\n\n\n# 例题 1\n\n\n\n首先调度 j1，然后计算响应比：\n\nj2 1+15/15=2\nj3 1+10/5=3\nj4 1+5/10=1.5\n\n\n1\n2\n3\n\n1\n2\n3\n\n\nj3 的响应比最大，调度 j3。随后计算 j3 完成后的响应比：\n\nt=20+5\nj2 1+20/15=2.3\nj4 1+10/10=2\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n所以调用 j2，最后调用 j4。\n\n\n# 例题 2\n\n\n\nfcfs j1 2 3 4\n8 10 2 1\n10 10.5 1.5+1/6 (1.5+1/6)/0.5=3.3\n10.5 10.6 1.6 1.6/0.1=16\n10.6 10.8 0.8+2/3 (0.8+2/3)/0.2=7.3\n(2+1.5+1/6+1.6+0.8+2/3)/4=1.68\n(1+(1.5+1/6)/0.5+1.6/0.1+(0.8+2/3)/0.2)/4=6.92\nsjf j1 3 4 2\n8 10 2 1\n10.3 10.8 1.8+1/6 (1.8+1/6)/0.5=3.93\n10 10.1 1.1 1.1/0.1=11\n10.1 10.3 0.3+2/3 (0.3+2/3)/0.2=4.83\n(2+1.8+1/6+1.1+0.3+2/3)/4=1.51\n(1+(1.8+1/6)/0.5+1.1/0.1+(0.3+2/3)/0.2)/4=5.19\nhrrf j1 \n8 10 2 1\n(10) j2 未完成\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 高优先权 (fpf) 调度算法（作业调度 + 进程调度）\n\n\n# 非抢占式优先权算法\n\n和 hrrn 算法很像，进程会正常运行，直到结束之后才发生调度，在调度的时候会选择队列中优先级最高的进程。\n\n\n# 抢占式优先权算法\n\n除了正常运行结束会发生调度之外，每次就绪队列有新的进程到达时还会做一次检查，如果新到达进程优先级高于正在运行进程的优先级，那么新到达进程会抢占处理机。\n\n\n# 静态优先权\n\n静态优先级，指的是进程的优先级在它创建的时候就确定了，此后一直不会改变。一般认为系统进程优先级要高于用户进程优先级；前台进程优先级高于后台进程优先级；i/o 型进程优先级会比较高。\n\n\n# 动态优先权\n\n动态优先级，会尽量遵循公平的原则。也就是说，如果某个进程实在等得太久，那么不妨提高它的优先级，让他有机会被调度；反之，如果某个进程占用处理机时间过长，那么就要考虑降低它的优先级，不要让他一直 “霸占” 处理机了。另外，之前说过 i/o 型进程的优先级会很高，所以如果某个进程频繁进行 i/o 操作，也可以考虑提高它的优先级。\n\n优先级算法的优点在于区分了各个进程的紧急程度，比较紧急重要的进程会优先得到处理，因此它适用于实时操作系统。另外，由于动态优先级的存在，使得它对进程的调度相对灵活很多。缺点则是，如果源源不断进来了一些高优先级的进程，那么优先级相对较低的进程可能一直无法执行，进而导致饥饿现象的发生。这点和 hrrn 算法也是很像的。（其实也可以把 hrrn 算法看作优先级算法的一种特殊情况，将响应比作为优先级评判的标准）\n\n\n# 例题 1\n\n\n\n可剥夺：\n\n开始执行时间:进程 0:p1 3:p2 5:p3 10:p4 20:p3 21:p1 23:done\n进程 周转时间 带权周转时间\np1 23-0=23 23/5=4.6\np2 5-3=2 2/2=1\np3 21-5=16 16/6=2.67\np4 20-10=10 10/10=1\n平均周转时间：12.75\n带权周转时间：2.32\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 时间片轮转 (rr) 调度算法（进程调度）\n\nrr 算法的特点则在于 “公平分配”，按照进程到达就绪队列的顺序，轮流让每个进程执行一个相等长度的时间片，若在自己的时间片内没有执行完，则进程自动进入就绪队列队尾，并调度队头进程运行。整体呈现出 “交替” 的特点。因为进程即使没运行完也会发生调度，所以这是一个抢占式的算法。\n\n> 答题需表格 + 执行顺序时间线\n\n\n# 例题 1\n\n\n\n开始执行时间:进程(剩余时间)：0:p1(33) 20:p2(0) 37:p3(48) 57:p4(4) 77:p1(13) 97:p3(28) 117:p4(0) 121:p1(0)  134:p3(8) 154:p3(0) 162:done\np1 134 134/50\np2 17 17/17\np3 162 162/68\np4 121 121/24\n平均周转时间：108.5\n带权平均周转时间：2.78\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 多级反馈调度算法（进程调度）\n\n\n\n * 有多个级别的就绪队列，各级队列优先级从高到低，时间片从小到大\n * 每次有新进程到达，都会首先进入第一级队列，并按 fcfs 算法被分配时间片。如果时间片用完了而进程还没执行完，那么该进程将被送到下一级队列队尾。如果当前已经是最后一级，则重新放回当前队列队尾\n * 当且仅当上层级别的队列为空时，下一级队列的进程才有机会被调度\n * 关于抢占：如果某个进程运行的时候，比它所在队列级别更高的队列中有新进程到达，则那个新进程会抢占处理机，而当前正在运行的进程会被送到当前队列队尾\n\n优点：\n\n * 对各类型进程相对公平（fcfs 的优点）：谁先进来，谁就会处于高级队列，优先得到服务\n * 每个新到达的进程都可以很快就得到响应（rr 的优点）：新到达的进程首先在高级队列，可以很快得到响应\n * 短进程只用较少的时间就可完成（spf 的优点）：不需要经历过多的队列\n * 可灵活地调整对各类进程的偏好程度，比如 cpu 密集型进程、i/o 密集型进程（拓展：可以将因 i/o 而阻塞的进程重新放回原队列，这样 i/o 型进程就可以保持较高优先级）\n * 对各类型用户友好。对于终端型用户来说，他们提交的大多属于较小的交互型作业，系统只要能使这些作业在第一队列所规定的时间片内完成，便可使终端型作业用户都感到满意；对短批处理作业用户来说，只需在第一队列中执行一个时间片，或至多在第二和第三队列中各执行一个时间片即可完成；对长批处理作业用户来说，只要让作业依次在第 1, 2，… n 个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理。\n\n缺点：\n\n * 可能会导致饥饿。若有源源不断的短进程到达第一队列，那么这些进程会持续被调度，使得下面一级的那些进程一直得不到调度，导致饥饿现象的发生。\n\n\n# 例题 1\n\n\n\n> d 就绪队列 2 有误\n\n\n# 例题 2（只有 3 个就绪队列的例题 1）\n\n\n\na 2-0=2 2/2\nb 22-2=20 20/6\nc 58-4=54 54/10\nd 66-6=60 60/14\ne 110-8=102 102/18\nf 118-10=108 108/22\ng 146-12=134 134/26\nh 154-14=140 140/30\ni 166-16=150 150/34\n平均周转时间：85.56\n带权平均周转时间：4.31\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n平均周转时间 = 结束时间 - 开始时间 ×，平均周转时间 = 结束时间 - 到达时间 √。若没有给到达时间，则默认所有任务一开始就同时到达。",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"多级存储器结构",frontmatter:{title:"多级存储器结构",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/1253d7/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/05.%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/02.%E5%A4%9A%E7%BA%A7%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%93%E6%9E%84.html",relativePath:"01.操作系统/05.第四章 存储器管理/02.多级存储器结构.md",key:"v-8ecad5d0",path:"/pages/1253d7/",headersStr:null,content:"# 多级存储器结构\n\n",normalizedContent:"# 多级存储器结构\n\n",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"程序的装入与链接",frontmatter:{title:"程序的装入与链接",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/ae65e4/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/05.%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/03.%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5%E4%B8%8E%E9%93%BE%E6%8E%A5.html",relativePath:"01.操作系统/05.第四章 存储器管理/03.程序的装入与链接.md",key:"v-c81693ae",path:"/pages/ae65e4/",headers:[{level:2,title:"链接",slug:"链接",normalizedTitle:"链接",charIndex:8},{level:3,title:"静态链接",slug:"静态链接",normalizedTitle:"静态链接",charIndex:165},{level:3,title:"装入时动态链接",slug:"装入时动态链接",normalizedTitle:"装入时动态链接",charIndex:226},{level:3,title:"运行时动态链接",slug:"运行时动态链接",normalizedTitle:"运行时动态链接",charIndex:335},{level:2,title:"装入",slug:"装入",normalizedTitle:"装入",charIndex:5},{level:3,title:"绝对装入方式",slug:"绝对装入方式",normalizedTitle:"绝对装入方式",charIndex:575},{level:3,title:"静态重定位装入方式",slug:"静态重定位装入方式",normalizedTitle:"静态重定位装入方式",charIndex:689},{level:3,title:"动态重定位装入方式",slug:"动态重定位装入方式",normalizedTitle:"动态重定位装入方式",charIndex:926}],headersStr:"链接 静态链接 装入时动态链接 运行时动态链接 装入 绝对装入方式 静态重定位装入方式 动态重定位装入方式",content:"# 程序的装入与链接\n\n\n\n用户程序在执行前必须先进入内存，具体来说包括以下步骤：\n\n * 编译：由编译程序将用户源程序编译成多个目标模块\n * 链接：由链接程序将编译后的多个目标模块和所需的库函数链接在一起，形成一个总的装入模块\n * 装入：由装入程序将装入模块装入内存运行\n\n\n# 链接\n\n根据链接的时间不同进行区分\n\n\n# 静态链接\n\n直接将编译后的多个目标模块和所需的库函数链接在一起，形成一个不再拆开的装入模块，该模块整体装入内存。\n\n\n# 装入时动态链接\n\n不事先进行链接，而是一边装入内存，一边进行链接，即在装入一个目标模块时，若发生一个外部模块调用事件，装入程序就去找出相应的外部目标模块。这种方式便于修改和更新，便于实现对目标模块的共享。\n\n\n\n\n# 运行时动态链接\n\n不事先进行链接，而是一边执行程序，一边进行模块的装入和链接，这种方式可以确保只装入和链接那些在执行时需要用到的模块，而不会引入多余的、实际根本用不到的模块，因此拥有装入时动态链接的优点，还加快了程序的装入过程，有利于节省内存空间。\n\n\n# 装入\n\n装入模块中指令所涉及的地址是逻辑地址（相对地址），往往并不是装入内存后的物理地址，因此在装入模块装入内存后，需要将原先的逻辑地址转换成物理地址（绝对地址）。在下面三种装入方式中，对逻辑地址的处理是不同的。\n\n\n# 绝对装入方式\n\n程序员如果事先知道程序最终装入内存时的物理地址（如在单道程序运行环境中），那么编译程序产生的目标模块中可以直接使用物理地址，此时的逻辑地址与物理地址一样，模块在装入到内存的时候也无需进行地址转换的工作。\n\n\n# 静态重定位装入方式\n\n在多道程序运行环境中，无法事先知道程序最终装入内存时的物理地址，所以目标模块中只能使用逻辑地址，所有指令中涉及到的逻辑地址都是从 0 开始的。装入模块可以装入到内存的合适位置，并且在装入的时候会进行地址转换（重定位）的工作。例如将程序中起始于 0 的逻辑地址都转换为起始于 10000 的物理地址。\n\n“静态” 主要体现在程序装入内存后，在运行期间就不能再移动了，因为一旦移动就意味着需要再次更改物理地址，而地址是无法修改的，否则会发生错误。\n\n\n# 动态重定位装入方式\n\n很多时候，程序在内存中的位置会经常发生改变，比如在外存和内存之间对换。位置不会是一成不变的，这时候就要采用动态重定位装入方式。这种方式并不急于在装入的时候就进行地址转换，而是在程序真正执行的时候才去进行地址转换的工作。\n\n\n\n这意味着程序在装入内存后，在运行期间是可以移动的。因为不管移动到哪个内存位置，始终会有一个重定位寄存器用于记录和更新装入模块当前的物理起始地址，逻辑地址只需要和这个物理起始地址相加即可得到物理地址。",normalizedContent:"# 程序的装入与链接\n\n\n\n用户程序在执行前必须先进入内存，具体来说包括以下步骤：\n\n * 编译：由编译程序将用户源程序编译成多个目标模块\n * 链接：由链接程序将编译后的多个目标模块和所需的库函数链接在一起，形成一个总的装入模块\n * 装入：由装入程序将装入模块装入内存运行\n\n\n# 链接\n\n根据链接的时间不同进行区分\n\n\n# 静态链接\n\n直接将编译后的多个目标模块和所需的库函数链接在一起，形成一个不再拆开的装入模块，该模块整体装入内存。\n\n\n# 装入时动态链接\n\n不事先进行链接，而是一边装入内存，一边进行链接，即在装入一个目标模块时，若发生一个外部模块调用事件，装入程序就去找出相应的外部目标模块。这种方式便于修改和更新，便于实现对目标模块的共享。\n\n\n\n\n# 运行时动态链接\n\n不事先进行链接，而是一边执行程序，一边进行模块的装入和链接，这种方式可以确保只装入和链接那些在执行时需要用到的模块，而不会引入多余的、实际根本用不到的模块，因此拥有装入时动态链接的优点，还加快了程序的装入过程，有利于节省内存空间。\n\n\n# 装入\n\n装入模块中指令所涉及的地址是逻辑地址（相对地址），往往并不是装入内存后的物理地址，因此在装入模块装入内存后，需要将原先的逻辑地址转换成物理地址（绝对地址）。在下面三种装入方式中，对逻辑地址的处理是不同的。\n\n\n# 绝对装入方式\n\n程序员如果事先知道程序最终装入内存时的物理地址（如在单道程序运行环境中），那么编译程序产生的目标模块中可以直接使用物理地址，此时的逻辑地址与物理地址一样，模块在装入到内存的时候也无需进行地址转换的工作。\n\n\n# 静态重定位装入方式\n\n在多道程序运行环境中，无法事先知道程序最终装入内存时的物理地址，所以目标模块中只能使用逻辑地址，所有指令中涉及到的逻辑地址都是从 0 开始的。装入模块可以装入到内存的合适位置，并且在装入的时候会进行地址转换（重定位）的工作。例如将程序中起始于 0 的逻辑地址都转换为起始于 10000 的物理地址。\n\n“静态” 主要体现在程序装入内存后，在运行期间就不能再移动了，因为一旦移动就意味着需要再次更改物理地址，而地址是无法修改的，否则会发生错误。\n\n\n# 动态重定位装入方式\n\n很多时候，程序在内存中的位置会经常发生改变，比如在外存和内存之间对换。位置不会是一成不变的，这时候就要采用动态重定位装入方式。这种方式并不急于在装入的时候就进行地址转换，而是在程序真正执行的时候才去进行地址转换的工作。\n\n\n\n这意味着程序在装入内存后，在运行期间是可以移动的。因为不管移动到哪个内存位置，始终会有一个重定位寄存器用于记录和更新装入模块当前的物理起始地址，逻辑地址只需要和这个物理起始地址相加即可得到物理地址。",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"死锁",frontmatter:{title:"死锁",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/15347c/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/04.%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/06.%E6%AD%BB%E9%94%81.html",relativePath:"01.操作系统/04.第三章 处理机调度与死锁/06.死锁.md",key:"v-163d8114",path:"/pages/15347c/",headers:[{level:2,title:"出现死锁的场景",slug:"出现死锁的场景",normalizedTitle:"出现死锁的场景",charIndex:9},{level:3,title:"进程推进顺序不当",slug:"进程推进顺序不当",normalizedTitle:"进程推进顺序不当",charIndex:21},{level:3,title:"资源竞争",slug:"资源竞争",normalizedTitle:"资源竞争",charIndex:36},{level:2,title:"产生死锁的四个必要条件",slug:"产生死锁的四个必要条件",normalizedTitle:"产生死锁的四个必要条件",charIndex:47},{level:3,title:"互斥",slug:"互斥",normalizedTitle:"互斥",charIndex:63},{level:3,title:"非抢占",slug:"非抢占",normalizedTitle:"非抢占",charIndex:119},{level:3,title:"请求和占有",slug:"请求和占有",normalizedTitle:"请求和占有",charIndex:185},{level:3,title:"环路循环等待",slug:"环路循环等待",normalizedTitle:"环路循环等待",charIndex:743},{level:2,title:"预防死锁",slug:"预防死锁",normalizedTitle:"预防死锁",charIndex:1014},{level:3,title:"破坏互斥条件",slug:"破坏互斥条件",normalizedTitle:"破坏互斥条件",charIndex:1105},{level:3,title:"破坏非抢占条件",slug:"破坏非抢占条件",normalizedTitle:"破坏非抢占条件",charIndex:1163},{level:3,title:"破坏“请求和占有”条件",slug:"破坏-请求和占有-条件",normalizedTitle:"破坏 “请求和占有” 条件",charIndex:1505},{level:3,title:"破坏“环路循环等待”条件",slug:"破坏-环路循环等待-条件",normalizedTitle:"破坏 “环路循环等待” 条件",charIndex:1752},{level:2,title:"避免死锁",slug:"避免死锁",normalizedTitle:"避免死锁",charIndex:2922},{level:3,title:"进程-资源分配图",slug:"进程-资源分配图",normalizedTitle:"进程 - 资源分配图",charIndex:3236},{level:3,title:"银行家算法",slug:"银行家算法",normalizedTitle:"银行家算法",charIndex:3564},{level:4,title:"银行家算法案例",slug:"银行家算法案例",normalizedTitle:"银行家算法案例",charIndex:3654},{level:4,title:"银行家算法过程",slug:"银行家算法过程",normalizedTitle:"银行家算法过程",charIndex:3864},{level:4,title:"例题1",slug:"例题1",normalizedTitle:"例题 1",charIndex:4613},{level:4,title:"例题2",slug:"例题2",normalizedTitle:"例题 2",charIndex:5293},{level:4,title:"例题3",slug:"例题3",normalizedTitle:"例题 3",charIndex:5382},{level:2,title:"检测死锁",slug:"检测死锁",normalizedTitle:"检测死锁",charIndex:5949},{level:3,title:"简化进程-资源分配图",slug:"简化进程-资源分配图",normalizedTitle:"简化进程 - 资源分配图",charIndex:5958},{level:4,title:"各类资源只有一个",slug:"各类资源只有一个",normalizedTitle:"各类资源只有一个",charIndex:5974},{level:4,title:"各类资源有多个",slug:"各类资源有多个",normalizedTitle:"各类资源有多个",charIndex:6312},{level:2,title:"解除死锁",slug:"解除死锁",normalizedTitle:"解除死锁",charIndex:6974},{level:3,title:"资源剥夺法",slug:"资源剥夺法",normalizedTitle:"资源剥夺法",charIndex:6983},{level:3,title:"终止进程法",slug:"终止进程法",normalizedTitle:"终止进程法",charIndex:7070},{level:3,title:"进程回退法",slug:"进程回退法",normalizedTitle:"进程回退法",charIndex:7159}],headersStr:"出现死锁的场景 进程推进顺序不当 资源竞争 产生死锁的四个必要条件 互斥 非抢占 请求和占有 环路循环等待 预防死锁 破坏互斥条件 破坏非抢占条件 破坏“请求和占有”条件 破坏“环路循环等待”条件 避免死锁 进程-资源分配图 银行家算法 银行家算法案例 银行家算法过程 例题1 例题2 例题3 检测死锁 简化进程-资源分配图 各类资源只有一个 各类资源有多个 解除死锁 资源剥夺法 终止进程法 进程回退法",content:"# 死锁\n\n\n# 出现死锁的场景\n\n\n# 进程推进顺序不当\n\n\n\n\n# 资源竞争\n\n\n\n\n# 产生死锁的四个必要条件\n\n\n# 互斥\n\n进程互斥使用资源。因为如果是可以共享使用的资源，多个进程直接同时使用就好，不会陷入等待的僵局。\n\n\n# 非抢占\n\n一个进程不能抢夺其他进程占有的资源。因为如果其它进程可以抢占资源，那么就是直接拿到资源了，也不会陷入等待的僵局。\n\n\n# 请求和占有\n\n申请新资源时不释放已占有资源，即要求进程是在占有（holding）至少一个资源的前提下，请求（waiting）新的资源的。由于新的资源被其它进程占有，此时，发出请求的进程就会带着自己占有的资源进入阻塞状态。假设 P1，P2 分别都需要 R1，R2 资源，如果是下面这种方式：\n\nP1:          P2:\nrequest(R1)  request(R2)\nrequest(R2)  request(R1) \n\n\n1\n2\n3\n\n1\n2\n3\n\n\n如果 P1 请求到了 R1 资源之后，P2 请求到了 R2 资源，那么此后不管是哪个进程再次请求资源，都是在占有资源的前提下请求的，此时就会带着这个资源陷入阻塞状态。P1 和 P2 需要互相等待，发生了死锁。\n\n换一种情况：\n\nP1:          P2:\nrequest(R1)  request(R1)\nrequest(R2)  request(R2) \n\n\n1\n2\n3\n\n1\n2\n3\n\n\n如果 P1 请求到了 R1 资源，那么 P2 在请求 R1 的时候虽然也会阻塞，但是是在不占有资源的情况下阻塞的，不像之前那样占有 R2。所以，此时 P1 可以正常完成任务并释放 R1，P2 拿到 R1 之后再去执行任务。这种情况就不会发生死锁。\n\n\n# 环路循环等待\n\n要求存在一条进程资源的循环等待链，链中的每一个进程占有的资源同时被另一个进程所请求。\n\n[P0，P1，P2，…Pn] 中的 P0 正在等待 P1 占用的资源，P1 正在等待 P2 占用的资源......Pn 正在等待 P0 占用的资源。\n\n发生死锁时一定有循环等待（因为是死锁的必要条件），但是发生循环等待的时候不一定会发生死锁。这是因为，如果循环等待链中的 P1 和 链外的 P6 都占有某个进程 P2 请求的资源，那么 P2 完全可以选择不等待 P1 释放该资源，而是等待 P6 释放资源。这样就不会发生死锁了。\n\n\n# 预防死锁\n\n通过设置某些限制条件，以牺牲资源利用率和系统吞吐量为代价，破坏产生死锁的四个必要条件中的一个或几个。特点是简单、限制条件严格，有可能导致资源利用率和系统吞吐量低\n\n\n# 破坏互斥条件\n\n如果可以把某个互斥资源转化成共享资源，那么就不存在互相等待资源的情况了，也就不会发生死锁。\n\n\n# 破坏非抢占条件\n\n如果资源是可以抢占的，那么在进程需要资源的时候，就可以直接抢占了，不存在互相等待资源的情况，也就不会发生死锁。要破坏非抢占条件，做到可抢占，可以从两个角度（方案）考虑：\n\n * 从占有资源的进程的角度考虑，如果它请求不到新的资源，那么它必须立即释放占有的全部资源，以后需要的时候重新申请\n * 从请求资源的进程的角度考虑，如果它需要请求资源，那么操作系统会帮助它抢占相关资源。比如现在有一个优先级更高的进程，如果是采用优先级调度算法，那么它将有机会在操作系统的帮助下抢占到资源。\n\n这种做法的问题在于：\n\n * 实现起来复杂\n * 某个占有资源的进程释放占有的全部资源时，可能会导致工作进度丢失\n * 反复的申请和释放资源会增加系统开销\n * 可能导致饥饿\n\n\n# 破坏 “请求和占有” 条件\n\n所有进程在运行之前，都必须一次性地申请其在整个行过程中的所需的全部资源，此时，若系统有足够的资源分配给某进程，便可把其需要的所有资源分配给该进程，这样，该进程在整个运行期间便不会再提出资源要求。\n\n该方法可能导致饥饿现象。若有 ABC 三类进程，A 用到 a 资源，B 用到 b 资源，C 用到 ab 资源，那么 AB 会在运行前事先申请到 ab 资源，如果 AB 源源不断进入就绪队列，那么 C 进程没有办法在运行前拿到 ab 资源，就进入了饥饿状态。\n\n\n# 破坏 “环路循环等待” 条件\n\n将所有资源按类型进行线性排队并编号，所有进程必须严格按照序号递增的顺序请求资源，即先请求小编号资源，后请求大编号资源。这样，在形成的资源分配图中，不再出现环路。\n\n优点：和前两种相比，资源利用率和吞吐量利用率高\n\n缺点：系统中各类资源所分配的序号必须相对稳定，限制了新类型设备的增加；作业（进程）使用各类资源的顺序与系统规定的顺序不同，造成对资源的浪费；为方便用户，系统对用户在编程时所施加的限制条件应尽量少，但必然限制用户简单、自主地编程。\n\n以之前的例子讲解：\n\nP1:          P2:\nrequest(R1)  request(R2)\nrequest(R2)  request(R1) \n\n\n1\n2\n3\n\n1\n2\n3\n\n\n这种情况下资源请求是无序的，尤其是 P2，它没有按照递增的顺序请求资源，因此很容易发生死锁。但是如果是这种情况：\n\nP1:          P2:\nrequest(R1)  request(R1)\nrequest(R2)  request(R2) \n\n\n1\n2\n3\n\n1\n2\n3\n\n\n实际上，这里除了破坏 “占有和请求条件” 之外，更重要的是破坏了循环等待条件 —— 因为这里是按照编号递增的顺序请求资源了，不管是 P1 还是 P2，都是先请求小编号的 R1，后请求大编号的 R2，这样的话就不会发生死锁，因为此时两个进程对资源的请求并没有形成一个闭环。\n\n也可以拿之前的哲学家进餐问题解释，如果我们给每个筷子进行编号，规定必须按照编号递增的顺序申请资源，那么从 0 号到 3 号，它们依然会拿起左手边小编号的筷子，但是轮到 4 号的时候，情况就不一样了。因为对于 4 号来说，右手筷子编号更小，所以在拿到左手筷子之前，它会先试图拿右手筷子，又由于该筷子已经被 0 号拿走，4 号被阻塞。对于 3 号来说，没人和自己抢 4 号筷子了，所以 3 号哲学家可以拿到左右筷子，避免了死锁。\n\n还可以从另一个角度考虑，因为我们是按照编号递增的顺序请求资源的，设想在某一时刻，若干个进程中必定有一个进程的资源编号暂时是所有进程中最大的，那么该进程在此后申请新的资源的时候，只可能申请编号更大的资源，一方面避开了小编号、可能已经被拿走的资源，也就避开了阻塞和死锁，另一方面，大编号资源并没有被其他进程拿走。因此这个时候，该进程一定可以拿到资源，不会有死锁现象。\n\n> 但这种预防死锁的方法，问题在于：\n> \n>  * 如何进行编号，从什么角度考虑？\n>  * 如果增加资源或设备，怎么重新编号？\n>  * 虽然资源请求上是先小编号资源，后大编号资源，但是实际使用的时候可能是得先使用大编号资源，这就意味着小编号资源虽然暂时用不到，但还是被进程占用，明显有资源浪费的问题。\n\n\n# 避免死锁\n\n安全状态：指系统按某种顺序 (P1,P2,…,Pn)(称 < P1,P2,…,Pn > 为安全序列) 来为每个进程分配其所需资源，直至满足每个进程资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。\n\n避免死锁的实质在于：系统在进行资源分配时，如何使系统不进入不安全状态\n\n安全状态之例：假定系统中有三个进程 P1、P2 和 P3, 共有 12 台磁带机。进程 P1 总共要求 10 台磁带机，P2 和 P3 分别要求 4 台和 9 台。假设在 T0 时刻，进程 P1、P2 和 P3 分别获得 5 台、2 台和 2 台，尚有 3 台未分配，如下表所示：\n\n\n\n\n# 进程 - 资源分配图\n\n当各类资源都只有一个的时候，可以使用这种方法求解。资源分配图是描述进程和资源之间请求和分配关系的有向图，从进程指向资源的虚线代表资源需求（要使用），从进程指向资源的实线代表资源请求（申请使用），从资源指向进程的实线代表资源分配（正在使用）。\n\n\n\n * 如果 P1 请求 R2 资源：那么就把 P1 到 R2 的需求边改为 R2 到 P1 的分配边，此时整个图中不存在回路，那么就认为系统处于安全状态，不会发生死锁。可以分配资源。\n * 如果 P2 请求 R2 资源：那么就把 P2 到 R2 的需求边改为 R2 到 P2 的分配边，此时整个图中存在一条回路，那么就认为系统处于不安全状态，有可能发生死锁。不可以分配资源。\n\n\n# 银行家算法\n\n * 银行家拥有一笔周转资金\n * 客户要求分期贷款，如果客户能够得到各期贷款，就一定能够归还贷款，否则就一定不能放贷\n * 银行家应谨慎的贷款，防止出现坏帐\n\n# 银行家算法案例\n\n设银行家有 10 万贷款，P,Q,R 分别需要 8,3,9 万元搞项目（假设任何人满足资金总额后都会归还所有贷款)\n\n如果 P 已申请到了 4 万：\n\n * Q 要申请 2 万，显然，如果满足 Q 的申请，有安全序列 <P,Q,R>/<Q,P,R>\n * R 要申请 4 万，显然，如果满足 R 的申请，则不存在安全序列。\n\n基本思想：分配申请的资源前，判断系统是否安全。如果不安全，则不分配。\n\n# 银行家算法过程\n\n\n\n假设系统中有 n 个进程，m 种资源，规定：\n\n * 每个进程在运行前先声明自己需要的最大资源数，用一个 n*m 的最大需求矩阵 Max 表示各个进程的需求情况，比如 Max[i][j]= K 就表示进程 i 需要 K 个 j 类型资源\n * 用一个 n*m 的分配矩阵 Allocation 表示各个进程的已分配资源情况\n * 用一个 n*m 的需求矩阵 Need 表示各个进程的最多还需要资源情况， Need = Max - Allocation\n * 用一个 m 长度的一维数组 Avaliable 表示剩余资源数目\n * 用一个 m 长度的申请矩阵 Request[i][j] 表示某个进程 i 某次申请的 j 类型资源数目\n\n按照之前说过的流程图，银行家算法的工作过程是：\n\n * 请求资源数是否超过最大资源数？ Request[i][j]<=Need[i][j] ，则到下一步；否则出错\n * 请求资源数是否超过剩余资源数？ Request[i][j]<=Available[j] ，则到下一步；否则说明资源不够，进程等待\n * 尝试进行资源分配。\n   * 剩余资源减少： Available = Available - Request\n   * 已分配资源增加： Allocation[i][j] = Allocation[i][j] + Request[i][j]\n   * 需求资源减少： Need[i][j] = Need[i][j] - Request[i][j]\n * 对分配后的状态通过安全性算法进行预判：\n   * 安全状态：不会发生死锁，可以分配资源\n   * 不安全状态：可能发生死锁，不分配资源，进程进入等待资源状态，并恢复系统状态\n\n# 例题 1\n\n假如现在有 P0 ~ P4 共五个进程，ABC 三类资源，个数为（10,5,7）。在某一时刻，资源剩余量为（3,3,2），各个进程的最大需求量、已分配量和需求量如下图所示：\n\n\n\n如何检测当前是否处于安全状态呢？尝试寻找安全序列：\n\n * 当前剩余资源（3,3,2），无法满足 P0 需要的（7,4,3），所以不能首先分配给 P0；但是可以满足 P1 需要的（1,2,2），P3 需要的（0,1,1），所以可以分配给 P1 和 P3，P1 和 P3 进入安全序列。\n * P1 和 P3 执行完之后，归还资源，剩余资源（3,3,2）+（2,0,0）+（2,1,1）=（7,4,3），可以满足 P0 需要的（7,4,3），P2 需要的（6,0,0），P4 需要的（4,3,1），所以 P0、P2、P4 依次进入安全序列。\n * 所以存在安全序列 P1->P3->P0->P2->P4 ，使得按照这个顺序分配资源后，每个进程都能拿到需要的资源并顺利完成，所以该状态是安全状态。\n\n看另一种情况。假如现在有 P0 ~ P4 共五个进程，ABC 三类资源，个数为（10,5,7）。在某一时刻，资源剩余量为（3,3,2），各个进程的最大需求量、已分配量和需求量如下图所示：\n\n\n\n当尝试寻找安全序列的时候，容易发现 P1 P3 可以满足，所以 P1 P3 进入安全序列，此后剩余资源为（7,4,3）。又由于 P0 P2 P4 都是无法满足的，所以实际上并不存在一个安全序列使得所有进程都能被分配资源。因此状态是不安全状态，可能发生死锁，取消资源分配。\n\n# 例题 2\n\nt0 时刻安全状态检查。如果 t0 时刻都不安全，则后面的部分都不用做了。但是考试时 t0 都是安全的。\n\n\n\n安全序列之一：<p1,p3,p4,p2,p0>\n\n# 例题 3\n\n在银行家算法中，若出现下述资源分配情况，试问：\n\nPROCESS   ALLOCATION   NEED   AVAILABLE\nP0        0032         0012   1622\nP1        1000         1750   \nP2        1354         2356   \nP3        0332         0652   \nP4        0014         0656   \n\n(1) 该状态是否安全？\n\nP0 1622+0032=1654\nP3 1654+0332=1986\nP1 1986+1000=2986\nP4 2986+0014=299 10\nP2 299 10+1354=3 12 14 14\n故存在安全序列P0 P3 P1 P4 P2\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n(2) 若进程 P2 提出请求 Request (1,2,2,2) 后，系统能否将资源分配给它？\n\nP2的Allocation加上1 2 2 2为2 5 7 6，Need变为1 1 3 4， Available变为0 4 0 0\n由(1)可知，此时系统资源无法满足任何一个进程，安全性检查不通过，无法分配资源\n\n\n1\n2\n\n1\n2\n\n\n\n# 检测死锁\n\n\n# 简化进程 - 资源分配图\n\n# 各类资源只有一个\n\n当各类资源只有一个的时候，可以把资源分配图化简为一个等待图（wait-for graph），比如说 A 进程请求 X 资源、X 资源被 B 进程占有，这个过程可以被简化为 A 进程等待 B 进程。比如说下面，左图被转化为对应的右图：\n\n\n\n死锁定理：有环路，且每个类型的资源只有一个，则一定会出现死锁。\n\n * 如果进程 - 资源分配图中无环路，则此时系统没有发生死锁。\n * 如果进程 - 资源分配图中有环路，且每个资源类中仅有一个资源，则系统中发生了死锁，此时，环路是系统发生死锁的充分和必要条件，环路中的进程便为死锁进程。\n * 如果进程 - 资源分配图中有环路，且涉及的资源类中有多个资源，则环路的存在只是产生死锁的必要条件而不是充分条件。\n\n# 各类资源有多个\n\n各类资源有多个的时候，我们可能需要根据给定表或给定图检测是否有死锁。对于前者，可以沿用之前的安全性算法进行检测；对于后者，可以尝试简化资源分配图。\n\n给定一个资源分配图为例：\n\n\n\n约定蓝色线为请求边，黑色线为分配边，资源中的一个圆点代表一个该类资源。那么 P1 占有两个 R1 资源，请求一个 R2 资源；P2 占有一个 R2 资源，一个 R1 资源，请求一个 R1 资源。\n\n * 首先找出非阻塞非孤立的进程点。P1 P2 都不是孤立的，所谓非阻塞指的是进程请求的资源数量足够，比如说 P2 请求 R1，由于 R1 已经有两个被 P1 占有，一个被 P2 占有，无多余资源，所以 P2 是阻塞的；而 P1 请求 R2，因为 R2 只有一个被 P2 占有，有多余资源，P1 是非阻塞的。这样就找到了符合条件的进程点 P1\n * 去除这样的点的所有边。那么就会去除 P1 的所有边，归还所有资源。P1 成为孤立点\n * 重复第一步和第二步。此时，因为这次 P2 请求的 R2 资源是足够的（被 P1 释放了），所以 P2 是非阻塞非孤立的点，把他的全部边去除\n * 由于图中所有的边都能被消除，所以称该图可以被简化，因此它不存在死锁（如果不可简化，则存在死锁）\n\n> \n\n又比如下面这种情况：\n\n\n\n首先还是找一个非孤立非阻塞的点，很显然只有 P3 符合要求。之后把 P3 的分配边去掉，会发现 P1 和 P2 都是非孤立阻塞的点，它们的边都无法消除。此时就说该资源分配图不能简化，因此存在死锁。\n\n\n# 解除死锁\n\n\n# 资源剥夺法\n\n将部分死锁的进程挂起并抢占它的资源，将这些资源分配给其它的死锁进程。但应防止被挂起的进程长时间得不到资源而饥饿。\n\n> 注意不是抢占非死锁进程的资源。\n\n\n# 终止进程法\n\n强制终止部分或全部死锁进程，并剥夺它们的资源。这种方式的优点是实现简单，但可能付出很大的代价。因为有些进程可能已经运行了很长时间，一旦被终止就功亏一篑了。\n\n\n# 进程回退法\n\n让一个或多个死锁进程回退到足以避免死锁的地步。这要求系统必须记录进程的历史信息，设置还原点。\n\n> 无论是哪种方法，都可以从以下角度考虑需要做出牺牲的进程：\n> \n>  * 优先级比较低的进程做出牺牲\n>  * 占用过多资源的进程做出牺牲\n>  * 执行时间长的进程不做出牺牲\n>  * 快要完成的进程不做出牺牲\n>  * 交互式进程不做出牺牲",normalizedContent:"# 死锁\n\n\n# 出现死锁的场景\n\n\n# 进程推进顺序不当\n\n\n\n\n# 资源竞争\n\n\n\n\n# 产生死锁的四个必要条件\n\n\n# 互斥\n\n进程互斥使用资源。因为如果是可以共享使用的资源，多个进程直接同时使用就好，不会陷入等待的僵局。\n\n\n# 非抢占\n\n一个进程不能抢夺其他进程占有的资源。因为如果其它进程可以抢占资源，那么就是直接拿到资源了，也不会陷入等待的僵局。\n\n\n# 请求和占有\n\n申请新资源时不释放已占有资源，即要求进程是在占有（holding）至少一个资源的前提下，请求（waiting）新的资源的。由于新的资源被其它进程占有，此时，发出请求的进程就会带着自己占有的资源进入阻塞状态。假设 p1，p2 分别都需要 r1，r2 资源，如果是下面这种方式：\n\np1:          p2:\nrequest(r1)  request(r2)\nrequest(r2)  request(r1) \n\n\n1\n2\n3\n\n1\n2\n3\n\n\n如果 p1 请求到了 r1 资源之后，p2 请求到了 r2 资源，那么此后不管是哪个进程再次请求资源，都是在占有资源的前提下请求的，此时就会带着这个资源陷入阻塞状态。p1 和 p2 需要互相等待，发生了死锁。\n\n换一种情况：\n\np1:          p2:\nrequest(r1)  request(r1)\nrequest(r2)  request(r2) \n\n\n1\n2\n3\n\n1\n2\n3\n\n\n如果 p1 请求到了 r1 资源，那么 p2 在请求 r1 的时候虽然也会阻塞，但是是在不占有资源的情况下阻塞的，不像之前那样占有 r2。所以，此时 p1 可以正常完成任务并释放 r1，p2 拿到 r1 之后再去执行任务。这种情况就不会发生死锁。\n\n\n# 环路循环等待\n\n要求存在一条进程资源的循环等待链，链中的每一个进程占有的资源同时被另一个进程所请求。\n\n[p0，p1，p2，…pn] 中的 p0 正在等待 p1 占用的资源，p1 正在等待 p2 占用的资源......pn 正在等待 p0 占用的资源。\n\n发生死锁时一定有循环等待（因为是死锁的必要条件），但是发生循环等待的时候不一定会发生死锁。这是因为，如果循环等待链中的 p1 和 链外的 p6 都占有某个进程 p2 请求的资源，那么 p2 完全可以选择不等待 p1 释放该资源，而是等待 p6 释放资源。这样就不会发生死锁了。\n\n\n# 预防死锁\n\n通过设置某些限制条件，以牺牲资源利用率和系统吞吐量为代价，破坏产生死锁的四个必要条件中的一个或几个。特点是简单、限制条件严格，有可能导致资源利用率和系统吞吐量低\n\n\n# 破坏互斥条件\n\n如果可以把某个互斥资源转化成共享资源，那么就不存在互相等待资源的情况了，也就不会发生死锁。\n\n\n# 破坏非抢占条件\n\n如果资源是可以抢占的，那么在进程需要资源的时候，就可以直接抢占了，不存在互相等待资源的情况，也就不会发生死锁。要破坏非抢占条件，做到可抢占，可以从两个角度（方案）考虑：\n\n * 从占有资源的进程的角度考虑，如果它请求不到新的资源，那么它必须立即释放占有的全部资源，以后需要的时候重新申请\n * 从请求资源的进程的角度考虑，如果它需要请求资源，那么操作系统会帮助它抢占相关资源。比如现在有一个优先级更高的进程，如果是采用优先级调度算法，那么它将有机会在操作系统的帮助下抢占到资源。\n\n这种做法的问题在于：\n\n * 实现起来复杂\n * 某个占有资源的进程释放占有的全部资源时，可能会导致工作进度丢失\n * 反复的申请和释放资源会增加系统开销\n * 可能导致饥饿\n\n\n# 破坏 “请求和占有” 条件\n\n所有进程在运行之前，都必须一次性地申请其在整个行过程中的所需的全部资源，此时，若系统有足够的资源分配给某进程，便可把其需要的所有资源分配给该进程，这样，该进程在整个运行期间便不会再提出资源要求。\n\n该方法可能导致饥饿现象。若有 abc 三类进程，a 用到 a 资源，b 用到 b 资源，c 用到 ab 资源，那么 ab 会在运行前事先申请到 ab 资源，如果 ab 源源不断进入就绪队列，那么 c 进程没有办法在运行前拿到 ab 资源，就进入了饥饿状态。\n\n\n# 破坏 “环路循环等待” 条件\n\n将所有资源按类型进行线性排队并编号，所有进程必须严格按照序号递增的顺序请求资源，即先请求小编号资源，后请求大编号资源。这样，在形成的资源分配图中，不再出现环路。\n\n优点：和前两种相比，资源利用率和吞吐量利用率高\n\n缺点：系统中各类资源所分配的序号必须相对稳定，限制了新类型设备的增加；作业（进程）使用各类资源的顺序与系统规定的顺序不同，造成对资源的浪费；为方便用户，系统对用户在编程时所施加的限制条件应尽量少，但必然限制用户简单、自主地编程。\n\n以之前的例子讲解：\n\np1:          p2:\nrequest(r1)  request(r2)\nrequest(r2)  request(r1) \n\n\n1\n2\n3\n\n1\n2\n3\n\n\n这种情况下资源请求是无序的，尤其是 p2，它没有按照递增的顺序请求资源，因此很容易发生死锁。但是如果是这种情况：\n\np1:          p2:\nrequest(r1)  request(r1)\nrequest(r2)  request(r2) \n\n\n1\n2\n3\n\n1\n2\n3\n\n\n实际上，这里除了破坏 “占有和请求条件” 之外，更重要的是破坏了循环等待条件 —— 因为这里是按照编号递增的顺序请求资源了，不管是 p1 还是 p2，都是先请求小编号的 r1，后请求大编号的 r2，这样的话就不会发生死锁，因为此时两个进程对资源的请求并没有形成一个闭环。\n\n也可以拿之前的哲学家进餐问题解释，如果我们给每个筷子进行编号，规定必须按照编号递增的顺序申请资源，那么从 0 号到 3 号，它们依然会拿起左手边小编号的筷子，但是轮到 4 号的时候，情况就不一样了。因为对于 4 号来说，右手筷子编号更小，所以在拿到左手筷子之前，它会先试图拿右手筷子，又由于该筷子已经被 0 号拿走，4 号被阻塞。对于 3 号来说，没人和自己抢 4 号筷子了，所以 3 号哲学家可以拿到左右筷子，避免了死锁。\n\n还可以从另一个角度考虑，因为我们是按照编号递增的顺序请求资源的，设想在某一时刻，若干个进程中必定有一个进程的资源编号暂时是所有进程中最大的，那么该进程在此后申请新的资源的时候，只可能申请编号更大的资源，一方面避开了小编号、可能已经被拿走的资源，也就避开了阻塞和死锁，另一方面，大编号资源并没有被其他进程拿走。因此这个时候，该进程一定可以拿到资源，不会有死锁现象。\n\n> 但这种预防死锁的方法，问题在于：\n> \n>  * 如何进行编号，从什么角度考虑？\n>  * 如果增加资源或设备，怎么重新编号？\n>  * 虽然资源请求上是先小编号资源，后大编号资源，但是实际使用的时候可能是得先使用大编号资源，这就意味着小编号资源虽然暂时用不到，但还是被进程占用，明显有资源浪费的问题。\n\n\n# 避免死锁\n\n安全状态：指系统按某种顺序 (p1,p2,…,pn)(称 < p1,p2,…,pn > 为安全序列) 来为每个进程分配其所需资源，直至满足每个进程资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。\n\n避免死锁的实质在于：系统在进行资源分配时，如何使系统不进入不安全状态\n\n安全状态之例：假定系统中有三个进程 p1、p2 和 p3, 共有 12 台磁带机。进程 p1 总共要求 10 台磁带机，p2 和 p3 分别要求 4 台和 9 台。假设在 t0 时刻，进程 p1、p2 和 p3 分别获得 5 台、2 台和 2 台，尚有 3 台未分配，如下表所示：\n\n\n\n\n# 进程 - 资源分配图\n\n当各类资源都只有一个的时候，可以使用这种方法求解。资源分配图是描述进程和资源之间请求和分配关系的有向图，从进程指向资源的虚线代表资源需求（要使用），从进程指向资源的实线代表资源请求（申请使用），从资源指向进程的实线代表资源分配（正在使用）。\n\n\n\n * 如果 p1 请求 r2 资源：那么就把 p1 到 r2 的需求边改为 r2 到 p1 的分配边，此时整个图中不存在回路，那么就认为系统处于安全状态，不会发生死锁。可以分配资源。\n * 如果 p2 请求 r2 资源：那么就把 p2 到 r2 的需求边改为 r2 到 p2 的分配边，此时整个图中存在一条回路，那么就认为系统处于不安全状态，有可能发生死锁。不可以分配资源。\n\n\n# 银行家算法\n\n * 银行家拥有一笔周转资金\n * 客户要求分期贷款，如果客户能够得到各期贷款，就一定能够归还贷款，否则就一定不能放贷\n * 银行家应谨慎的贷款，防止出现坏帐\n\n# 银行家算法案例\n\n设银行家有 10 万贷款，p,q,r 分别需要 8,3,9 万元搞项目（假设任何人满足资金总额后都会归还所有贷款)\n\n如果 p 已申请到了 4 万：\n\n * q 要申请 2 万，显然，如果满足 q 的申请，有安全序列 <p,q,r>/<q,p,r>\n * r 要申请 4 万，显然，如果满足 r 的申请，则不存在安全序列。\n\n基本思想：分配申请的资源前，判断系统是否安全。如果不安全，则不分配。\n\n# 银行家算法过程\n\n\n\n假设系统中有 n 个进程，m 种资源，规定：\n\n * 每个进程在运行前先声明自己需要的最大资源数，用一个 n*m 的最大需求矩阵 max 表示各个进程的需求情况，比如 max[i][j]= k 就表示进程 i 需要 k 个 j 类型资源\n * 用一个 n*m 的分配矩阵 allocation 表示各个进程的已分配资源情况\n * 用一个 n*m 的需求矩阵 need 表示各个进程的最多还需要资源情况， need = max - allocation\n * 用一个 m 长度的一维数组 avaliable 表示剩余资源数目\n * 用一个 m 长度的申请矩阵 request[i][j] 表示某个进程 i 某次申请的 j 类型资源数目\n\n按照之前说过的流程图，银行家算法的工作过程是：\n\n * 请求资源数是否超过最大资源数？ request[i][j]<=need[i][j] ，则到下一步；否则出错\n * 请求资源数是否超过剩余资源数？ request[i][j]<=available[j] ，则到下一步；否则说明资源不够，进程等待\n * 尝试进行资源分配。\n   * 剩余资源减少： available = available - request\n   * 已分配资源增加： allocation[i][j] = allocation[i][j] + request[i][j]\n   * 需求资源减少： need[i][j] = need[i][j] - request[i][j]\n * 对分配后的状态通过安全性算法进行预判：\n   * 安全状态：不会发生死锁，可以分配资源\n   * 不安全状态：可能发生死锁，不分配资源，进程进入等待资源状态，并恢复系统状态\n\n# 例题 1\n\n假如现在有 p0 ~ p4 共五个进程，abc 三类资源，个数为（10,5,7）。在某一时刻，资源剩余量为（3,3,2），各个进程的最大需求量、已分配量和需求量如下图所示：\n\n\n\n如何检测当前是否处于安全状态呢？尝试寻找安全序列：\n\n * 当前剩余资源（3,3,2），无法满足 p0 需要的（7,4,3），所以不能首先分配给 p0；但是可以满足 p1 需要的（1,2,2），p3 需要的（0,1,1），所以可以分配给 p1 和 p3，p1 和 p3 进入安全序列。\n * p1 和 p3 执行完之后，归还资源，剩余资源（3,3,2）+（2,0,0）+（2,1,1）=（7,4,3），可以满足 p0 需要的（7,4,3），p2 需要的（6,0,0），p4 需要的（4,3,1），所以 p0、p2、p4 依次进入安全序列。\n * 所以存在安全序列 p1->p3->p0->p2->p4 ，使得按照这个顺序分配资源后，每个进程都能拿到需要的资源并顺利完成，所以该状态是安全状态。\n\n看另一种情况。假如现在有 p0 ~ p4 共五个进程，abc 三类资源，个数为（10,5,7）。在某一时刻，资源剩余量为（3,3,2），各个进程的最大需求量、已分配量和需求量如下图所示：\n\n\n\n当尝试寻找安全序列的时候，容易发现 p1 p3 可以满足，所以 p1 p3 进入安全序列，此后剩余资源为（7,4,3）。又由于 p0 p2 p4 都是无法满足的，所以实际上并不存在一个安全序列使得所有进程都能被分配资源。因此状态是不安全状态，可能发生死锁，取消资源分配。\n\n# 例题 2\n\nt0 时刻安全状态检查。如果 t0 时刻都不安全，则后面的部分都不用做了。但是考试时 t0 都是安全的。\n\n\n\n安全序列之一：<p1,p3,p4,p2,p0>\n\n# 例题 3\n\n在银行家算法中，若出现下述资源分配情况，试问：\n\nprocess   allocation   need   available\np0        0032         0012   1622\np1        1000         1750   \np2        1354         2356   \np3        0332         0652   \np4        0014         0656   \n\n(1) 该状态是否安全？\n\np0 1622+0032=1654\np3 1654+0332=1986\np1 1986+1000=2986\np4 2986+0014=299 10\np2 299 10+1354=3 12 14 14\n故存在安全序列p0 p3 p1 p4 p2\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n(2) 若进程 p2 提出请求 request (1,2,2,2) 后，系统能否将资源分配给它？\n\np2的allocation加上1 2 2 2为2 5 7 6，need变为1 1 3 4， available变为0 4 0 0\n由(1)可知，此时系统资源无法满足任何一个进程，安全性检查不通过，无法分配资源\n\n\n1\n2\n\n1\n2\n\n\n\n# 检测死锁\n\n\n# 简化进程 - 资源分配图\n\n# 各类资源只有一个\n\n当各类资源只有一个的时候，可以把资源分配图化简为一个等待图（wait-for graph），比如说 a 进程请求 x 资源、x 资源被 b 进程占有，这个过程可以被简化为 a 进程等待 b 进程。比如说下面，左图被转化为对应的右图：\n\n\n\n死锁定理：有环路，且每个类型的资源只有一个，则一定会出现死锁。\n\n * 如果进程 - 资源分配图中无环路，则此时系统没有发生死锁。\n * 如果进程 - 资源分配图中有环路，且每个资源类中仅有一个资源，则系统中发生了死锁，此时，环路是系统发生死锁的充分和必要条件，环路中的进程便为死锁进程。\n * 如果进程 - 资源分配图中有环路，且涉及的资源类中有多个资源，则环路的存在只是产生死锁的必要条件而不是充分条件。\n\n# 各类资源有多个\n\n各类资源有多个的时候，我们可能需要根据给定表或给定图检测是否有死锁。对于前者，可以沿用之前的安全性算法进行检测；对于后者，可以尝试简化资源分配图。\n\n给定一个资源分配图为例：\n\n\n\n约定蓝色线为请求边，黑色线为分配边，资源中的一个圆点代表一个该类资源。那么 p1 占有两个 r1 资源，请求一个 r2 资源；p2 占有一个 r2 资源，一个 r1 资源，请求一个 r1 资源。\n\n * 首先找出非阻塞非孤立的进程点。p1 p2 都不是孤立的，所谓非阻塞指的是进程请求的资源数量足够，比如说 p2 请求 r1，由于 r1 已经有两个被 p1 占有，一个被 p2 占有，无多余资源，所以 p2 是阻塞的；而 p1 请求 r2，因为 r2 只有一个被 p2 占有，有多余资源，p1 是非阻塞的。这样就找到了符合条件的进程点 p1\n * 去除这样的点的所有边。那么就会去除 p1 的所有边，归还所有资源。p1 成为孤立点\n * 重复第一步和第二步。此时，因为这次 p2 请求的 r2 资源是足够的（被 p1 释放了），所以 p2 是非阻塞非孤立的点，把他的全部边去除\n * 由于图中所有的边都能被消除，所以称该图可以被简化，因此它不存在死锁（如果不可简化，则存在死锁）\n\n> \n\n又比如下面这种情况：\n\n\n\n首先还是找一个非孤立非阻塞的点，很显然只有 p3 符合要求。之后把 p3 的分配边去掉，会发现 p1 和 p2 都是非孤立阻塞的点，它们的边都无法消除。此时就说该资源分配图不能简化，因此存在死锁。\n\n\n# 解除死锁\n\n\n# 资源剥夺法\n\n将部分死锁的进程挂起并抢占它的资源，将这些资源分配给其它的死锁进程。但应防止被挂起的进程长时间得不到资源而饥饿。\n\n> 注意不是抢占非死锁进程的资源。\n\n\n# 终止进程法\n\n强制终止部分或全部死锁进程，并剥夺它们的资源。这种方式的优点是实现简单，但可能付出很大的代价。因为有些进程可能已经运行了很长时间，一旦被终止就功亏一篑了。\n\n\n# 进程回退法\n\n让一个或多个死锁进程回退到足以避免死锁的地步。这要求系统必须记录进程的历史信息，设置还原点。\n\n> 无论是哪种方法，都可以从以下角度考虑需要做出牺牲的进程：\n> \n>  * 优先级比较低的进程做出牺牲\n>  * 占用过多资源的进程做出牺牲\n>  * 执行时间长的进程不做出牺牲\n>  * 快要完成的进程不做出牺牲\n>  * 交互式进程不做出牺牲",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"连续内存分配",frontmatter:{title:"连续内存分配",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/e66b46/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/05.%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/04.%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html",relativePath:"01.操作系统/05.第四章 存储器管理/04.连续内存分配.md",key:"v-a2241a92",path:"/pages/e66b46/",headers:[{level:2,title:"外部碎片和内部碎片",slug:"外部碎片和内部碎片",normalizedTitle:"外部碎片和内部碎片",charIndex:13},{level:2,title:"单一连续分配",slug:"单一连续分配",normalizedTitle:"单一连续分配",charIndex:100},{level:2,title:"固定分区分配",slug:"固定分区分配",normalizedTitle:"固定分区分配",charIndex:214},{level:2,title:"动态分区分配",slug:"动态分区分配",normalizedTitle:"动态分区分配",charIndex:660},{level:3,title:"概括",slug:"概括",normalizedTitle:"概括",charIndex:671},{level:3,title:"主要过程",slug:"主要过程",normalizedTitle:"主要过程",charIndex:956},{level:3,title:"基于顺序搜索的算法",slug:"基于顺序搜索的算法",normalizedTitle:"基于顺序搜索的算法",charIndex:1221},{level:4,title:"首次适应（FF）",slug:"首次适应-ff",normalizedTitle:"首次适应（ff）",charIndex:1234},{level:4,title:"邻近适应（NF）",slug:"邻近适应-nf",normalizedTitle:"邻近适应（nf）",charIndex:1466},{level:4,title:"最佳适应（BF）",slug:"最佳适应-bf",normalizedTitle:"最佳适应（bf）",charIndex:1710},{level:4,title:"最坏适应 （WF）",slug:"最坏适应-wf",normalizedTitle:"最坏适应 （wf）",charIndex:2064},{level:4,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:2328},{level:3,title:"基于索引搜索的算法",slug:"基于索引搜索的算法",normalizedTitle:"基于索引搜索的算法",charIndex:2438},{level:4,title:"快速适应",slug:"快速适应",normalizedTitle:"快速适应",charIndex:2521},{level:4,title:"伙伴系统",slug:"伙伴系统",normalizedTitle:"伙伴系统",charIndex:2801},{level:3,title:"哈希算法",slug:"哈希算法",normalizedTitle:"哈希算法",charIndex:2818},{level:2,title:"动态可重定位分区分配",slug:"动态可重定位分区分配",normalizedTitle:"动态可重定位分区分配",charIndex:4307}],headersStr:"外部碎片和内部碎片 单一连续分配 固定分区分配 动态分区分配 概括 主要过程 基于顺序搜索的算法 首次适应（FF） 邻近适应（NF） 最佳适应（BF） 最坏适应 （WF） 总结 基于索引搜索的算法 快速适应 伙伴系统 哈希算法 动态可重定位分区分配",content:"# 连续内存分配\n\n\n# 外部碎片和内部碎片\n\n * 外部碎片指的是尚未分配出去、由于太小而无法分配出去的内存空间（化整为零）\n * 内部碎片指的是已经分配出去、但没有完全得到利用的内存空间\n\n\n# 单一连续分配\n\n单一连续分配只适用于单用户、单任务的操作系统中，它会把整个内存区划分为系统区和用户区，一道用户程序就会独占整个用户区，因此存储器的利用率非常低、内部碎片很大（分配了整个用户区，但实际用到的空间并不多）。\n\n\n# 固定分区分配\n\n固定分区分配是最简单的多道程序的存储管理方式，依然是将整个内存区划分为系统区和用户区，但是用户区进一步细分：划分为多个固定大小的分区，系统启动后就已经分好了分区，一个分区放一个进程。\n\n每个分区的大小可以相等也可以不等：\n\n * 如果每个分区大小相等，缺乏灵活性：对于小进程，无法利用全部空间而产生内部碎片；对于大进程，找不到大小足够的分区。\n\n * 如果每个分区的大小不等，提高了灵活度，可以将用户区划分为大量的小分区、适量的中分区、少量的大分区，并维护一张记录了分区号、分区大小、分区起始地址、分区分配状态的分区使用表。每次需要为进程分配内存空间的时候，先在这张表上进行检索，找到一个合适的分区分配给它。\n   \n   这种划分方式可以认为不存在过小的、分配不出去的内存空间，不会产生外部碎片；但是，由于提前划分了分区，不能保证一个进程完全利用完某个分区，分区会产生内部碎片：\n   \n   \n   \n   > 浪费了 7+23+87+211K=328K 的空间\n\n\n# 动态分区分配\n\n\n# 概括\n\n动态分区分配方式比前面的分配方式要灵活很多，类似于按需分配，不是预先划分好，而是进程需要多少内存空间，就给它多少内存空间。\n\n但这种分配方式需要考虑的问题是，当一个进程有多个空闲的内存分区可供选择的时候，它应该使用哪个空间呢？比如进程 2 运行完释放了 20K 的内存空间，此时进程 4 进来，也需要用到 20K 的内存空间，它既可以选择占用进程 2 释放的空间，也可以选择占用后面没被用到的一大片空间。\n\n因此，我们需要一种算法来决定进程 4 的选择，而且为了更好地描述内存使用情况，我们同样要像固定分区分配一样维护一张空闲分区表或者一个空闲分区链。\n\n\n# 主要过程\n\n假设进程 X 需要用到 x 大小的内存空间，在某种算法下，系统会检索空闲分区表或者空闲分区链，决定将某个空闲分区分配给这个进程。假设这个空闲分区大小为 y（y>x），若 y-x 的值小于预先设定的一个阈值，说明进程可以充分利用这个空闲分区，可以将整个分区直接分配给进程；若 y-x 的值大于这个阈值，说明空闲分区无法得到完全的利用，可以将整个分区能够被充分利用的那部分（也即 x）划分给进程，而剩下的 y-x 则继续留在空闲分区表（因为只记录空闲分区，所以没有 “状态” 项）或者空闲分区链（不讲不考察）中。\n\n\n# 基于顺序搜索的算法\n\n# 首次适应（FF）\n\n将多个空闲分区按照地址递增的顺序排列，每次分配内存的时候顺序查找空闲分区表，找到第一个大小能满足要求的空闲分区。\n\n * 由于地址一开始就是确定下来的，能够保证顺序始终是递增的，因此这种算法无需频繁地变更空闲分区的顺序，而且每次优先利用低地址空间，保证了高地址空间有足够大的空闲区域可供大进程使用。\n * 但是，因为每次优先利用低地址空间，所以低地址空间被不断分割，产生了大量的外部碎片；而且，每次都是从头开始寻找空闲空间，效率并不高。\n\n# 邻近适应（NF）\n\n邻近适应算法（循环首次适应算法）克服了首次适应算法的缺点，它同样是将多个空闲分区按照地址递增的顺序排列，不同的是，每次查找都是从上次查找结束的位置开始查找的\n\n * 不会从头开始一个个找，一定程度上提高了效率；而且，它会更趋向于往后推进，避免了对低地址空间重复地进行分割，进而避免了大量外部碎片的产生。\n\n * 优点同时也是缺点，由于邻近适应算法更趋向于往后推进，所以更可能分割高地址空间，这就破坏了首次适应算法的初衷，导致大进程可能没有足够的空闲空间可利用。\n\n# 最佳适应（BF）\n\n连续分配的方式规定，为各个进程分配的必须是一块连续的空间，因此对于一块内存空间来说，若它不断被分割，则意味着它能容纳下大进程的可能性越低。为了保证有足够的内存空间可以容纳大进程，基本思想应该是优先利用小的空闲分区，而保留大的空闲分区。\n\n最佳适应算法将空闲分区按照容量递增的顺序排列，每次分配内存的时候顺序查找空闲分区表，找到第一个大小能满足要求的空闲分区。\n\n * 分配操作主要集中在小的空闲分区那里进行，保证了有大的空闲分区可以用来容纳大进程。\n * 因为要按照容量递增的顺序排列，而每次内存的分配和回收都会改变某一块空间的大小，每次在进行分配和回收的时候，基本都要重新进行排序，算法开销大。而且，由于分配操作集中在小的空闲分区进行，导致它们不断被分割，容易产生大量外部碎片。\n\n# 最坏适应 （WF）\n\n为了克服最佳适应算法的缺点，最坏适应算法规定，将空闲分区按照容量递减的顺序排列，每次分配内存的时候顺序查找空闲分区表，找到第一个大小能满足要求的空闲分区。\n\n * 最坏适应算法优先使用大的空闲分区，而大的空闲分区由于容量充足，即使被不断分割，也可以保证剩余空间不至于太小，依然能够被新的进程利用，大幅度减少了外部碎片的产生。\n * 但是，这又破坏了最佳适应算法的初衷，因为优先使用大的空闲分区，很容易导致后续的大进程没有足够大小的空闲分区可以利用。并且，这种算法也无法避免分配和回收之后的重新排序。\n\n# 总结\n\n\n\n由于动态分区分配不是事先划分好区域，而是 “按需分配”，所以不会出现区域划分出去后无法完全得到利用的情况，也即不会产生内部碎片；但是可能出现内存空间太小而无法被分配出去的情况，也即可能产生外部碎片。\n\n\n# 基于索引搜索的算法\n\n当系统很大的时候，内存分区会很多，这时候还采取基于顺序搜索的动态分区分配算法的话，效率并不高。因此出现了基于索引搜索的动态分区分配算法。\n\n# 快速适应\n\n快速适应算法（分类搜索算法）将空闲分区按照进程常用的空间大小进行分类，比如 2KB 为一类，4KB 为一类，6KB 为一类等，对于每一类空闲分区，会有一个单独的空闲分区链表。此外，还会有一张总的管理索引表，索引表的每一个表项对应了一类空闲分区。\n\n在为进程分配分区的时候，首先会根据进程长度，从索引表中找到能容纳它的最小空闲区链表，接着将该链表的第一块分配给进程。\n\n * 因为前面已经进行了合理的分类，因此这种方法不会对任何分区产生分割，也不会产生外部或者内部碎片，并且查找效率很高\n * 但是，回收、合并分区时的算法复杂，系统开销比较大\n\n# 伙伴系统\n\n> 接下来的伙伴关系和哈希算法为自学内容\n\n\n\n举个例子\n\n假设系统总的内存为 512KB，现有进程活动如下：\n\n * 进程 A 请求 100KB，进程 B 请求 50KB，进程 C 请求 100KB\n * 进程 A 释放 100KB\n * 进程 D 请求 20KB\n * 进程 D 释放 20KB\n * 进程 B 释放 50KB\n\n按照伙伴系统的算法，内存的分配和回收是怎么进行的呢？\n\n首先，一开始肯定是整片空的内存空间，进程 A 请求 100KB，因为 64<100<128，即 26<100<27，所以寻找是否有 27=128 的空闲分区，当然是没有的（目前只有 512KB)，所以寻找是否有 28=256 的空闲分区，也没有，所以寻找是否有 29=512 的空闲分区，找到了，此时就把 512KB 一分为二：\n\n\n\n一半的 256KB 加入到对应的空闲分区链表，一半的 256KB 用于分配，对这一半继续一分为二：\n\n\n\n一半的 128KB 加入到对应的空闲分区链表，一半的 128KB 用于分配，这一半对进程 A 来说足够了，于是占用它：\n\n\n\n进程 B 请求 50KB，因为 32<50<64，即 25<100<26，所以寻找是否有 26=64 的空闲分区，没有，所以寻找是否有 27=128，找到了，此时就把 128KB 一分为二：\n\n\n\n一半的 64KB 加入到对应的空闲分区链表，一半的 64KB 用于分配，这一半对进程 B 来说足够了，于是占用它：\n\n\n\n进程 C 请求 100KB，因为 64<100<128，即 26<100<27，所以寻找是否有 27=128 的空闲分区，没有，所以寻找是否有 28=256 的空闲分区，找到了，此时就把 256KB 一分为二：\n\n\n\n一半的 128KB 加入到对应的空闲分区链表，一半的 128KB 用于分配，这一半对进程 C 来说足够了，于是占用它：\n\n\n\n进程 A 释放 100KB：\n\n\n\n进程 D 请求 20KB，因为 16<20<32，即 24<100<25，所以寻找是否有 25=32 的空闲分区，没有，所以寻找是否有 26=64 的空闲分区，找到了，此时就把 64KB 一分为二：\n\n\n\n一半的 32KB 加入到对应的空闲分区链表，一半的 32KB 用于分配，这一半对进程 D 来说足够了，于是占用它：\n\n\n\n进程 D 释放 20KB，回收 32KB，由于事先已经有一个 32KB，所以此时两个互为伙伴的 32KB 进行合并：\n\n\n\n进程 B 释放 50KB，回收 64KB，由于事先已经有一个 64KB，所以此时两个互为伙伴的 64KB 进行合并，形成 128KB，由于事先已经有一个 128KB，所以此时两个互为伙伴的 128KB 进行合并，形成 256KB：\n\n\n\n计算伙伴地址的方法：对于给定的内存块，若它的大小为 2k，起始地址为 x，\n\n * 如果 x/2^k 为奇数，则伙伴地址为 x - 2^k\n * 如果 x/2^k 为偶数，则伙伴地址为 x + 2^k\n\n\n# 哈希算法\n\n快速适应和伙伴系统都是将空闲分区按照大小进行分类，并为每一类建立一个独立的空闲分区链表，再用一个总的索引表进行记录。不过，如果分类过多，则索引表的表项也会过多，这时候搜索索引表的时间开销就会比较大。\n\n因此，哈希算法选择建立一张哈希表（而不是普通的索引表），这张哈希表以空闲分区大小作为关键字，每次需要进行分配的时候，会根据所需空闲分区的大小，通过哈希函数快速计算得到该空闲分区在表中的位置，从而得到对应的空闲分区链表。\n\n\n# 动态可重定位分区分配\n\n动态可重定位分区分配算法与动态分区分配算法基本一致，仅仅增加了紧凑功能。\n\n连续分配为某个进程分配的必须是一块连续的空间，若多个空闲分区不是相邻的，即便它们的大小总和已经满足进程的需求，也无法进行分配。采用紧凑技术解决这个问题。紧凑技术把内存中各个进程进行移动并使其相邻，从而化零为整，带来了更大的空闲分区：\n\n\n\n在这里会发现，每次发生紧凑，各个程序和数据的物理地址就要发生改变。\n\n * 假定我们先前采用的是静态重定位装入方式，那么在模块装入内存的时候，就已经把逻辑地址转换为物理地址了，每次发生紧凑，都要在程序上重新修改一次物理地址。\n * 如果我们采用动态重定位装入方式，各个程序和数据的地址全部都是逻辑地址，当程序需要访问地址时，无需修改程序上的地址，只需要将该逻辑地址与当前重定位寄存器里存放的物理起始地址进行相加。每次发生紧凑时，也只需要用紧凑后的新起始地址去替换重定位寄存器里的旧起始地址。",normalizedContent:"# 连续内存分配\n\n\n# 外部碎片和内部碎片\n\n * 外部碎片指的是尚未分配出去、由于太小而无法分配出去的内存空间（化整为零）\n * 内部碎片指的是已经分配出去、但没有完全得到利用的内存空间\n\n\n# 单一连续分配\n\n单一连续分配只适用于单用户、单任务的操作系统中，它会把整个内存区划分为系统区和用户区，一道用户程序就会独占整个用户区，因此存储器的利用率非常低、内部碎片很大（分配了整个用户区，但实际用到的空间并不多）。\n\n\n# 固定分区分配\n\n固定分区分配是最简单的多道程序的存储管理方式，依然是将整个内存区划分为系统区和用户区，但是用户区进一步细分：划分为多个固定大小的分区，系统启动后就已经分好了分区，一个分区放一个进程。\n\n每个分区的大小可以相等也可以不等：\n\n * 如果每个分区大小相等，缺乏灵活性：对于小进程，无法利用全部空间而产生内部碎片；对于大进程，找不到大小足够的分区。\n\n * 如果每个分区的大小不等，提高了灵活度，可以将用户区划分为大量的小分区、适量的中分区、少量的大分区，并维护一张记录了分区号、分区大小、分区起始地址、分区分配状态的分区使用表。每次需要为进程分配内存空间的时候，先在这张表上进行检索，找到一个合适的分区分配给它。\n   \n   这种划分方式可以认为不存在过小的、分配不出去的内存空间，不会产生外部碎片；但是，由于提前划分了分区，不能保证一个进程完全利用完某个分区，分区会产生内部碎片：\n   \n   \n   \n   > 浪费了 7+23+87+211k=328k 的空间\n\n\n# 动态分区分配\n\n\n# 概括\n\n动态分区分配方式比前面的分配方式要灵活很多，类似于按需分配，不是预先划分好，而是进程需要多少内存空间，就给它多少内存空间。\n\n但这种分配方式需要考虑的问题是，当一个进程有多个空闲的内存分区可供选择的时候，它应该使用哪个空间呢？比如进程 2 运行完释放了 20k 的内存空间，此时进程 4 进来，也需要用到 20k 的内存空间，它既可以选择占用进程 2 释放的空间，也可以选择占用后面没被用到的一大片空间。\n\n因此，我们需要一种算法来决定进程 4 的选择，而且为了更好地描述内存使用情况，我们同样要像固定分区分配一样维护一张空闲分区表或者一个空闲分区链。\n\n\n# 主要过程\n\n假设进程 x 需要用到 x 大小的内存空间，在某种算法下，系统会检索空闲分区表或者空闲分区链，决定将某个空闲分区分配给这个进程。假设这个空闲分区大小为 y（y>x），若 y-x 的值小于预先设定的一个阈值，说明进程可以充分利用这个空闲分区，可以将整个分区直接分配给进程；若 y-x 的值大于这个阈值，说明空闲分区无法得到完全的利用，可以将整个分区能够被充分利用的那部分（也即 x）划分给进程，而剩下的 y-x 则继续留在空闲分区表（因为只记录空闲分区，所以没有 “状态” 项）或者空闲分区链（不讲不考察）中。\n\n\n# 基于顺序搜索的算法\n\n# 首次适应（ff）\n\n将多个空闲分区按照地址递增的顺序排列，每次分配内存的时候顺序查找空闲分区表，找到第一个大小能满足要求的空闲分区。\n\n * 由于地址一开始就是确定下来的，能够保证顺序始终是递增的，因此这种算法无需频繁地变更空闲分区的顺序，而且每次优先利用低地址空间，保证了高地址空间有足够大的空闲区域可供大进程使用。\n * 但是，因为每次优先利用低地址空间，所以低地址空间被不断分割，产生了大量的外部碎片；而且，每次都是从头开始寻找空闲空间，效率并不高。\n\n# 邻近适应（nf）\n\n邻近适应算法（循环首次适应算法）克服了首次适应算法的缺点，它同样是将多个空闲分区按照地址递增的顺序排列，不同的是，每次查找都是从上次查找结束的位置开始查找的\n\n * 不会从头开始一个个找，一定程度上提高了效率；而且，它会更趋向于往后推进，避免了对低地址空间重复地进行分割，进而避免了大量外部碎片的产生。\n\n * 优点同时也是缺点，由于邻近适应算法更趋向于往后推进，所以更可能分割高地址空间，这就破坏了首次适应算法的初衷，导致大进程可能没有足够的空闲空间可利用。\n\n# 最佳适应（bf）\n\n连续分配的方式规定，为各个进程分配的必须是一块连续的空间，因此对于一块内存空间来说，若它不断被分割，则意味着它能容纳下大进程的可能性越低。为了保证有足够的内存空间可以容纳大进程，基本思想应该是优先利用小的空闲分区，而保留大的空闲分区。\n\n最佳适应算法将空闲分区按照容量递增的顺序排列，每次分配内存的时候顺序查找空闲分区表，找到第一个大小能满足要求的空闲分区。\n\n * 分配操作主要集中在小的空闲分区那里进行，保证了有大的空闲分区可以用来容纳大进程。\n * 因为要按照容量递增的顺序排列，而每次内存的分配和回收都会改变某一块空间的大小，每次在进行分配和回收的时候，基本都要重新进行排序，算法开销大。而且，由于分配操作集中在小的空闲分区进行，导致它们不断被分割，容易产生大量外部碎片。\n\n# 最坏适应 （wf）\n\n为了克服最佳适应算法的缺点，最坏适应算法规定，将空闲分区按照容量递减的顺序排列，每次分配内存的时候顺序查找空闲分区表，找到第一个大小能满足要求的空闲分区。\n\n * 最坏适应算法优先使用大的空闲分区，而大的空闲分区由于容量充足，即使被不断分割，也可以保证剩余空间不至于太小，依然能够被新的进程利用，大幅度减少了外部碎片的产生。\n * 但是，这又破坏了最佳适应算法的初衷，因为优先使用大的空闲分区，很容易导致后续的大进程没有足够大小的空闲分区可以利用。并且，这种算法也无法避免分配和回收之后的重新排序。\n\n# 总结\n\n\n\n由于动态分区分配不是事先划分好区域，而是 “按需分配”，所以不会出现区域划分出去后无法完全得到利用的情况，也即不会产生内部碎片；但是可能出现内存空间太小而无法被分配出去的情况，也即可能产生外部碎片。\n\n\n# 基于索引搜索的算法\n\n当系统很大的时候，内存分区会很多，这时候还采取基于顺序搜索的动态分区分配算法的话，效率并不高。因此出现了基于索引搜索的动态分区分配算法。\n\n# 快速适应\n\n快速适应算法（分类搜索算法）将空闲分区按照进程常用的空间大小进行分类，比如 2kb 为一类，4kb 为一类，6kb 为一类等，对于每一类空闲分区，会有一个单独的空闲分区链表。此外，还会有一张总的管理索引表，索引表的每一个表项对应了一类空闲分区。\n\n在为进程分配分区的时候，首先会根据进程长度，从索引表中找到能容纳它的最小空闲区链表，接着将该链表的第一块分配给进程。\n\n * 因为前面已经进行了合理的分类，因此这种方法不会对任何分区产生分割，也不会产生外部或者内部碎片，并且查找效率很高\n * 但是，回收、合并分区时的算法复杂，系统开销比较大\n\n# 伙伴系统\n\n> 接下来的伙伴关系和哈希算法为自学内容\n\n\n\n举个例子\n\n假设系统总的内存为 512kb，现有进程活动如下：\n\n * 进程 a 请求 100kb，进程 b 请求 50kb，进程 c 请求 100kb\n * 进程 a 释放 100kb\n * 进程 d 请求 20kb\n * 进程 d 释放 20kb\n * 进程 b 释放 50kb\n\n按照伙伴系统的算法，内存的分配和回收是怎么进行的呢？\n\n首先，一开始肯定是整片空的内存空间，进程 a 请求 100kb，因为 64<100<128，即 26<100<27，所以寻找是否有 27=128 的空闲分区，当然是没有的（目前只有 512kb)，所以寻找是否有 28=256 的空闲分区，也没有，所以寻找是否有 29=512 的空闲分区，找到了，此时就把 512kb 一分为二：\n\n\n\n一半的 256kb 加入到对应的空闲分区链表，一半的 256kb 用于分配，对这一半继续一分为二：\n\n\n\n一半的 128kb 加入到对应的空闲分区链表，一半的 128kb 用于分配，这一半对进程 a 来说足够了，于是占用它：\n\n\n\n进程 b 请求 50kb，因为 32<50<64，即 25<100<26，所以寻找是否有 26=64 的空闲分区，没有，所以寻找是否有 27=128，找到了，此时就把 128kb 一分为二：\n\n\n\n一半的 64kb 加入到对应的空闲分区链表，一半的 64kb 用于分配，这一半对进程 b 来说足够了，于是占用它：\n\n\n\n进程 c 请求 100kb，因为 64<100<128，即 26<100<27，所以寻找是否有 27=128 的空闲分区，没有，所以寻找是否有 28=256 的空闲分区，找到了，此时就把 256kb 一分为二：\n\n\n\n一半的 128kb 加入到对应的空闲分区链表，一半的 128kb 用于分配，这一半对进程 c 来说足够了，于是占用它：\n\n\n\n进程 a 释放 100kb：\n\n\n\n进程 d 请求 20kb，因为 16<20<32，即 24<100<25，所以寻找是否有 25=32 的空闲分区，没有，所以寻找是否有 26=64 的空闲分区，找到了，此时就把 64kb 一分为二：\n\n\n\n一半的 32kb 加入到对应的空闲分区链表，一半的 32kb 用于分配，这一半对进程 d 来说足够了，于是占用它：\n\n\n\n进程 d 释放 20kb，回收 32kb，由于事先已经有一个 32kb，所以此时两个互为伙伴的 32kb 进行合并：\n\n\n\n进程 b 释放 50kb，回收 64kb，由于事先已经有一个 64kb，所以此时两个互为伙伴的 64kb 进行合并，形成 128kb，由于事先已经有一个 128kb，所以此时两个互为伙伴的 128kb 进行合并，形成 256kb：\n\n\n\n计算伙伴地址的方法：对于给定的内存块，若它的大小为 2k，起始地址为 x，\n\n * 如果 x/2^k 为奇数，则伙伴地址为 x - 2^k\n * 如果 x/2^k 为偶数，则伙伴地址为 x + 2^k\n\n\n# 哈希算法\n\n快速适应和伙伴系统都是将空闲分区按照大小进行分类，并为每一类建立一个独立的空闲分区链表，再用一个总的索引表进行记录。不过，如果分类过多，则索引表的表项也会过多，这时候搜索索引表的时间开销就会比较大。\n\n因此，哈希算法选择建立一张哈希表（而不是普通的索引表），这张哈希表以空闲分区大小作为关键字，每次需要进行分配的时候，会根据所需空闲分区的大小，通过哈希函数快速计算得到该空闲分区在表中的位置，从而得到对应的空闲分区链表。\n\n\n# 动态可重定位分区分配\n\n动态可重定位分区分配算法与动态分区分配算法基本一致，仅仅增加了紧凑功能。\n\n连续分配为某个进程分配的必须是一块连续的空间，若多个空闲分区不是相邻的，即便它们的大小总和已经满足进程的需求，也无法进行分配。采用紧凑技术解决这个问题。紧凑技术把内存中各个进程进行移动并使其相邻，从而化零为整，带来了更大的空闲分区：\n\n\n\n在这里会发现，每次发生紧凑，各个程序和数据的物理地址就要发生改变。\n\n * 假定我们先前采用的是静态重定位装入方式，那么在模块装入内存的时候，就已经把逻辑地址转换为物理地址了，每次发生紧凑，都要在程序上重新修改一次物理地址。\n * 如果我们采用动态重定位装入方式，各个程序和数据的地址全部都是逻辑地址，当程序需要访问地址时，无需修改程序上的地址，只需要将该逻辑地址与当前重定位寄存器里存放的物理起始地址进行相加。每次发生紧凑时，也只需要用紧凑后的新起始地址去替换重定位寄存器里的旧起始地址。",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"虚拟存储器概述",frontmatter:{title:"虚拟存储器概述",date:"2023-01-05T20:56:18.000Z",permalink:"/pages/f6080a/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/06.%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/01.%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0.html",relativePath:"01.操作系统/06.第五章 虚拟存储器/01.虚拟存储器概述.md",key:"v-95f67a58",path:"/pages/f6080a/",headers:[{level:2,title:"局部性原理",slug:"局部性原理",normalizedTitle:"局部性原理",charIndex:14},{level:2,title:"工作情况",slug:"工作情况",normalizedTitle:"工作情况",charIndex:34},{level:2,title:"特征",slug:"特征",normalizedTitle:"特征",charIndex:324}],headersStr:"局部性原理 工作情况 特征",content:"# 虚拟存储器概述\n\n\n# 局部性原理\n\n\n\n> 及时即使\n\n\n# 工作情况\n\n把内存中暂时不能运行或者暂时不用的程序、数据调动到虚拟存储器上。或者说把程序的一部分放入内存、一部分放在虚拟存储器。程序运行时，如果所需要访问的页（段）已调入内存，便可继续执行下去；但如果程序所要访问的页（段）尚未调入内存（即缺页或缺段），则程序利用 OS 所提供的请求调页（段）功能，将它们调入内存，以使进程继续执行；如果此时，内存已满，则需利用页（段）置换功能。\n\n页面对换 ：请求分页存储管理（基本分页 + 页面对换）\n\n分段对换 ：请求分段存储管理（基本分段 + 分段对换）\n\n挂起是对进程而言的，而不是线程；为了管理虚拟存储器，才将进程分为页或段。\n\n\n# 特征\n\n虚拟存储器的特征：虚拟性、多次性、对换性\n\n",normalizedContent:"# 虚拟存储器概述\n\n\n# 局部性原理\n\n\n\n> 及时即使\n\n\n# 工作情况\n\n把内存中暂时不能运行或者暂时不用的程序、数据调动到虚拟存储器上。或者说把程序的一部分放入内存、一部分放在虚拟存储器。程序运行时，如果所需要访问的页（段）已调入内存，便可继续执行下去；但如果程序所要访问的页（段）尚未调入内存（即缺页或缺段），则程序利用 os 所提供的请求调页（段）功能，将它们调入内存，以使进程继续执行；如果此时，内存已满，则需利用页（段）置换功能。\n\n页面对换 ：请求分页存储管理（基本分页 + 页面对换）\n\n分段对换 ：请求分段存储管理（基本分段 + 分段对换）\n\n挂起是对进程而言的，而不是线程；为了管理虚拟存储器，才将进程分为页或段。\n\n\n# 特征\n\n虚拟存储器的特征：虚拟性、多次性、对换性\n\n",charsets:{cjk:!0}},{title:"非连续内存分配",frontmatter:{title:"非连续内存分配",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/a8d561/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/05.%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/05.%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html",relativePath:"01.操作系统/05.第四章 存储器管理/05.非连续内存分配.md",key:"v-55469fce",path:"/pages/a8d561/",headers:[{level:2,title:"基本分页存储管理",slug:"基本分页存储管理",normalizedTitle:"基本分页存储管理",charIndex:79},{level:3,title:"基本思路",slug:"基本思路",normalizedTitle:"基本思路",charIndex:92},{level:3,title:"页面、页框",slug:"页面、页框",normalizedTitle:"页面、页框",charIndex:278},{level:3,title:"地址转换的思路",slug:"地址转换的思路",normalizedTitle:"地址转换的思路",charIndex:612},{level:4,title:"十进制地址",slug:"十进制地址",normalizedTitle:"十进制地址",charIndex:688},{level:4,title:"二进制地址",slug:"二进制地址",normalizedTitle:"二进制地址",charIndex:1100},{level:4,title:"例题",slug:"例题",normalizedTitle:"例题",charIndex:1385},{level:3,title:"页表",slug:"页表",normalizedTitle:"页表",charIndex:489},{level:3,title:"地址变换机构",slug:"地址变换机构",normalizedTitle:"地址变换机构",charIndex:1625},{level:4,title:"基本地址变换机构",slug:"基本地址变换机构",normalizedTitle:"基本地址变换机构",charIndex:1635},{level:4,title:"例题1",slug:"例题1",normalizedTitle:"例题 1",charIndex:2160},{level:4,title:"具有快表的地址变换机构",slug:"具有快表的地址变换机构",normalizedTitle:"具有快表的地址变换机构",charIndex:2481},{level:4,title:"例题2",slug:"例题2",normalizedTitle:"例题 2",charIndex:3366},{level:3,title:"页表项的大小",slug:"页表项的大小",normalizedTitle:"页表项的大小",charIndex:1928},{level:3,title:"两级页表",slug:"两级页表",normalizedTitle:"两级页表",charIndex:4957},{level:4,title:"单级页表占用过大的连续内存空间的问题",slug:"单级页表占用过大的连续内存空间的问题",normalizedTitle:"单级页表占用过大的连续内存空间的问题",charIndex:4965},{level:4,title:"引入两级页表",slug:"引入两级页表",normalizedTitle:"引入两级页表",charIndex:5285},{level:4,title:"单级页表常驻内存的问题",slug:"单级页表常驻内存的问题",normalizedTitle:"单级页表常驻内存的问题",charIndex:5916},{level:4,title:"多级页表",slug:"多级页表",normalizedTitle:"多级页表",charIndex:6017},{level:3,title:"习题",slug:"习题",normalizedTitle:"习题",charIndex:6652},{level:2,title:"基本分段存储管理",slug:"基本分段存储管理",normalizedTitle:"基本分段存储管理",charIndex:8152},{level:3,title:"基本思路",slug:"基本思路-2",normalizedTitle:"基本思路",charIndex:92},{level:3,title:"逻辑地址",slug:"逻辑地址",normalizedTitle:"逻辑地址",charIndex:645},{level:3,title:"段表",slug:"段表",normalizedTitle:"段表",charIndex:8725},{level:3,title:"段表项的大小",slug:"段表项的大小",normalizedTitle:"段表项的大小",charIndex:8934},{level:3,title:"地址转换",slug:"地址转换",normalizedTitle:"地址转换",charIndex:612},{level:3,title:"分页和分段的对比",slug:"分页和分段的对比",normalizedTitle:"分页和分段的对比",charIndex:9613},{level:4,title:"划分的角度和维度",slug:"划分的角度和维度",normalizedTitle:"划分的角度和维度",charIndex:9625},{level:4,title:"信息的共享和保护",slug:"信息的共享和保护",normalizedTitle:"信息的共享和保护",charIndex:9639},{level:4,title:"访存次数",slug:"访存次数",normalizedTitle:"访存次数",charIndex:9862},{level:2,title:"段页式存储管理",slug:"段页式存储管理",normalizedTitle:"段页式存储管理",charIndex:9963},{level:3,title:"基本思路",slug:"基本思路-3",normalizedTitle:"基本思路",charIndex:92},{level:3,title:"逻辑地址",slug:"逻辑地址-2",normalizedTitle:"逻辑地址",charIndex:645},{level:3,title:"段表",slug:"段表-2",normalizedTitle:"段表",charIndex:8725},{level:3,title:"地址转换",slug:"地址转换-2",normalizedTitle:"地址转换",charIndex:612},{level:3,title:"访存次数",slug:"访存次数-2",normalizedTitle:"访存次数",charIndex:9862}],headersStr:"基本分页存储管理 基本思路 页面、页框 地址转换的思路 十进制地址 二进制地址 例题 页表 地址变换机构 基本地址变换机构 例题1 具有快表的地址变换机构 例题2 页表项的大小 两级页表 单级页表占用过大的连续内存空间的问题 引入两级页表 单级页表常驻内存的问题 多级页表 习题 基本分段存储管理 基本思路 逻辑地址 段表 段表项的大小 地址转换 分页和分段的对比 划分的角度和维度 信息的共享和保护 访存次数 段页式存储管理 基本思路 逻辑地址 段表 地址转换 访存次数",content:"# 非连续内存分配\n\n固定分区分配容易产生内部碎片，动态分区分配容易产生外部碎片（虽然可以用紧凑技术解决，但是有一定的成本），都不是理想的解决方案。\n\n\n# 基本分页存储管理\n\n\n# 基本思路\n\n在连续分配中，一个进程不可被分割，只能整体放入一块连续的内存空间中；但在基本分页存储管理中，允许把一个进程按照固定大小 X 分割为多个部分，同时把内存也按照固定大小 X 分割为多个部分，并把前者对应地放到后者中（不要求连续存放）。通常来说，一个进程的最后一部分会小于 X ，这部分若放到内存的某个 X 空间中，仍然会产生碎片（这种碎片称为页内碎片）。\n\n\n# 页面、页框\n\n * 页框 (Page Frame)：具体来说，把内存分割为多个固定大小 X 的部分，这些部分就叫做页框 / 页帧 / 物理块 / 内存块，每个页框会有一个数字编号，第一个页框就从 0 开始\n\n * 页面 (Page)：同样，进程被分割为多个固定大小 X 的部分，这些部分就叫做页面 / 页，每个页面会有一个数字编号，第一个页面就从 0 开始\n\n\n\n若页面太小，虽然可使页内碎片减小、提高内存利用率，但是会使页表过长、降低页面换进换出的效率；若页面太大，则相反。因此页面的大小应是 2 的整数幂，通常为 1KB~8KB。\n\n系统以页框为单位为各个进程分配内存空间，一个页面就对应一个页框，它具体放到哪个页框是随意的，无需顾虑是否连续和先后顺序。\n\n\n# 地址转换的思路\n\n假设我们采用动态重定位方式进行模块装入，程序中是逻辑地址，但在程序执行到需要访问地址的时候，需要进行逻辑地址到物理地址的转换。\n\n# 十进制地址\n\n左边进程按照 50B 的大小分为 4 个页面，右边内存按照 50B 的大小分为若干个页框：\n\n\n\n在程序执行到指令 1 的时候，需要访问地址 80，这是一个逻辑地址，需要转换成对应的物理地址。转换步骤如下：\n\n * 计算逻辑地址的页号\n * 根据页号找到页号对应页面在内存中的起始地址\n * 计算逻辑地址在当前页面内的偏移量（页内偏移量）\n * 物理地址 = 起始地址 + 页内偏移量\n\n从左图可以看出，逻辑地址 80 在 1 号页面内，而 1 号页面对应的是右图中的红色页框，起始地址为 450；逻辑地址 80 在 1 号页面内的偏移量为 30；所以 物理地址 = 450 + 30 = 480\n\n也可以用计算的方法，在已知逻辑地址的情况下：\n\n * 页号 = 逻辑地址 / 页面大小 ，即 80/50 = 1 （取整数部分）\n * 页内偏移量 = 逻辑地址 % 页面大小 ，即 80%50 = 30\n\n# 二进制地址\n\n地址实际上是用 32 位二进制数表示的。这时候计算页号 P 和页内偏移量 W 实际上更加简单，因为地址本身已经包含了这两者的信息。\n\n以页面 / 页框大小 4KB 为例，用地址的前 20 位（红色部分，也叫高 20 位）表示页号 P，用地址的后 12 位（黑色部分，也叫低 12 位）表示页内偏移量 W。页内偏移量的位数可以表明每个页面的大小，即 212 = 4KB。0 号页、1 号页、2 号页的表示如下：\n\n\n\n若页面 / 页框大小为 1KB，也即 210B = 1024B，那么地址的前 22 位表示页号，剩余的 10 位表示页内偏移量：\n\n\n\n# 例题\n\n\n\n\n\n\n# 页表\n\n根据地址，就已经可以知道页号和页内偏移量，还有一个工作是根据页号找到对应页面在内存中的物理地址。\n\n每一个进程都有一张页表来记录页面号（页号）与页框号（块号）的映射关系，可以根据页号找到内存中对应页框的编号。其中页号是隐含的，相当于从 0 开始的下标，不占存储空间，页表实际只保存了块号。\n\n\n\n根据地址知道页号后，从页表中找出页号对应的块号，再用 块号 * 页框大小 ，即可算出块的起始地址。用 起始地址 + 偏移量 ，即可算出物理地址。\n\n\n# 地址变换机构\n\n# 基本地址变换机构\n\n上述的地址转换是通过基本地址变换机构这个硬件实现的，它借助页表将逻辑地址转换为物理地址。转换过程如下：\n\n\n\n在程序未执行的时候，PCB 中存放程序对应页表的初始地址 F 以及页表长度 M（页表项个数）。程序一旦开始执行，F 和 M 会被送到页表寄存器中。在需要访问地址的时候，基本地址变换机构开始运行：\n\n * 首先将逻辑地址 A 拆分为页号和页内偏移量两个部分，然后将页号与页表寄存器中的页表长度作比较。页表长度即页表项个数，即页面个数，因此页号是不能大于等于（不能等于，因为页号从 0 开始计算）页表长度的，如果页号越界就会发生越界中断。\n * 由于页表中每个页表项的大小是一样的（假设为 size），且已经知道了页表在内存中连续分配的起始地址（假设为 X），所以页号 P 对应的页表项的存放地址等于 X + P*size ，在这个地址保存着页号对应的块号\n * 将块号与偏移量的二进制数拼接，就得到了物理地址，得以访问目标\n\n例子中涉及到的都是二进制数，要计算物理地址，只需要将块号二进制数与偏移量二进制数拼接即可。如果例子给出的是十进制数，则应用 块起始地址 + 页内偏移量 进行相加，计算结果再转化为二进制数。\n\n# 例题 1\n\n若给定的是十进制：\n\n> 页面大小 1KB，块号 2，偏移量 1023。\n\n块起始地址等于 2 * 1KB = 2 * 1024B = 2048B ，又偏移量 1023，所以物理地址等于 2048 + 1023 = 3071 ，转化为 32 位二进制数，就是 0000000000000000000010,1111111111\n\n若给定的是二进制：\n\n> 页面大小 1KB，块号 2，偏移量 1111111111。\n\n块号 2 转化为 22 位二进制数就是 0000000000000000000010 ，与偏移量拼接，就得到 0000000000000000000010,1111111111 ，与十进制的结果是一样的。\n\n# 具有快表的地址变换机构\n\n在前面的基本地址变换机构中，存在两个问题：\n\n * 每次存取数据都需要访问内存两次：第一次访问内存中的页表，找到块号，并将块号与偏移量拼接得到物理地址；第二次根据物理地址访问内存中存放的数据。第二次访存肯定是不能避免的，但是第一次访存可以想办法避免\n * 若多条指令涉及到的逻辑地址的页号都相同，就都必须经历第一次访存，找到该页号对应的块号\n\n这两个问题可以通过引入快表来解决。\n\n快表（联想寄存器）是一种访问速度比内存快很多的高速缓冲存储器，用以存放访问过的页表项的副本，从而加快地址转换的过程。引入快表后，地址转换大概率不需要经历第一次访存，而是直接从快表中拿到需要的页表项。于是内存中原本的页表被称为慢表。\n\n此时的地址变换机构的运行过程和之前还是差不多的，只是多了一个快表的处理过程：\n\n\n\n在程序未执行的时候，PCB 中存放程序对应页表的初始地址 F 以及页表长度 M（页表项个数）。程序一旦开始执行，F 和 M 会被送到页表寄存器中。在需要访问地址的时候，地址变换机构开始运行：\n\n * 首先将地址拆分为页号和页内偏移量两个部分，然后将页号与页表寄存器中的页表长度作比较。若越界，则发生越界中断。\n * 该页号被送往快表，并与其中的页表项比较，寻找是否有匹配的页号。因为这里我们是第一次查询，所以是没有的，即未命中，页号被送往慢表。\n * 第一次访存，在慢表中找到页号对应的页表项的地址，意味着找到了页号对应的块号\n * 将该页表项拷贝一份副本放到快表中\n * 将块号与偏移量的二进制数拼接，就得到了物理地址，得以访问目标\n\n我们需要继续访问某个地址，并且与上次访问的地址的页号一样：\n\n * 首先将地址拆分为页号和页内偏移量两个部分，然后将页号与页表寄存器中的页表长度作比较。若越界，则发生越界中断。\n * 该页号被送往快表，并与其中的页表项比较，寻找是否有匹配的页号。因为快表中已经存放了一份页表项的副本，所以找到了匹配的页号，即命中。\n * 从快表中读出该页号对应的块号，并与偏移量拼接，就得到了物理地址，得以访问目标\n\n# 例题 2\n\n> 某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。假设访问一次快表耗时 1us，访问一次内存耗时 100us，快表的命中率为 90%。\n\n * 若未引入快表，则访问一个逻辑地址耗时 100 + 100 = 200us\n\n * 若引入快表，则访问一个逻辑地址耗时 (1+100) * 0.9 + (1+100+100) * 0.1 = 111 us\n\n * 若引入快表，且该系统支持同时查询快表和慢表，则访问一个逻辑地址耗时 (1+100) * 0.9 + (100+100) * 0.1 = 110.9us\n\n\n\n\n# 页表项的大小\n\n> 假设某系统物理内存大小为 4GB，页面大小为 4KB，则每个页表项至少应该为多少字节？\n\n一条页表项的大小取决于块号的位数。的 4GB=232B， 4KB=212B，因此 4GB 的内存总共会被分为 232/212 = 220 个内存块，因此内存块号的范围应该是 0～220-1。因此对于单个页表项，它要用一个 20 位二进制数才能表示这样的一个内存块号，而一个字节 8 位，所以至少要 3B 才可以表示这样的一个内存块号。\n\n但是一个页表项用 3 个字节其实会出现一些问题。类似于进程被拆分为多个页面存储在内存中一样，页表也是被拆分为多个页表项存储在内存中的。假设页面 / 页框大小为 4KB，也即 4096B，由于一个页表项 3B，所以一个页框至多可以放 4096/3=1365 个页表项，并且这个页框剩余 1B 的空间。由于 1B 不足以再存放一个页表项，所以第 1366 个页表项（1365 号页表项）只能放在下一个页框中了。\n\n这就会导致，前面 1365 个页表项的地址依然可以采用 X + 3*P 的方式计算，但是第 1366 个页表项，它的地址却应该是 X + 3*P + 1 ，也就是说，我们无法以一个通用的式子去计算页表项的存放地址。\n\n因此，一个页表项的大小通常应选取 2 的整数幂。如果页表项大小为 4B，那么一个页框就刚好可以放 4096/4=1024 个页表项，余下的页表项可以依次放在下一个页框中。这样，涉及到页表项地址的计算都可以用通用的式子 X + 4*P ，就无需考虑由于页框无法得到完全利用而带来的查询麻烦的问题了。当然，为了这个式子能够通用，页表通常也应该连续地存放在内存块中，中间不出现断节。\n\n> Q: 首先，在 页表项的大小 中，按照您的讲述，第 1366 个页表项的地址应为 X + 3*(P+1) 。另外，我对 “一个页表项的大小应同样选取 2 的整数幂” 的说法抱有疑问，因为 “一个页框能否在没有剩余空间的情况下装入足够多的页表项” 并不会影响到 “利用页号在页表中找到对应的块号”。即使页表项大小为 3B 时，第 1366 个页表项会被装入下一个页框，但是当页表项大小为 4B 时，第 4097 个页表项也同样会被装入下一个页框，不是吗？请问您是怎么理解的呢？\n> \n> A: 页表项的地址≠块号，页表项的存放地址的数据内容才是块号。同样的，块号≠内存块的物理地址，块号是内存块在内存中组织顺序的索引， 块号 * 页框大小 才等于内存块的起始物理地址。\n> \n> 问题不在于 “如何从已经找到地址的页表项中读取块号”，而在于 “如何根据隐含的页号找到页表项的存放地址”。页号是隐含的，页表中并没有储存页号，我们无法根据页号直接读取到页表项存储的块号，必须先根据 X + P*size 这个式子来确定页表项的存放地址。页表项大小为 3B 时，第 1365 个页表项和第 1366 个页表项之间间隔了未分配的 1B，先前 X + 3*P 的寻址规律就被打破了。 X + 3*P + 1 中的 +1 是前一个页框剩余的 1B，而不是 “下一个页框” 的意思。\n\n\n# 两级页表\n\n# 单级页表占用过大的连续内存空间的问题\n\n假设页面 / 页框大小 4KB，页表项大小 4B，一个页表占用的空间：\n\n * 计算页表一共有多少个页表项：4KB = 212B，所以 32 位逻辑地址中，后 12 位表示偏移量，前 20 位表示页号。总共有 220 个页面，也就是有 220 个页表项需要存放。\n * 计算一个页框可以放多少个页表项：一个页框 4KB，一个页表项 4B，所以一个页框可以放 4096/4 = 1024 个页表项\n * 计算存放所有页表项需要多少个页框：220/1024 = 1024\n\n需要 1024 个页框才能放下整个页表，而且为了以通用的式子计算页表项地址，页表必须是连续存放的，这违背了分页存储的初衷。\n\n# 引入两级页表\n\n就像进程拆分为多个页面一样，页表也可以进行拆分：将长的单级页表分为多个子页表，再将每每个子页表离散地存放到各个内存块中。在之前的例子中，一个页框可以放 1024 个页表项，那么每 1024 个页表项就拆分出一个子页表，因为页表一共有 220 个页表项，所以一共可以拆分出 1024 个子页表，这些子页表再各自存放到内存块中。\n\n于是，我们需要一张页目录表（一级页表 / 顶层页表 / 外层页表）来记录页目录表和子页表（二级页表）之间的映射关系，如下图：\n\n\n\n同时，之前的逻辑地址的含义也发生了改变。在单级页表中，前 20 位表示页号；而在两级页表中，前 10 位表示一级页号（一级页表的页号），紧跟着的 10 位表示二级页号（二级页表的页号）。这么划分之后，一级页号共有 210=1024 种可能的取值，即页目录表的 1024 个页表项；二级页号也有 210=1024 种可能的取值，即子页表的 1024 个页表项。\n\n在需要进行地址转换时：\n\n * 首先将逻辑地址分为三个部分：一级页号、二级页号、页内偏移量\n * 然后从 PCB 中读出页目录表的初始地址，结合一级页号以及每个页表项的大小，找到一级页号对应页表项的地址，即读取到了一级页号对应的块号\n * 根据块号到内存中找到对应的二级页表\n * 在二级页表中，根据二级页号找到对应的块号\n * 块号 * 页框大小 + 偏移量 得到物理地址\n\n上面的过程也可以直接看这幅图理解：\n\n\n\n# 单级页表常驻内存的问题\n\n执行程序时，往往只需要访问特定的几个页面，但整个单级页表是常驻在内存中的。[虚拟存储技术](# 第五章 虚拟存储器) 可以在需要访问页面的时候才把对应的页表项调入内存。\n\n# 多级页表\n\n> 某系统按字节编址，采用 40 位逻辑地址，页面大小为 4KB，页表项大小为 4B，假设采用纯页式存储，则要采用多少级页表？页内偏移量为多少位？\n\n4KB = 4*1024B = 212B，根据之前讲过的，页面偏移量应该是 12 位。40 - 12 = 28，所以前面 28 位用来表示页号。\n\n因为采用多级页表后，各级页表的大小不能超过一个页面，而一个页面最多只能放 1024 个页表项，所以应该限制页表最多只能包含 1024 个页表项（否则就放不下多余的页表项，导致页表超过一个页面），即逻辑地址中的 10 位二进制数。\n\n在逻辑地址的前 28 位中，可以选择 10 位用于表示某一级的页号（这一级的页表假设页表项可能有 1024 个这么多），再用 10 位表示某一级的页号（这一级的页表假设页表项可能有 1024 个这么多），再用剩下的 8 位表示某一级的页号（这一级的页表假设页表项远远少于 1024 个）。\n\n也可以考虑前面 8 位作为一级页号，紧接着的 10 位作为二级页号，再紧接着的 10 位作为三级页号，这样刚好就用完了逻辑地址前 28 位。所以题目需要采用三级页表。\n\n那如果这里不采用三级页表，强行使用二级页表，则必定有某一级的页号位数超过了 10，说明页表的页表项个数超过了 210=1024 个，很显然就会导致一个页框放不下这一级的页表，需要跨页，这与规定 “采用多级页表后，各级页表的大小不能超过一个页面” 是相悖的。\n\n\n# 习题\n\n>  1. 若系统采用两级分页存储方式，物理内存 64MB，页面大小 1KB，页表项大小 2B，则顶级页表有多少个页表项？\n\n这里我们可以参考之前求页表项大小的思路。物理内存 64MB = 226B，表示这么多内存需要 26 位逻辑地址。这 26 位中，一部分表示一级页号，一部分表示二级页号，剩下的表示页内偏移量。\n\n因为页面大小 1KB = 210B，所以页内偏移量需要 10 位来表示，余下 16 位供一、二级页号使用。一个页面大小 210B，一个页表项 2B，所以一个页框可以最多可以放 210/2 = 29 个页表项，又由于各级页表不能超过一个页面，所以各级页表都不能超过 29 个页表项。在余下的 16 位中，用 9 位表示二级页表的页号（此时该页表的页表项个数取满）。剩下的 7 位表示一级页表的页号，可以包含 27 = 128 个页表项。\n\n>  2. 若系统采用分页存储方式，物理内存 256MB，页面大小 1KB，页表如下：\n> \n> 页号 0，1，2，3，4，5，6，7，8，9，10 分别对应块号 15，16，20，28，29，30，31，32，36，38，39\n> \n> 则逻辑地址 1A68（16 进制）对应的物理地址是多少？\n\n为了方便计算，我们先统一用十进制计算，得到十进制的物理地址后再转换为十六进制。\n\n1A68 按权展开转化为对应的十进制数字是 6760，对于逻辑地址 6760，可以计算它的页号和页内偏移量：\n\n * 页号 = 6760/1024 = 6（取整数部分）\n * 页内偏移量 = 6760%1024 = 616\n\n根据页号 6 找到块号 31，根据块号 31 计算块初始地址为 31*1024 = 31744，偏移量和初始地址相加得到的物理地址为 31744+616 = 32360。32360 是十进制的物理地址，短除法转化为对应的十六进制物理地址就是 7E68。\n\n> 若统一使用二进制计算：\n> \n> 256MB = 228B 逻辑地址共 28 位\n> \n> 1A68 转换为二进制：0001 1010 0110 1000\n> \n> 页内偏移量 10 位\n> \n> 28-10=18 页号位数\n> \n> 补齐位数 0000 0000 0000 0001 1010 0110 1000\n> \n> 即 000000000000000110,1001101000\n> \n> 页号为 6，起始地址 31*1024=31744\n> \n> 出题者想让你用十进制做，因为给的是十进制的页表\n\n>  3. 若系统采用分页存储方式，物理内存 1MB，共有 32 个页面，一个页面 2KB，则逻辑地址一共多少位？\n\n因为物理内存 1MB = 220B，所以逻辑地址 20 位。\n\n根据上面的经验，我们可能会这么做，但是这是错误的做法。上面的习题都没有告诉我们程序具体被划分为多少个页面，所以我们认为物理地址需要多少位，逻辑地址也需要多少位。但是这道题已经告诉了我们程序具体被划分为 32 个页面 —— 显然，仅仅 32 个页面是不需要 20 这么多位的逻辑地址的。\n\n逻辑地址包括两部分，页号和页内偏移量：\n\n * 考虑页内偏移量位数。由于一个页面 2KB，也即 211B，所以页内偏移量占 11 位（注意这点是不变的）\n * 考虑页号位数。由于页面仅仅被划分为 32 = 25 个，所以页号只需要 5 位\n\n11 + 5 = 16，所以逻辑地址一共 16 位。\n\n当题目明确给出分页个数的时候，按照页号位数 + 偏移量位数计算逻辑地址总位数。\n\n\n# 基本分段存储管理\n\n\n# 基本思路\n\n在基本分页存储管理中，我们将程序分为多个大小相等的物理单元（页面）。而在基本分段存储管理中，我们倾向于从逻辑功能的角度去考虑，将程序分为多个逻辑功能段，每个段都有自己的段名，并且都从 0 开始编址。分配内存时以段为单位进行分配，段内所占内存空间是连续的，但是各个段之间可以不相邻，如下图：\n\n\n\n编写程序时可以将程序按照逻辑功能模块进行划分，会更加方便，可读性会更高，比如：\n\nLOAD 1，[D]|<A>\nSTORE 1，[X]|<B>\n\n\n1\n2\n\n1\n2\n\n\n分别表示：将分段 D 中 A 单元内的值读入寄存器 1，以及将寄存器 1 的值存入分段 X 的 B 单元中。这里的分段 D 和 X 都是段名，程序员在编程的时候只需要使用段名，编译时段名会转化为对应的段号。同理，A、B 单元编译时也会转化为寄存器地址。\n\n\n# 逻辑地址\n\n分段存储管理中逻辑地址的含义与分页存储管理不同。假设仍然是用 32 位二进制数表示逻辑地址，地址的前 16 位表示段号，后 16 位表示段内偏移量：\n\n * 段号是 16 位二进制数，有 216 种取值，即每个进程最多可以被分为 216 个段\n * 段内偏移量也是 16 位二进制数，在一个段内，段内地址可能有 216 种取值，所以一个段的最大长度为 216\n\n\n# 段表\n\n类似的，我们需要用段表来记录某个编号段与实际物理存放位置之间的映射关系。在分段存储管理中，程序被分为大小不等的多个段，且不连续，没法像之前一样只凭借块号来推导块的初始地址。为了准确地找出段存放在内存中的位置，我们要将段号、段长、基址 这三者作为段表的三列。这样，根据段号可以在段表中找到对应段在内存中的基址（即起始地址，不是块号），再结合段长，可以知道这个段具体占用了哪里的空间。\n\n如下图所示：\n\n\n\n\n# 段表项的大小\n\n每个段表项由段号、段长、基址构成，我们可以依次考虑每一列可能占用的空间（假设物理内存 4GB，按字节寻址）：\n\n * 基址：因为物理内存 4GB，也就是 232B，那么内存中的地址最多可能取到 232 种值。为了让基址列足够表示这些值，基址列占用了 32 位。\n * 段长：前面讲过，在逻辑地址中，段号和段内偏移量都是 16 位，所以段内偏移量最多可能取到 216 种值，为了让段长列足够表示这些值，段长列占用了 16 位\n * 段号：和页表一样，在段表中同样隐含段号，因为段表也是连续的，我们只需要知道段表的起始地址和每个段表项的大小就能定位一个段表项的地址，而无需去维护一个从段号到段表项的映射。\n\n因此，每个段表项占用了 16+32=48 位，一个字节 8 位，占用了 6 个字节， 即 6B。\n\n\n# 地址转换\n\n转换过程我们可以直接看下图理解：\n\n\n\n可以联系分页存储的地址转换过程。在需要将逻辑地址转换为物理地址的时候：\n\n * 首先将逻辑地址分为段号和段内偏移量两个部分，段表寄存器中的段表长度保存了程序总共被分为了多少段，因此段号不应该超过段表长度，若超过则发生越界中断。\n * 根据段号、段表初始地址和段表项的大小，找到段号对应的段表项。比较段表项中的段长 C 和逻辑地址中的段内偏移量 W，若 W >= C 则发生越界中断（此处比分页存储多一次越界判断，因为页表的页框大小固定，且受页内偏移量位数限制不会越界，而段长可变）\n * 在段表项中找到段号对应的基址，将该基址与段内偏移量拼接，得到物理地址，得以访问目标\n\n\n# 分页和分段的对比\n\n# 划分的角度和维度\n\n\n\n# 信息的共享和保护\n\n在分段存储方式中，更容易实现信息共享和保护：\n\n\n\n可重入代码 (Reentry code) 也叫纯代码 (Pure code) 是一种允许多个进程同时访问的代码。为了使各进程所执行的代码完全相同，故不允许任何进程对其进行修改。程序在运行过程中可以被打断，并由开始处再次执行，并且在合理的范围内（多次重入，而不造成堆栈溢出等其他问题），程序可以在被打断处继续执行，且执行结果不受影响。\n\n在分页存储方式中，则很难：\n\n\n\n# 访存次数\n\n两者的访存次数是一样的：\n\n * 若不引入快表，两者的第一次访存都是访问内存中的页 / 段表，第二次是访问内存中的目标。\n * 若引入快表，则两者的第一次访存有可能因为命中而省去。\n\n\n# 段页式存储管理\n\n\n# 基本思路\n\n * 采用分页存储管理，内存利用率高，不会产生外部碎片，仅会产生少量内部碎片；但是不方便按照逻辑模块实现信息的共享和保护\n * 采用分段存储管理，可以按照逻辑模块实现信息的共享和保护，但是若逻辑过多则会导致段过长，另外，这种方式也会产生外部碎片\n\n所以结合二者之长，出现了段页式存储管理方式。\n\n如下图，段页存储管理会首先将进程按照逻辑模块划分为多个段，针对每个段再划分为多个页；同时也把内存划分为多个页框。分配内存的时候，一个页面就对应了一个页框。\n\n\n\n\n# 逻辑地址\n\n在分段存储管理中，给出一个逻辑地址，可以划分为段号和段内地址两个部分；而在段页存储管理中，段内地址还要继续细分成页号和页内偏移量两个部分。所以逻辑地址由段号、页号和页内偏移量三个部分组成。\n\n段号的位数仍然决定了一个进程可以被划分为多少个段，而页号的位数则决定了一个段可以被划分为多少个页面，页内偏移量则决定了一个页面可以有多大，即页面 / 页框大小。\n\n和分段存储管理一样，段页存储管理的地址结构也是二维的。\n\n\n# 段表\n\n段页存储管理中的段表不同于分段存储管理中的段表。程序被划分为多个段，每个段都会再被划分为多个页面，因此每一个段都维护着属于自己的一张页表。段表需要记录的是段号与段号对应段的页表之间的映射关系，包括段号、页表长度和存放页表的块号（块号 * 页框大小 = 页表所在块的起始地址）。段号是隐含的。\n\n\n\n\n# 地址转换\n\n\n\n段页式存储的地址转换机构结合了分页存储和分段存储的方式，在需要将逻辑地址转换为物理地址的时候：\n\n * 首先将逻辑地址分为段号、页号和页内偏移量三个部分，段表寄存器中的段表长度仍代表程序总共被分为多少个段，因此段号不应该超过段表长度，若超过则越界中断（同段式存储第一次越界检查）\n * 根据段号、段表初始地址以及段表项的大小，找到段号对应的段表项。可以从这个段表项读取到该段号对应的页表的位置和大小。这里同样要比较段表项中的页表长度和逻辑地址中的页号 P，若页号大于等于页表长度则越界中断（同页式存储唯一一次越界检查，不同于段式存储第二次越界检查）\n * 找到了段表项就是找到了该段的页表所在块的块号。根据块号，在内存中找到这个块，再从块中找到页表\n * 根据逻辑地址中的页号，在页表中找到页号对应的块号，将块号和逻辑地址中的页内偏移量拼接，得到物理地址，得以访问目标\n\n\n# 访存次数\n\n不采用快表时，段页式存储管理需要经历三次访存：第一次访存，访问内存中的段表，找到段表中记录的页表信息；第二次访存，访问内存中的页表，找到目标所在的块；第三次访存，访问内存中的目标。\n\n如果采用快表，会利用段号和页号去寄存器中检索，若命中，则无需经历第一次和第二次访存，可以直接拿到块号并和偏移量进行拼接，得到物理地址。同样只需要一次访存。",normalizedContent:"# 非连续内存分配\n\n固定分区分配容易产生内部碎片，动态分区分配容易产生外部碎片（虽然可以用紧凑技术解决，但是有一定的成本），都不是理想的解决方案。\n\n\n# 基本分页存储管理\n\n\n# 基本思路\n\n在连续分配中，一个进程不可被分割，只能整体放入一块连续的内存空间中；但在基本分页存储管理中，允许把一个进程按照固定大小 x 分割为多个部分，同时把内存也按照固定大小 x 分割为多个部分，并把前者对应地放到后者中（不要求连续存放）。通常来说，一个进程的最后一部分会小于 x ，这部分若放到内存的某个 x 空间中，仍然会产生碎片（这种碎片称为页内碎片）。\n\n\n# 页面、页框\n\n * 页框 (page frame)：具体来说，把内存分割为多个固定大小 x 的部分，这些部分就叫做页框 / 页帧 / 物理块 / 内存块，每个页框会有一个数字编号，第一个页框就从 0 开始\n\n * 页面 (page)：同样，进程被分割为多个固定大小 x 的部分，这些部分就叫做页面 / 页，每个页面会有一个数字编号，第一个页面就从 0 开始\n\n\n\n若页面太小，虽然可使页内碎片减小、提高内存利用率，但是会使页表过长、降低页面换进换出的效率；若页面太大，则相反。因此页面的大小应是 2 的整数幂，通常为 1kb~8kb。\n\n系统以页框为单位为各个进程分配内存空间，一个页面就对应一个页框，它具体放到哪个页框是随意的，无需顾虑是否连续和先后顺序。\n\n\n# 地址转换的思路\n\n假设我们采用动态重定位方式进行模块装入，程序中是逻辑地址，但在程序执行到需要访问地址的时候，需要进行逻辑地址到物理地址的转换。\n\n# 十进制地址\n\n左边进程按照 50b 的大小分为 4 个页面，右边内存按照 50b 的大小分为若干个页框：\n\n\n\n在程序执行到指令 1 的时候，需要访问地址 80，这是一个逻辑地址，需要转换成对应的物理地址。转换步骤如下：\n\n * 计算逻辑地址的页号\n * 根据页号找到页号对应页面在内存中的起始地址\n * 计算逻辑地址在当前页面内的偏移量（页内偏移量）\n * 物理地址 = 起始地址 + 页内偏移量\n\n从左图可以看出，逻辑地址 80 在 1 号页面内，而 1 号页面对应的是右图中的红色页框，起始地址为 450；逻辑地址 80 在 1 号页面内的偏移量为 30；所以 物理地址 = 450 + 30 = 480\n\n也可以用计算的方法，在已知逻辑地址的情况下：\n\n * 页号 = 逻辑地址 / 页面大小 ，即 80/50 = 1 （取整数部分）\n * 页内偏移量 = 逻辑地址 % 页面大小 ，即 80%50 = 30\n\n# 二进制地址\n\n地址实际上是用 32 位二进制数表示的。这时候计算页号 p 和页内偏移量 w 实际上更加简单，因为地址本身已经包含了这两者的信息。\n\n以页面 / 页框大小 4kb 为例，用地址的前 20 位（红色部分，也叫高 20 位）表示页号 p，用地址的后 12 位（黑色部分，也叫低 12 位）表示页内偏移量 w。页内偏移量的位数可以表明每个页面的大小，即 212 = 4kb。0 号页、1 号页、2 号页的表示如下：\n\n\n\n若页面 / 页框大小为 1kb，也即 210b = 1024b，那么地址的前 22 位表示页号，剩余的 10 位表示页内偏移量：\n\n\n\n# 例题\n\n\n\n\n\n\n# 页表\n\n根据地址，就已经可以知道页号和页内偏移量，还有一个工作是根据页号找到对应页面在内存中的物理地址。\n\n每一个进程都有一张页表来记录页面号（页号）与页框号（块号）的映射关系，可以根据页号找到内存中对应页框的编号。其中页号是隐含的，相当于从 0 开始的下标，不占存储空间，页表实际只保存了块号。\n\n\n\n根据地址知道页号后，从页表中找出页号对应的块号，再用 块号 * 页框大小 ，即可算出块的起始地址。用 起始地址 + 偏移量 ，即可算出物理地址。\n\n\n# 地址变换机构\n\n# 基本地址变换机构\n\n上述的地址转换是通过基本地址变换机构这个硬件实现的，它借助页表将逻辑地址转换为物理地址。转换过程如下：\n\n\n\n在程序未执行的时候，pcb 中存放程序对应页表的初始地址 f 以及页表长度 m（页表项个数）。程序一旦开始执行，f 和 m 会被送到页表寄存器中。在需要访问地址的时候，基本地址变换机构开始运行：\n\n * 首先将逻辑地址 a 拆分为页号和页内偏移量两个部分，然后将页号与页表寄存器中的页表长度作比较。页表长度即页表项个数，即页面个数，因此页号是不能大于等于（不能等于，因为页号从 0 开始计算）页表长度的，如果页号越界就会发生越界中断。\n * 由于页表中每个页表项的大小是一样的（假设为 size），且已经知道了页表在内存中连续分配的起始地址（假设为 x），所以页号 p 对应的页表项的存放地址等于 x + p*size ，在这个地址保存着页号对应的块号\n * 将块号与偏移量的二进制数拼接，就得到了物理地址，得以访问目标\n\n例子中涉及到的都是二进制数，要计算物理地址，只需要将块号二进制数与偏移量二进制数拼接即可。如果例子给出的是十进制数，则应用 块起始地址 + 页内偏移量 进行相加，计算结果再转化为二进制数。\n\n# 例题 1\n\n若给定的是十进制：\n\n> 页面大小 1kb，块号 2，偏移量 1023。\n\n块起始地址等于 2 * 1kb = 2 * 1024b = 2048b ，又偏移量 1023，所以物理地址等于 2048 + 1023 = 3071 ，转化为 32 位二进制数，就是 0000000000000000000010,1111111111\n\n若给定的是二进制：\n\n> 页面大小 1kb，块号 2，偏移量 1111111111。\n\n块号 2 转化为 22 位二进制数就是 0000000000000000000010 ，与偏移量拼接，就得到 0000000000000000000010,1111111111 ，与十进制的结果是一样的。\n\n# 具有快表的地址变换机构\n\n在前面的基本地址变换机构中，存在两个问题：\n\n * 每次存取数据都需要访问内存两次：第一次访问内存中的页表，找到块号，并将块号与偏移量拼接得到物理地址；第二次根据物理地址访问内存中存放的数据。第二次访存肯定是不能避免的，但是第一次访存可以想办法避免\n * 若多条指令涉及到的逻辑地址的页号都相同，就都必须经历第一次访存，找到该页号对应的块号\n\n这两个问题可以通过引入快表来解决。\n\n快表（联想寄存器）是一种访问速度比内存快很多的高速缓冲存储器，用以存放访问过的页表项的副本，从而加快地址转换的过程。引入快表后，地址转换大概率不需要经历第一次访存，而是直接从快表中拿到需要的页表项。于是内存中原本的页表被称为慢表。\n\n此时的地址变换机构的运行过程和之前还是差不多的，只是多了一个快表的处理过程：\n\n\n\n在程序未执行的时候，pcb 中存放程序对应页表的初始地址 f 以及页表长度 m（页表项个数）。程序一旦开始执行，f 和 m 会被送到页表寄存器中。在需要访问地址的时候，地址变换机构开始运行：\n\n * 首先将地址拆分为页号和页内偏移量两个部分，然后将页号与页表寄存器中的页表长度作比较。若越界，则发生越界中断。\n * 该页号被送往快表，并与其中的页表项比较，寻找是否有匹配的页号。因为这里我们是第一次查询，所以是没有的，即未命中，页号被送往慢表。\n * 第一次访存，在慢表中找到页号对应的页表项的地址，意味着找到了页号对应的块号\n * 将该页表项拷贝一份副本放到快表中\n * 将块号与偏移量的二进制数拼接，就得到了物理地址，得以访问目标\n\n我们需要继续访问某个地址，并且与上次访问的地址的页号一样：\n\n * 首先将地址拆分为页号和页内偏移量两个部分，然后将页号与页表寄存器中的页表长度作比较。若越界，则发生越界中断。\n * 该页号被送往快表，并与其中的页表项比较，寻找是否有匹配的页号。因为快表中已经存放了一份页表项的副本，所以找到了匹配的页号，即命中。\n * 从快表中读出该页号对应的块号，并与偏移量拼接，就得到了物理地址，得以访问目标\n\n# 例题 2\n\n> 某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。假设访问一次快表耗时 1us，访问一次内存耗时 100us，快表的命中率为 90%。\n\n * 若未引入快表，则访问一个逻辑地址耗时 100 + 100 = 200us\n\n * 若引入快表，则访问一个逻辑地址耗时 (1+100) * 0.9 + (1+100+100) * 0.1 = 111 us\n\n * 若引入快表，且该系统支持同时查询快表和慢表，则访问一个逻辑地址耗时 (1+100) * 0.9 + (100+100) * 0.1 = 110.9us\n\n\n\n\n# 页表项的大小\n\n> 假设某系统物理内存大小为 4gb，页面大小为 4kb，则每个页表项至少应该为多少字节？\n\n一条页表项的大小取决于块号的位数。的 4gb=232b， 4kb=212b，因此 4gb 的内存总共会被分为 232/212 = 220 个内存块，因此内存块号的范围应该是 0～220-1。因此对于单个页表项，它要用一个 20 位二进制数才能表示这样的一个内存块号，而一个字节 8 位，所以至少要 3b 才可以表示这样的一个内存块号。\n\n但是一个页表项用 3 个字节其实会出现一些问题。类似于进程被拆分为多个页面存储在内存中一样，页表也是被拆分为多个页表项存储在内存中的。假设页面 / 页框大小为 4kb，也即 4096b，由于一个页表项 3b，所以一个页框至多可以放 4096/3=1365 个页表项，并且这个页框剩余 1b 的空间。由于 1b 不足以再存放一个页表项，所以第 1366 个页表项（1365 号页表项）只能放在下一个页框中了。\n\n这就会导致，前面 1365 个页表项的地址依然可以采用 x + 3*p 的方式计算，但是第 1366 个页表项，它的地址却应该是 x + 3*p + 1 ，也就是说，我们无法以一个通用的式子去计算页表项的存放地址。\n\n因此，一个页表项的大小通常应选取 2 的整数幂。如果页表项大小为 4b，那么一个页框就刚好可以放 4096/4=1024 个页表项，余下的页表项可以依次放在下一个页框中。这样，涉及到页表项地址的计算都可以用通用的式子 x + 4*p ，就无需考虑由于页框无法得到完全利用而带来的查询麻烦的问题了。当然，为了这个式子能够通用，页表通常也应该连续地存放在内存块中，中间不出现断节。\n\n> q: 首先，在 页表项的大小 中，按照您的讲述，第 1366 个页表项的地址应为 x + 3*(p+1) 。另外，我对 “一个页表项的大小应同样选取 2 的整数幂” 的说法抱有疑问，因为 “一个页框能否在没有剩余空间的情况下装入足够多的页表项” 并不会影响到 “利用页号在页表中找到对应的块号”。即使页表项大小为 3b 时，第 1366 个页表项会被装入下一个页框，但是当页表项大小为 4b 时，第 4097 个页表项也同样会被装入下一个页框，不是吗？请问您是怎么理解的呢？\n> \n> a: 页表项的地址=块号，页表项的存放地址的数据内容才是块号。同样的，块号=内存块的物理地址，块号是内存块在内存中组织顺序的索引， 块号 * 页框大小 才等于内存块的起始物理地址。\n> \n> 问题不在于 “如何从已经找到地址的页表项中读取块号”，而在于 “如何根据隐含的页号找到页表项的存放地址”。页号是隐含的，页表中并没有储存页号，我们无法根据页号直接读取到页表项存储的块号，必须先根据 x + p*size 这个式子来确定页表项的存放地址。页表项大小为 3b 时，第 1365 个页表项和第 1366 个页表项之间间隔了未分配的 1b，先前 x + 3*p 的寻址规律就被打破了。 x + 3*p + 1 中的 +1 是前一个页框剩余的 1b，而不是 “下一个页框” 的意思。\n\n\n# 两级页表\n\n# 单级页表占用过大的连续内存空间的问题\n\n假设页面 / 页框大小 4kb，页表项大小 4b，一个页表占用的空间：\n\n * 计算页表一共有多少个页表项：4kb = 212b，所以 32 位逻辑地址中，后 12 位表示偏移量，前 20 位表示页号。总共有 220 个页面，也就是有 220 个页表项需要存放。\n * 计算一个页框可以放多少个页表项：一个页框 4kb，一个页表项 4b，所以一个页框可以放 4096/4 = 1024 个页表项\n * 计算存放所有页表项需要多少个页框：220/1024 = 1024\n\n需要 1024 个页框才能放下整个页表，而且为了以通用的式子计算页表项地址，页表必须是连续存放的，这违背了分页存储的初衷。\n\n# 引入两级页表\n\n就像进程拆分为多个页面一样，页表也可以进行拆分：将长的单级页表分为多个子页表，再将每每个子页表离散地存放到各个内存块中。在之前的例子中，一个页框可以放 1024 个页表项，那么每 1024 个页表项就拆分出一个子页表，因为页表一共有 220 个页表项，所以一共可以拆分出 1024 个子页表，这些子页表再各自存放到内存块中。\n\n于是，我们需要一张页目录表（一级页表 / 顶层页表 / 外层页表）来记录页目录表和子页表（二级页表）之间的映射关系，如下图：\n\n\n\n同时，之前的逻辑地址的含义也发生了改变。在单级页表中，前 20 位表示页号；而在两级页表中，前 10 位表示一级页号（一级页表的页号），紧跟着的 10 位表示二级页号（二级页表的页号）。这么划分之后，一级页号共有 210=1024 种可能的取值，即页目录表的 1024 个页表项；二级页号也有 210=1024 种可能的取值，即子页表的 1024 个页表项。\n\n在需要进行地址转换时：\n\n * 首先将逻辑地址分为三个部分：一级页号、二级页号、页内偏移量\n * 然后从 pcb 中读出页目录表的初始地址，结合一级页号以及每个页表项的大小，找到一级页号对应页表项的地址，即读取到了一级页号对应的块号\n * 根据块号到内存中找到对应的二级页表\n * 在二级页表中，根据二级页号找到对应的块号\n * 块号 * 页框大小 + 偏移量 得到物理地址\n\n上面的过程也可以直接看这幅图理解：\n\n\n\n# 单级页表常驻内存的问题\n\n执行程序时，往往只需要访问特定的几个页面，但整个单级页表是常驻在内存中的。[虚拟存储技术](# 第五章 虚拟存储器) 可以在需要访问页面的时候才把对应的页表项调入内存。\n\n# 多级页表\n\n> 某系统按字节编址，采用 40 位逻辑地址，页面大小为 4kb，页表项大小为 4b，假设采用纯页式存储，则要采用多少级页表？页内偏移量为多少位？\n\n4kb = 4*1024b = 212b，根据之前讲过的，页面偏移量应该是 12 位。40 - 12 = 28，所以前面 28 位用来表示页号。\n\n因为采用多级页表后，各级页表的大小不能超过一个页面，而一个页面最多只能放 1024 个页表项，所以应该限制页表最多只能包含 1024 个页表项（否则就放不下多余的页表项，导致页表超过一个页面），即逻辑地址中的 10 位二进制数。\n\n在逻辑地址的前 28 位中，可以选择 10 位用于表示某一级的页号（这一级的页表假设页表项可能有 1024 个这么多），再用 10 位表示某一级的页号（这一级的页表假设页表项可能有 1024 个这么多），再用剩下的 8 位表示某一级的页号（这一级的页表假设页表项远远少于 1024 个）。\n\n也可以考虑前面 8 位作为一级页号，紧接着的 10 位作为二级页号，再紧接着的 10 位作为三级页号，这样刚好就用完了逻辑地址前 28 位。所以题目需要采用三级页表。\n\n那如果这里不采用三级页表，强行使用二级页表，则必定有某一级的页号位数超过了 10，说明页表的页表项个数超过了 210=1024 个，很显然就会导致一个页框放不下这一级的页表，需要跨页，这与规定 “采用多级页表后，各级页表的大小不能超过一个页面” 是相悖的。\n\n\n# 习题\n\n>  1. 若系统采用两级分页存储方式，物理内存 64mb，页面大小 1kb，页表项大小 2b，则顶级页表有多少个页表项？\n\n这里我们可以参考之前求页表项大小的思路。物理内存 64mb = 226b，表示这么多内存需要 26 位逻辑地址。这 26 位中，一部分表示一级页号，一部分表示二级页号，剩下的表示页内偏移量。\n\n因为页面大小 1kb = 210b，所以页内偏移量需要 10 位来表示，余下 16 位供一、二级页号使用。一个页面大小 210b，一个页表项 2b，所以一个页框可以最多可以放 210/2 = 29 个页表项，又由于各级页表不能超过一个页面，所以各级页表都不能超过 29 个页表项。在余下的 16 位中，用 9 位表示二级页表的页号（此时该页表的页表项个数取满）。剩下的 7 位表示一级页表的页号，可以包含 27 = 128 个页表项。\n\n>  2. 若系统采用分页存储方式，物理内存 256mb，页面大小 1kb，页表如下：\n> \n> 页号 0，1，2，3，4，5，6，7，8，9，10 分别对应块号 15，16，20，28，29，30，31，32，36，38，39\n> \n> 则逻辑地址 1a68（16 进制）对应的物理地址是多少？\n\n为了方便计算，我们先统一用十进制计算，得到十进制的物理地址后再转换为十六进制。\n\n1a68 按权展开转化为对应的十进制数字是 6760，对于逻辑地址 6760，可以计算它的页号和页内偏移量：\n\n * 页号 = 6760/1024 = 6（取整数部分）\n * 页内偏移量 = 6760%1024 = 616\n\n根据页号 6 找到块号 31，根据块号 31 计算块初始地址为 31*1024 = 31744，偏移量和初始地址相加得到的物理地址为 31744+616 = 32360。32360 是十进制的物理地址，短除法转化为对应的十六进制物理地址就是 7e68。\n\n> 若统一使用二进制计算：\n> \n> 256mb = 228b 逻辑地址共 28 位\n> \n> 1a68 转换为二进制：0001 1010 0110 1000\n> \n> 页内偏移量 10 位\n> \n> 28-10=18 页号位数\n> \n> 补齐位数 0000 0000 0000 0001 1010 0110 1000\n> \n> 即 000000000000000110,1001101000\n> \n> 页号为 6，起始地址 31*1024=31744\n> \n> 出题者想让你用十进制做，因为给的是十进制的页表\n\n>  3. 若系统采用分页存储方式，物理内存 1mb，共有 32 个页面，一个页面 2kb，则逻辑地址一共多少位？\n\n因为物理内存 1mb = 220b，所以逻辑地址 20 位。\n\n根据上面的经验，我们可能会这么做，但是这是错误的做法。上面的习题都没有告诉我们程序具体被划分为多少个页面，所以我们认为物理地址需要多少位，逻辑地址也需要多少位。但是这道题已经告诉了我们程序具体被划分为 32 个页面 —— 显然，仅仅 32 个页面是不需要 20 这么多位的逻辑地址的。\n\n逻辑地址包括两部分，页号和页内偏移量：\n\n * 考虑页内偏移量位数。由于一个页面 2kb，也即 211b，所以页内偏移量占 11 位（注意这点是不变的）\n * 考虑页号位数。由于页面仅仅被划分为 32 = 25 个，所以页号只需要 5 位\n\n11 + 5 = 16，所以逻辑地址一共 16 位。\n\n当题目明确给出分页个数的时候，按照页号位数 + 偏移量位数计算逻辑地址总位数。\n\n\n# 基本分段存储管理\n\n\n# 基本思路\n\n在基本分页存储管理中，我们将程序分为多个大小相等的物理单元（页面）。而在基本分段存储管理中，我们倾向于从逻辑功能的角度去考虑，将程序分为多个逻辑功能段，每个段都有自己的段名，并且都从 0 开始编址。分配内存时以段为单位进行分配，段内所占内存空间是连续的，但是各个段之间可以不相邻，如下图：\n\n\n\n编写程序时可以将程序按照逻辑功能模块进行划分，会更加方便，可读性会更高，比如：\n\nload 1，[d]|<a>\nstore 1，[x]|<b>\n\n\n1\n2\n\n1\n2\n\n\n分别表示：将分段 d 中 a 单元内的值读入寄存器 1，以及将寄存器 1 的值存入分段 x 的 b 单元中。这里的分段 d 和 x 都是段名，程序员在编程的时候只需要使用段名，编译时段名会转化为对应的段号。同理，a、b 单元编译时也会转化为寄存器地址。\n\n\n# 逻辑地址\n\n分段存储管理中逻辑地址的含义与分页存储管理不同。假设仍然是用 32 位二进制数表示逻辑地址，地址的前 16 位表示段号，后 16 位表示段内偏移量：\n\n * 段号是 16 位二进制数，有 216 种取值，即每个进程最多可以被分为 216 个段\n * 段内偏移量也是 16 位二进制数，在一个段内，段内地址可能有 216 种取值，所以一个段的最大长度为 216\n\n\n# 段表\n\n类似的，我们需要用段表来记录某个编号段与实际物理存放位置之间的映射关系。在分段存储管理中，程序被分为大小不等的多个段，且不连续，没法像之前一样只凭借块号来推导块的初始地址。为了准确地找出段存放在内存中的位置，我们要将段号、段长、基址 这三者作为段表的三列。这样，根据段号可以在段表中找到对应段在内存中的基址（即起始地址，不是块号），再结合段长，可以知道这个段具体占用了哪里的空间。\n\n如下图所示：\n\n\n\n\n# 段表项的大小\n\n每个段表项由段号、段长、基址构成，我们可以依次考虑每一列可能占用的空间（假设物理内存 4gb，按字节寻址）：\n\n * 基址：因为物理内存 4gb，也就是 232b，那么内存中的地址最多可能取到 232 种值。为了让基址列足够表示这些值，基址列占用了 32 位。\n * 段长：前面讲过，在逻辑地址中，段号和段内偏移量都是 16 位，所以段内偏移量最多可能取到 216 种值，为了让段长列足够表示这些值，段长列占用了 16 位\n * 段号：和页表一样，在段表中同样隐含段号，因为段表也是连续的，我们只需要知道段表的起始地址和每个段表项的大小就能定位一个段表项的地址，而无需去维护一个从段号到段表项的映射。\n\n因此，每个段表项占用了 16+32=48 位，一个字节 8 位，占用了 6 个字节， 即 6b。\n\n\n# 地址转换\n\n转换过程我们可以直接看下图理解：\n\n\n\n可以联系分页存储的地址转换过程。在需要将逻辑地址转换为物理地址的时候：\n\n * 首先将逻辑地址分为段号和段内偏移量两个部分，段表寄存器中的段表长度保存了程序总共被分为了多少段，因此段号不应该超过段表长度，若超过则发生越界中断。\n * 根据段号、段表初始地址和段表项的大小，找到段号对应的段表项。比较段表项中的段长 c 和逻辑地址中的段内偏移量 w，若 w >= c 则发生越界中断（此处比分页存储多一次越界判断，因为页表的页框大小固定，且受页内偏移量位数限制不会越界，而段长可变）\n * 在段表项中找到段号对应的基址，将该基址与段内偏移量拼接，得到物理地址，得以访问目标\n\n\n# 分页和分段的对比\n\n# 划分的角度和维度\n\n\n\n# 信息的共享和保护\n\n在分段存储方式中，更容易实现信息共享和保护：\n\n\n\n可重入代码 (reentry code) 也叫纯代码 (pure code) 是一种允许多个进程同时访问的代码。为了使各进程所执行的代码完全相同，故不允许任何进程对其进行修改。程序在运行过程中可以被打断，并由开始处再次执行，并且在合理的范围内（多次重入，而不造成堆栈溢出等其他问题），程序可以在被打断处继续执行，且执行结果不受影响。\n\n在分页存储方式中，则很难：\n\n\n\n# 访存次数\n\n两者的访存次数是一样的：\n\n * 若不引入快表，两者的第一次访存都是访问内存中的页 / 段表，第二次是访问内存中的目标。\n * 若引入快表，则两者的第一次访存有可能因为命中而省去。\n\n\n# 段页式存储管理\n\n\n# 基本思路\n\n * 采用分页存储管理，内存利用率高，不会产生外部碎片，仅会产生少量内部碎片；但是不方便按照逻辑模块实现信息的共享和保护\n * 采用分段存储管理，可以按照逻辑模块实现信息的共享和保护，但是若逻辑过多则会导致段过长，另外，这种方式也会产生外部碎片\n\n所以结合二者之长，出现了段页式存储管理方式。\n\n如下图，段页存储管理会首先将进程按照逻辑模块划分为多个段，针对每个段再划分为多个页；同时也把内存划分为多个页框。分配内存的时候，一个页面就对应了一个页框。\n\n\n\n\n# 逻辑地址\n\n在分段存储管理中，给出一个逻辑地址，可以划分为段号和段内地址两个部分；而在段页存储管理中，段内地址还要继续细分成页号和页内偏移量两个部分。所以逻辑地址由段号、页号和页内偏移量三个部分组成。\n\n段号的位数仍然决定了一个进程可以被划分为多少个段，而页号的位数则决定了一个段可以被划分为多少个页面，页内偏移量则决定了一个页面可以有多大，即页面 / 页框大小。\n\n和分段存储管理一样，段页存储管理的地址结构也是二维的。\n\n\n# 段表\n\n段页存储管理中的段表不同于分段存储管理中的段表。程序被划分为多个段，每个段都会再被划分为多个页面，因此每一个段都维护着属于自己的一张页表。段表需要记录的是段号与段号对应段的页表之间的映射关系，包括段号、页表长度和存放页表的块号（块号 * 页框大小 = 页表所在块的起始地址）。段号是隐含的。\n\n\n\n\n# 地址转换\n\n\n\n段页式存储的地址转换机构结合了分页存储和分段存储的方式，在需要将逻辑地址转换为物理地址的时候：\n\n * 首先将逻辑地址分为段号、页号和页内偏移量三个部分，段表寄存器中的段表长度仍代表程序总共被分为多少个段，因此段号不应该超过段表长度，若超过则越界中断（同段式存储第一次越界检查）\n * 根据段号、段表初始地址以及段表项的大小，找到段号对应的段表项。可以从这个段表项读取到该段号对应的页表的位置和大小。这里同样要比较段表项中的页表长度和逻辑地址中的页号 p，若页号大于等于页表长度则越界中断（同页式存储唯一一次越界检查，不同于段式存储第二次越界检查）\n * 找到了段表项就是找到了该段的页表所在块的块号。根据块号，在内存中找到这个块，再从块中找到页表\n * 根据逻辑地址中的页号，在页表中找到页号对应的块号，将块号和逻辑地址中的页内偏移量拼接，得到物理地址，得以访问目标\n\n\n# 访存次数\n\n不采用快表时，段页式存储管理需要经历三次访存：第一次访存，访问内存中的段表，找到段表中记录的页表信息；第二次访存，访问内存中的页表，找到目标所在的块；第三次访存，访问内存中的目标。\n\n如果采用快表，会利用段号和页号去寄存器中检索，若命中，则无需经历第一次和第二次访存，可以直接拿到块号并和偏移量进行拼接，得到物理地址。同样只需要一次访存。",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"请求分页存储管理方式",frontmatter:{title:"请求分页存储管理方式",date:"2023-02-08T09:29:27.000Z",permalink:"/pages/9b0e23/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/06.%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/02.%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F.html",relativePath:"01.操作系统/06.第五章 虚拟存储器/02.请求分页存储管理方式.md",key:"v-10ced923",path:"/pages/9b0e23/",headers:[{level:2,title:"基本思想",slug:"基本思想",normalizedTitle:"基本思想",charIndex:17},{level:2,title:"硬件支持",slug:"硬件支持",normalizedTitle:"硬件支持",charIndex:72},{level:3,title:"页表机制",slug:"页表机制",normalizedTitle:"页表机制",charIndex:114},{level:3,title:"缺页中断机构",slug:"缺页中断机构",normalizedTitle:"缺页中断机构",charIndex:150},{level:4,title:"缺页中断与一般中断的区别",slug:"缺页中断与一般中断的区别",normalizedTitle:"缺页中断与一般中断的区别",charIndex:253},{level:3,title:"地址变换机构以及变换过程",slug:"地址变换机构以及变换过程",normalizedTitle:"地址变换机构以及变换过程",charIndex:479}],headersStr:"基本思想 硬件支持 页表机制 缺页中断机构 缺页中断与一般中断的区别 地址变换机构以及变换过程",content:"# 请求分页存储管理方式\n\n\n# 基本思想\n\n在基本分页基础上，增加调页功能和页面置换功能；每次调入和换出的基本单位都是长度固定的页面\n\n\n# 硬件支持\n\n要想在基本分页的基础上实现虚拟存储管理，需要以下三个新的特性：\n\n\n# 页表机制\n\n\n\n> 请求分段存储管理方式将页表替换为段表即可。\n\n\n# 缺页中断机构\n\n * 请求分页系统中、每当发现要访问的页面不在内存、便产生中断通知 OS 调入缺页\n\n * 要经过 保护CPU现场（内中断）、分析中断原因、执行缺页中断程序、执行完毕恢复现场 等步骤\n\n# 缺页中断与一般中断的区别\n\n缺页中断是内中断（在 CPU 内发起的中断），一般中断是外中断（在 CPU 外发起的中断）。\n\n与一般中断相比，缺页中断有着明显的不同，主要表现在以下两个方面：\n\n 1. 通常，CPU 是在一条指令执行完后，才检查是否有中断请求到达。若有，便去响应；否则，继续执行下一条指令。然而，缺页中断则是在指令执行期间，发现所要访问的指令或数据不在内存时所产生和处理的。\n\n 2. 一条指令在执行期间，可能产生多次缺页中断。\n\n\n# 地址变换机构以及变换过程",normalizedContent:"# 请求分页存储管理方式\n\n\n# 基本思想\n\n在基本分页基础上，增加调页功能和页面置换功能；每次调入和换出的基本单位都是长度固定的页面\n\n\n# 硬件支持\n\n要想在基本分页的基础上实现虚拟存储管理，需要以下三个新的特性：\n\n\n# 页表机制\n\n\n\n> 请求分段存储管理方式将页表替换为段表即可。\n\n\n# 缺页中断机构\n\n * 请求分页系统中、每当发现要访问的页面不在内存、便产生中断通知 os 调入缺页\n\n * 要经过 保护cpu现场（内中断）、分析中断原因、执行缺页中断程序、执行完毕恢复现场 等步骤\n\n# 缺页中断与一般中断的区别\n\n缺页中断是内中断（在 cpu 内发起的中断），一般中断是外中断（在 cpu 外发起的中断）。\n\n与一般中断相比，缺页中断有着明显的不同，主要表现在以下两个方面：\n\n 1. 通常，cpu 是在一条指令执行完后，才检查是否有中断请求到达。若有，便去响应；否则，继续执行下一条指令。然而，缺页中断则是在指令执行期间，发现所要访问的指令或数据不在内存时所产生和处理的。\n\n 2. 一条指令在执行期间，可能产生多次缺页中断。\n\n\n# 地址变换机构以及变换过程",charsets:{cjk:!0}},{title:"页面置换算法",frontmatter:{title:"页面置换算法",date:"2023-02-08T09:30:18.000Z",permalink:"/pages/985167/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/06.%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/03.%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.html",relativePath:"01.操作系统/06.第五章 虚拟存储器/03.页面置换算法.md",key:"v-ebc83474",path:"/pages/985167/",headers:[{level:2,title:"最佳置换算法",slug:"最佳置换算法",normalizedTitle:"最佳置换算法",charIndex:13},{level:3,title:"案例分析",slug:"案例分析",normalizedTitle:"案例分析",charIndex:108},{level:2,title:"先进先出置换算法",slug:"先进先出置换算法",normalizedTitle:"先进先出置换算法",charIndex:410},{level:3,title:"案例分析",slug:"案例分析-2",normalizedTitle:"案例分析",charIndex:108},{level:2,title:"最近最久未使用置换算法",slug:"最近最久未使用置换算法",normalizedTitle:"最近最久未使用置换算法",charIndex:549},{level:3,title:"案例分析",slug:"案例分析-3",normalizedTitle:"案例分析",charIndex:108},{level:2,title:"Clock 置换算法",slug:"clock-置换算法",normalizedTitle:"clock 置换算法",charIndex:742}],headersStr:"最佳置换算法 案例分析 先进先出置换算法 案例分析 最近最久未使用置换算法 案例分析 Clock 置换算法",content:"# 页面置换算法\n\n\n# 最佳置换算法\n\n * 是一种理想化的算法，有最好的性能，但无法实现\n\n * 可以用该算法来评价其他算法\n\n * 思想：被置换的页面是以后永远不使用或以后长时间不使用的（需向后遍历）\n\n\n# 案例分析\n\n系统为某个进程（有 8 个页面）只分配了 3 个物理块，进程有如下的页面号引用\n\n7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1\n\n求该进程在最佳置换算法下执行完毕缺页多少次？中断多少次？缺页率为多少？页面置换多少次？\n\n\n\n缺页次数：9 次\n\n中断次数：每次缺页都会产生一次缺页中断 = 缺页次数 = 9 次\n\n页面执行次数：页面走向中一共有 20 个页面执行\n\n缺页率：缺页次数 / 页面执行次数 = 9/20 = 45%（不管用什么算法，都不可能使缺页率小于 45%）\n\n页面置换次数：新页面置换内存中老的页面的次数 = 9 - 3 = 6 次\n\n\n# 先进先出置换算法\n\n * 思想：淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面给予淘汰（向前看）\n\n\n# 案例分析\n\n题干同上\n\n缺页次数或中断次数：15 次\n\n页面执行次数：20\n\n缺页率：15/20 = 75%\n\n页面置换次数：15 - 3 = 12 次\n\n\n# 最近最久未使用置换算法\n\n * 思想：选择和现在相比最长时间没有使用的页面进行置换（向前看）\n\n * 硬件\n   \n   * 寄存器：记录某进程在内存中各页的使用情况\n   * 栈：用来保存当前使用的各个页面的页面号\n\n\n# 案例分析\n\n题干同上\n\n缺页次数或中断次数：12 次\n\n页面执行次数：20\n\n缺页率：12/20 = 60%\n\n页面置换次数：12 - 3 = 9 次\n\n\n# Clock 置换算法\n\n> 了解即可，不考察。\n\nLRU 算法是较好的一种算法，但由于它要求有较多的硬件支持，故在实际应用中，大多采用 LRU 的近似算法。Clock 算法就是用得较多的一种 LRU 近似算法。\n\n思想：为每页设置一位访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位被置为 1。置换算法选择一位淘汰时，只需检查页的访问位。如果是 0，就选择该页换出；若为 1，则重新将它置 0，暂不换出，而是给该页第二次驻留内存的机会，再按照 FIFO 算法检查下一个页面。\n\n\n\n\n\n",normalizedContent:"# 页面置换算法\n\n\n# 最佳置换算法\n\n * 是一种理想化的算法，有最好的性能，但无法实现\n\n * 可以用该算法来评价其他算法\n\n * 思想：被置换的页面是以后永远不使用或以后长时间不使用的（需向后遍历）\n\n\n# 案例分析\n\n系统为某个进程（有 8 个页面）只分配了 3 个物理块，进程有如下的页面号引用\n\n7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1\n\n求该进程在最佳置换算法下执行完毕缺页多少次？中断多少次？缺页率为多少？页面置换多少次？\n\n\n\n缺页次数：9 次\n\n中断次数：每次缺页都会产生一次缺页中断 = 缺页次数 = 9 次\n\n页面执行次数：页面走向中一共有 20 个页面执行\n\n缺页率：缺页次数 / 页面执行次数 = 9/20 = 45%（不管用什么算法，都不可能使缺页率小于 45%）\n\n页面置换次数：新页面置换内存中老的页面的次数 = 9 - 3 = 6 次\n\n\n# 先进先出置换算法\n\n * 思想：淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面给予淘汰（向前看）\n\n\n# 案例分析\n\n题干同上\n\n缺页次数或中断次数：15 次\n\n页面执行次数：20\n\n缺页率：15/20 = 75%\n\n页面置换次数：15 - 3 = 12 次\n\n\n# 最近最久未使用置换算法\n\n * 思想：选择和现在相比最长时间没有使用的页面进行置换（向前看）\n\n * 硬件\n   \n   * 寄存器：记录某进程在内存中各页的使用情况\n   * 栈：用来保存当前使用的各个页面的页面号\n\n\n# 案例分析\n\n题干同上\n\n缺页次数或中断次数：12 次\n\n页面执行次数：20\n\n缺页率：12/20 = 60%\n\n页面置换次数：12 - 3 = 9 次\n\n\n# clock 置换算法\n\n> 了解即可，不考察。\n\nlru 算法是较好的一种算法，但由于它要求有较多的硬件支持，故在实际应用中，大多采用 lru 的近似算法。clock 算法就是用得较多的一种 lru 近似算法。\n\n思想：为每页设置一位访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位被置为 1。置换算法选择一位淘汰时，只需检查页的访问位。如果是 0，就选择该页换出；若为 1，则重新将它置 0，暂不换出，而是给该页第二次驻留内存的机会，再按照 fifo 算法检查下一个页面。\n\n\n\n\n\n",charsets:{cjk:!0}},{title:"内存分配策略和分配算法",frontmatter:{title:"内存分配策略和分配算法",date:"2023-02-08T11:03:49.000Z",permalink:"/pages/3be910/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/06.%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/04.%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%E5%92%8C%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95.html",relativePath:"01.操作系统/06.第五章 虚拟存储器/04.内存分配策略和分配算法.md",key:"v-64f88198",path:"/pages/3be910/",headersStr:null,content:"# 内存分配策略和分配算法\n\n在为进程分配内存时，将涉及到三个问题：\n\n 1. 最小物理块数问题\n    \n    * 能保证进程正常运行所需的最小物理块数\n\n 2. 物理块的分配策略\n    \n    * 固定分配局部置换\n    \n    * 可变分配全部置换\n    \n    * 可变分配局部置换\n\n 3. 物理块分配算法\n    \n    * 平均分配算法\n    \n    * 按比例分配算法\n\n",normalizedContent:"# 内存分配策略和分配算法\n\n在为进程分配内存时，将涉及到三个问题：\n\n 1. 最小物理块数问题\n    \n    * 能保证进程正常运行所需的最小物理块数\n\n 2. 物理块的分配策略\n    \n    * 固定分配局部置换\n    \n    * 可变分配全部置换\n    \n    * 可变分配局部置换\n\n 3. 物理块分配算法\n    \n    * 平均分配算法\n    \n    * 按比例分配算法\n\n",charsets:{cjk:!0}},{title:"抖动与工作集",frontmatter:{title:"抖动与工作集",date:"2023-02-08T09:30:18.000Z",permalink:"/pages/8b5fe6/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/06.%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/05.%E6%8A%96%E5%8A%A8%E4%B8%8E%E5%B7%A5%E4%BD%9C%E9%9B%86.html",relativePath:"01.操作系统/06.第五章 虚拟存储器/05.抖动与工作集.md",key:"v-269b9ef7",path:"/pages/8b5fe6/",headers:[{level:2,title:"多道程序与处理机的利用率",slug:"多道程序与处理机的利用率",normalizedTitle:"多道程序与处理机的利用率",charIndex:13},{level:2,title:"产生“抖动”的原因",slug:"产生-抖动-的原因",normalizedTitle:"产生 “抖动” 的原因",charIndex:32},{level:3,title:"缺页率与物理块数的关系",slug:"缺页率与物理块数的关系",normalizedTitle:"缺页率与物理块数的关系",charIndex:263},{level:2,title:"工作集",slug:"工作集",normalizedTitle:"工作集",charIndex:5},{level:2,title:"预防抖动的方法",slug:"预防抖动的方法",normalizedTitle:"预防抖动的方法",charIndex:304}],headersStr:"多道程序与处理机的利用率 产生“抖动”的原因 缺页率与物理块数的关系 工作集 预防抖动的方法",content:"# 抖动与工作集\n\n\n# 多道程序与处理机的利用率\n\n\n\n\n# 产生 “抖动” 的原因\n\n同时在系统中运行的进程太多，从而使得分配给每一个进程的物理块数减少，不能满足进程正常运行的基本要求，致使每个进程运行时，频繁地出现缺页，必须请求系统将所缺之页调入内存。这会使得系统中排队等待页面调进 / 调出的进程数目增加。显然，对磁盘的有效访问时间也随之急剧增加，造成每个进程的大部分时间都用于页面的换进 / 换出，而几乎不能再做任何有效的工作，从而导致发生处理机的利用率急剧下降并趋于 0。此时的进程处于 “抖动” 状态。\n\n\n# 缺页率与物理块数的关系\n\n\n\n\n# 工作集\n\n> 了解即可，不考察。\n\n\n\n\n# 预防抖动的方法\n\n",normalizedContent:"# 抖动与工作集\n\n\n# 多道程序与处理机的利用率\n\n\n\n\n# 产生 “抖动” 的原因\n\n同时在系统中运行的进程太多，从而使得分配给每一个进程的物理块数减少，不能满足进程正常运行的基本要求，致使每个进程运行时，频繁地出现缺页，必须请求系统将所缺之页调入内存。这会使得系统中排队等待页面调进 / 调出的进程数目增加。显然，对磁盘的有效访问时间也随之急剧增加，造成每个进程的大部分时间都用于页面的换进 / 换出，而几乎不能再做任何有效的工作，从而导致发生处理机的利用率急剧下降并趋于 0。此时的进程处于 “抖动” 状态。\n\n\n# 缺页率与物理块数的关系\n\n\n\n\n# 工作集\n\n> 了解即可，不考察。\n\n\n\n\n# 预防抖动的方法\n\n",charsets:{cjk:!0}},{title:"考试题型",frontmatter:{title:"考试题型",date:"2023-01-05T20:00:46.000Z",permalink:"/pages/a80c85/"},regularPath:"/01.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/09.%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83/01.%E8%80%83%E8%AF%95%E9%A2%98%E5%9E%8B.html",relativePath:"01.操作系统/09.期末考试备考/01.考试题型.md",key:"v-71917082",path:"/pages/a80c85/",headersStr:null,content:"# 考试题型\n\n\n\n第一章文件管理就在基本原理和应用\n\n第六章主要考中断\n\n算法与计算问题求解，主要是上课做的大题\n\n问题分析与求解为三选二\n\nPV 操作必考，比书上的难一些，不止哲学家问题",normalizedContent:"# 考试题型\n\n\n\n第一章文件管理就在基本原理和应用\n\n第六章主要考中断\n\n算法与计算问题求解，主要是上课做的大题\n\n问题分析与求解为三选二\n\npv 操作必考，比书上的难一些，不止哲学家问题",charsets:{cjk:!0}},{title:"课堂速记",frontmatter:{title:"课堂速记",date:"2023-01-05T01:29:32.000Z",permalink:"/asm-notes/shorthand/"},regularPath:"/02.%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/01.%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/02.%E8%AF%BE%E5%A0%82%E9%80%9F%E8%AE%B0.html",relativePath:"02.汇编语言/01.汇编语言课程笔记/02.课堂速记.md",key:"v-88e97502",path:"/asm-notes/shorthand/",headers:[{level:2,title:"引入 进制转换",slug:"引入-进制转换",normalizedTitle:"引入 进制转换",charIndex:44},{level:3,title:"十六转十进制",slug:"十六转十进制",normalizedTitle:"十六转十进制",charIndex:56},{level:3,title:"十六转二进制",slug:"十六转二进制",normalizedTitle:"十六转二进制",charIndex:133},{level:3,title:"十进制转十六",slug:"十进制转十六",normalizedTitle:"十进制转十六",charIndex:221},{level:3,title:"二进制转十六",slug:"二进制转十六",normalizedTitle:"二进制转十六",charIndex:308},{level:3,title:"十进制转二进制",slug:"十进制转二进制",normalizedTitle:"十进制转二进制",charIndex:404},{level:3,title:"二进制转十进制",slug:"二进制转十进制",normalizedTitle:"二进制转十进制",charIndex:433},{level:3,title:"巧算法",slug:"巧算法",normalizedTitle:"巧算法",charIndex:464},{level:2,title:"第二章 寄存器",slug:"第二章-寄存器",normalizedTitle:"第二章 寄存器",charIndex:554},{level:3,title:"8086 访问地址",slug:"_8086-访问地址",normalizedTitle:"8086 访问地址",charIndex:566},{level:3,title:"CS:IP",slug:"cs-ip",normalizedTitle:"cs:ip",charIndex:637},{level:2,title:"第三章 寄存器（内存访问）",slug:"第三章-寄存器-内存访问",normalizedTitle:"第三章 寄存器（内存访问）",charIndex:716},{level:3,title:"内存中字的存储",slug:"内存中字的存储",normalizedTitle:"内存中字的存储",charIndex:734},{level:4,title:"例1",slug:"例1",normalizedTitle:"例 1",charIndex:910},{level:4,title:"例2",slug:"例2",normalizedTitle:"例 2",charIndex:919},{level:3,title:"堆栈",slug:"堆栈",normalizedTitle:"堆栈",charIndex:956},{level:4,title:"先进后出",slug:"先进后出",normalizedTitle:"先进后出",charIndex:1e3},{level:4,title:"SS:SP",slug:"ss-sp",normalizedTitle:"ss:sp",charIndex:1010},{level:2,title:"第四章",slug:"第四章",normalizedTitle:"第四章",charIndex:1109},{level:3,title:"源程序中的“程序”",slug:"源程序中的-程序",normalizedTitle:"源程序中的 “程序”",charIndex:1117},{level:3,title:"汇编程序&伪指令",slug:"汇编程序-伪指令",normalizedTitle:"汇编程序 &amp; 伪指令",charIndex:null},{level:3,title:"编译&连接",slug:"编译-连接",normalizedTitle:"编译 &amp; 连接",charIndex:null},{level:3,title:"谁将可执行文件中的程序装载进入内存并使它运行？",slug:"谁将可执行文件中的程序装载进入内存并使它运行",normalizedTitle:"谁将可执行文件中的程序装载进入内存并使它运行？",charIndex:1547},{level:3,title:"EXE文件中的程序的加载过程 DS",slug:"exe文件中的程序的加载过程-ds",normalizedTitle:"exe 文件中的程序的加载过程 ds",charIndex:1862},{level:3,title:"程序执行过程的跟踪",slug:"程序执行过程的跟踪",normalizedTitle:"程序执行过程的跟踪",charIndex:2143},{level:2,title:"第六章 包含多个段的程序",slug:"第六章-包含多个段的程序",normalizedTitle:"第六章 包含多个段的程序",charIndex:2230},{level:3,title:"在代码段中使用数据",slug:"在代码段中使用数据",normalizedTitle:"在代码段中使用数据",charIndex:2247},{level:3,title:"在代码段中使用栈",slug:"在代码段中使用栈",normalizedTitle:"在代码段中使用栈",charIndex:2348},{level:3,title:"将数据、代码、栈放入不同的段",slug:"将数据、代码、栈放入不同的段",normalizedTitle:"将数据、代码、栈放入不同的段",charIndex:2411},{level:2,title:"第七章 更灵活的定位内存地址的方法",slug:"第七章-更灵活的定位内存地址的方法",normalizedTitle:"第七章 更灵活的定位内存地址的方法",charIndex:2612},{level:3,title:"ASCII码",slug:"ascii码",normalizedTitle:"ascii 码",charIndex:2634},{level:3,title:"[bx+idata] 寄存器相对寻址",slug:"bx-idata-寄存器相对寻址",normalizedTitle:"[bx+idata] 寄存器相对寻址",charIndex:2688},{level:3,title:"SI和DI 基址变址寻址",slug:"si和di-基址变址寻址",normalizedTitle:"si 和 di 基址变址寻址",charIndex:2816},{level:3,title:"相对基址变址寻址（[bx+si+idata]和[bx+di+idata]）",slug:"相对基址变址寻址-bx-si-idata-和-bx-di-idata",normalizedTitle:"相对基址变址寻址（[bx+si+idata] 和 [bx+di+idata]）",charIndex:2927},{level:2,title:"第八章 数据处理的两个基本问题",slug:"第八章-数据处理的两个基本问题",normalizedTitle:"第八章 数据处理的两个基本问题",charIndex:2998},{level:3,title:"bx，si，di，bp",slug:"bx-si-di-bp",normalizedTitle:"bx，si，di，bp",charIndex:3047},{level:3,title:"寻址方式",slug:"寻址方式",normalizedTitle:"寻址方式",charIndex:3212},{level:3,title:"指令要处理的数据有多长？",slug:"指令要处理的数据有多长",normalizedTitle:"指令要处理的数据有多长？",charIndex:3233},{level:3,title:"div指令 书P169",slug:"div指令-书p169",normalizedTitle:"div 指令 书 p169",charIndex:3325},{level:2,title:"第九章 转移指令的原理",slug:"第九章-转移指令的原理",normalizedTitle:"第九章 转移指令的原理",charIndex:3666},{level:3,title:"offset",slug:"offset",normalizedTitle:"offset",charIndex:3682},{level:3,title:"jmp",slug:"jmp",normalizedTitle:"jmp",charIndex:3742},{level:2,title:"第十一章",slug:"第十一章",normalizedTitle:"第十一章",charIndex:3756},{level:3,title:"PF标志（Parity）",slug:"pf标志-parity",normalizedTitle:"pf 标志（parity）",charIndex:3765},{level:3,title:"SF标志（Sign）",slug:"sf标志-sign",normalizedTitle:"sf 标志（sign）",charIndex:3818},{level:3,title:"ZF标志（Zero）",slug:"zf标志-zero",normalizedTitle:"zf 标志（zero）",charIndex:3860},{level:3,title:"CF标志（Carry）",slug:"cf标志-carry",normalizedTitle:"cf 标志（carry）",charIndex:3907},{level:3,title:"OF标志（Overflow）",slug:"of标志-overflow",normalizedTitle:"of 标志（overflow）",charIndex:4023},{level:3,title:"adc指令",slug:"adc指令",normalizedTitle:"adc 指令",charIndex:4178},{level:3,title:"sbb指令",slug:"sbb指令",normalizedTitle:"sbb 指令",charIndex:4395},{level:3,title:"cmp指令",slug:"cmp指令",normalizedTitle:"cmp 指令",charIndex:4416},{level:3,title:"je指令等",slug:"je指令等",normalizedTitle:"je 指令等",charIndex:4661},{level:3,title:"DF标志和串传送指令",slug:"df标志和串传送指令",normalizedTitle:"df 标志和串传送指令",charIndex:4696},{level:2,title:"第十二章 内中断",slug:"第十二章-内中断",normalizedTitle:"第十二章 内中断",charIndex:4832},{level:2,title:"第十三章 int指令",slug:"第十三章-int指令",normalizedTitle:"第十三章 int 指令",charIndex:4862},{level:3,title:"13.5 BIOS和DOS中断例程的安装过程",slug:"_13-5-bios和dos中断例程的安装过程",normalizedTitle:"13.5 bios 和 dos 中断例程的安装过程",charIndex:4980},{level:2,title:"第十四章",slug:"第十四章",normalizedTitle:"第十四章",charIndex:5122},{level:3,title:"shl和shr指令",slug:"shl和shr指令",normalizedTitle:"shl 和 shr 指令",charIndex:5131},{level:2,title:"期末考试复习",slug:"期末考试复习",normalizedTitle:"期末考试复习",charIndex:5266}],headersStr:"引入 进制转换 十六转十进制 十六转二进制 十进制转十六 二进制转十六 十进制转二进制 二进制转十进制 巧算法 第二章 寄存器 8086 访问地址 CS:IP 第三章 寄存器（内存访问） 内存中字的存储 例1 例2 堆栈 先进后出 SS:SP 第四章 源程序中的“程序” 汇编程序&伪指令 编译&连接 谁将可执行文件中的程序装载进入内存并使它运行？ EXE文件中的程序的加载过程 DS 程序执行过程的跟踪 第六章 包含多个段的程序 在代码段中使用数据 在代码段中使用栈 将数据、代码、栈放入不同的段 第七章 更灵活的定位内存地址的方法 ASCII码 [bx+idata] 寄存器相对寻址 SI和DI 基址变址寻址 相对基址变址寻址（[bx+si+idata]和[bx+di+idata]） 第八章 数据处理的两个基本问题 bx，si，di，bp 寻址方式 指令要处理的数据有多长？ div指令 书P169 第九章 转移指令的原理 offset jmp 第十一章 PF标志（Parity） SF标志（Sign） ZF标志（Zero） CF标志（Carry） OF标志（Overflow） adc指令 sbb指令 cmp指令 je指令等 DF标志和串传送指令 第十二章 内中断 第十三章 int指令 13.5 BIOS和DOS中断例程的安装过程 第十四章 shl和shr指令 期末考试复习",content:"# 课堂速记\n\n> 本笔记使用教材《汇编语言（第三版）》，王爽，清华大学出版社\n\n\n# 引入 进制转换\n\n\n# 十六转十进制\n\n就用乘法，每一位乘以 16^0, 16^1, 16^2 ... 然后加在一起。\n\n举个例子，ff bf 是几？答：65471\n\n\n\n\n# 十六转二进制\n\n更简单了，只需把每一位，变成二进制的四位数，然后拼在一起。\n\n看个例子就懂了，ff bf 是二进制的几？答：1111 1111 1011 1111\n\n\n\n\n# 十进制转十六\n\n稍微复杂些，用短除法。每次除以 16，把余数从下到上拼起来，就得到了 16 进制的数。\n\n来一起试试，65471 是十六进制的几？答：ff bf\n\n\n\n\n# 二进制转十六\n\n又容易了，只需切成 4 个 4 个的小段，把每段对应的字母 / 数字拼在一起，就可以了。\n\n比如这个例子，11 1111 1011 1111 是几？答：3f bf\n\n\n\n\n# 十进制转二进制\n\n除二取余，倒序排列，高位补零。\n\n\n# 二进制转十进制\n\n同十六转十进制，但 16 改成 2\n\n\n# 巧算法\n\n如何快速把 2^n 的十进制数，转换为二进制？\n\n只需把 n 除以 4，得到 j 余 i。把 i 变成 2^i 做为第一位，其余的就是，j 是几就跟几个零。\n\n\n\n\n# 第二章 寄存器\n\n\n# 8086 访问地址\n\n\n\n\n\n\n\n\n\n一个段的最大大小为 2^16=65536=64K，此为偏移地址的最大表示大小 FFFFH。\n\n\n\n\n# CS:IP\n\n代码段的段地址存放在 CS 中，指令指针寄存器 IP 指示代码段中指令的偏移地址，处理器利用 CS:IP 取得下一条要执行的指令。\n\n\n\n\n# 第三章 寄存器（内存访问）\n\n\n# 内存中字的存储\n\n\n\n(1) 20H (2) 4E20H\n\n字节型数据＜字型数据。一个字型数据 (如 1234H) 存放在内存中，由 2 个连续的地址的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址内存单元存放字型数据的低位字节。\n\n\n\n\n\n\n\nmov 的大小就是 al 的大小\n\n\n\n\n\n此处 “一般的寄存器” 就是上例中的 bx\n\n# 例 1\n\n\n\n# 例 2\n\n\n\n1200+7C0A+4532+A963（舍弃溢出）\n\n\n# 堆栈\n\n8086CPU 入栈出栈都以字为单位，不能 push/pop 一个 al\n\n# 先进后出\n\n\n\n# SS:SP\n\n\n\n\n\n入栈出栈时 SP 会先进行 - 2/+2 的操作，push 时 SP 向上（低位）移动 - 2。然后将数据送入 SS:SP 指向的内存单元处。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 第四章\n\n\n# 源程序中的 “程序”\n\n汇编源程序：\n\n * 伪指令（编译器处理）\n * 汇编指令（编译为机器码）\n\n程序：源程序中最终由计算机执行、处理的指令或数据。\n\n\n# 汇编程序 & 伪指令\n\ncodesg：标号，放在 segment 的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。\n\n\n\n\n\n\n# 编译 & 连接\n\n当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件；\n\n程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件；\n\n一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。\n\n所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。\n\n\n# 谁将可执行文件中的程序装载进入内存并使它运行？\n\n在 DOS 中，可执行文件中的程序 P1 若要运行，必须有一个正在运行的程序 P2 将 P1 从可执行文件中加载入内存，将 CPU 的控制权交给它，P1 才能得以运行；当 P1 运行完毕后，应该将 CPU 的控制权交还给使它得以运行的程序 P2。\n\n（1）我们在 DOS 中直接执行 1.exe 时，是正在运行的 command 将 1.exe 中的程序加载入内存。\n\n（2）command 设置 CPU 的 CS:IP 指向程序的第一条指令（即程序的入口），从而使程序得以运行。\n\n（3）程序运行结束后，返回到 command 中，CPU 继续运行 command\n\n\n\n\n# EXE 文件中的程序的加载过程 DS\n\n\n\n程序加载后，ds 中存放着程序所在内存区的段地址，这个内存区的偏移地址为 0，则程序所在的内存区的地址为：ds:0；\n\n这个内存区的前 256 个字节中存放的是 PSP，dos 用来和程序进行通信。\n\n所以，我们从 ds 中可以得到 PSP 的段地址 SA，PSP 的偏移地址为 0，则物理地址为 SAX16+0。\n\n因为 PSP 占 256（100H）字节，所以程序的物理地址是：\n\nSA×16+0+256= SA×16+16×16= (SA+16)×16+0\n\n可用段地址和偏移地址表示为：SA+10:0\n\n\n# 程序执行过程的跟踪\n\n用 R 命令查看各个寄存器的设置情况\n\n\n\n用 U 命令查看其他指令\n\n\n\n使用 P 命令执行 int 21\n\n使用 Q 命令退出 Debug\n\n\n# 第六章 包含多个段的程序\n\n\n# 在代码段中使用数据\n\n\n\n程序解读见书 P124。 mov ax,4c00h 代表终止。\n\n程序 6.2\n\nend start 除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。\n\n\n# 在代码段中使用栈\n\n程序 6.3\n\n30h 是 48 字节，正好对应 dw 分配的 16 个字型数据，用于栈的空间。\n\n\n# 将数据、代码、栈放入不同的段\n\n程序 6.4\n\ncs 是自动装载的，不用在代码段中指定 cs 的指向。\n\n * 为什么 mov bx,0 可以将 ds:bx 指向 data 段中的第一个单元？\n   \n   因为 0 被认为是 ds,[0]\n\n * 为什么 mov cx,5 表示循环 5 次？\n   \n   cs 用来控制循环次数，每次执行 loop 指令时，都会检查 cs 的值是否为 0\n\n\n# 第七章 更灵活的定位内存地址的方法\n\n\n# ASCII 码\n\n程序 7.1\n\ninc 加 1，而不是加 2，因为一个 ASCII 码占一个字节\n\n\n# [bx+idata] 寄存器相对寻址\n\n[bx+idata] 表示一个内存单元，它的偏移地址为 (bx)+idata（bx 中的数值加上 idata）\n\nmov ax,[bx+200]\n\n数学化描述：(ax)=((ds)*16+(bx)+200)\n\n\n# SI 和 DI 基址变址寻址\n\n类似于 bx，但是不能分成两个 8 位寄存器\n\n段寄存器、两个内存单元之间、两个段之间都不能直接 mov，需要用寄存器中转\n\n> SI 元变址寄存器\n> \n> DI 目的变址寄存器\n\n\n# 相对基址变址寻址（[bx+si+idata] 和 [bx+di+idata]）\n\n问题 7.1、7.3、7.4、7.5 的分析很实用\n\n\n# 第八章 数据处理的两个基本问题\n\n> 用 reg 表示一个寄存器，sreg 表示段寄存器\n\n\n# bx，si，di，bp\n\nbp 用于在堆栈段上寻址，bs 默认用于数据段寻址。都是基址 (base)\n\n“两个 i 不相见，两个 b 不相见”\n\n错误指令：\n\nmov ax,[bx+bp]\n\nmov ax,[si+di]\n\n只要在 [...] 中使用寄存器 bp，且指令中没有显性地给出段地址，段地址就默认在 ss 中。\n\n\n# 寻址方式\n\nP164 表 8.2\n\n\n# 指令要处理的数据有多长？\n\nword ptr 和 byte ptr 来显式的指定内存单元的长度\n\nP166: mov word ptr [1000H],1 -> 0100FF\n\n\n# div 指令 书 P169\n\ndiv byte ptr ds:[0]\n\n(al) = (ax) / ((ds) * 16 + 0) 的商\n\n(ah) = (ax) / ((ds) * 16 + 0) 的余数\n\ndiv word ptr es:[0]\n\n(ax) = [(dx) * 10000H + (ax)] / ((es) * 16 + 0) 的商\n\n(dx) = [(dx) * 10000H + (ax)] / ((es) * 16 + 0) 的余数\n\n> 低商高余\n\n> 例题\n> \n> mov ax,data\n> \n> mov ds,ax\n> \n> mov ax,ds[0]\n> \n> mov dx,ds[2]\n> \n> div word ptr ds:[4]\n\n\n# 第九章 转移指令的原理\n\n\n# offset\n\nP175、176\n\n> 问题 9.1 为什么要加 cs: ？\n\n不加冒号复制的是默认 ds 段\n\n\n# jmp\n\n讲得太快\n\n\n# 第十一章\n\n\n# PF 标志（Parity）\n\n表示奇偶性，1 的个数为奇数时 PF=0，为偶数个时 PF 为 1\n\n\n# SF 标志（Sign）\n\n结果为负那么 SF=1，结果非负数则 SF=0；\n\n\n# ZF 标志（Zero）\n\n结果为 0 那么 ZF=1, 结果不为 0 则 ZF=0；\n\n\n# CF 标志（Carry）\n\nmov al,97H\n\nsub al,98H\n\n执行后：(al)=FFH, CF=1, CF 记录了向更高位的借位值\n\n10010111\n\n10011000\n\n(-1)11111111\n\nFFH\n\n\n# OF 标志（Overflow）\n\nmov al,98\nadd al,99\n\n\n1\n2\n\n1\n2\n\n\n执行后 CF=0, OF=1\n\n对于无符号数运算，没有进位，CF=0；对于有符号数运算，发生了溢出（数值位向符号位进了一位，虽然污染了符号位，但此时数还是八位。如果进到第九位，则产生了进位），OF=1\n\n\n# adc 指令\n\nmov ax,1\nadd ax,ax\nadc ax,3\n\n\n1\n2\n3\n\n1\n2\n3\n\n\nadc 利用了 CF，执行时相当于计算 (ax)+3+CF=2+3+0=5\n\n计算 1EF000H+201000H，结果放在 ax（高 16 位）和 bx（低 16 位）中\n\nmov ax,001EH\nmov bx,F000H\nadd bx,1000H\nadc ax,0020H\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# sbb 指令\n\nadc 的减法版\n\n\n# cmp 指令\n\n不保存结果的减法比较，仅仅根据结果设置标志位\n\n\n\ncmp 比较大小不能仅靠 SF，因为可能溢出，还需要借助 OF\n\n * SF=1, OF=0，说明没有溢出，逻辑上结果正负 = 实际上结果正负，即 ah＜bh\n\n * SF=1, OF=1，溢出会污染符号位，正负性颠倒，即 ah＞bh\n\n * SF=0, OF=1，跟刚才逻辑一样，ah＜bh\n\n * SF=0, OF=0，ah＞bh；若 ZF=0，则 ah=bh\n\n任意一个为 1，另一个为 0 时，前者＜后者\n\n\n# je 指令等\n\n\n\n有符号位的是 jl（小于）、jg（大于）\n\n\n# DF 标志和串传送指令\n\ndf=0 每次操作后 si、di 递增\n\ndf=1 每次操作后 si、di 递减\n\nmovsb 将 ds:si 指向的内存单元的一个字节送入 es:di 中，然后根据 df 位的值，将 si 和 di 递增或递减\n\nmovsw\n\nrep\n\n\n# 第十二章 内中断\n\n中断向量表 四个单元\n\ndo0\n\n\n# 第十三章 int 指令\n\nint n，n 是中断类型码，功能是引发中断，相当于引发一个 n 号中断的中断过程，执行过程：\n\n标志寄存器入栈，IF=0，TF=0；CS、IP 入栈；(IP)=(n*4), (CS)=(n*4+2)\n\n\n# 13.5 BIOS 和 DOS 中断例程的安装过程\n\n编程时可以用 int 指令调用 BIOS 和 DOS 提供的中断例程\n\n//不重要\nmov ah,9 //调用设置光标的子程序\nmov al,'a'\nmov bh,7 //颜色设置\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# 第十四章\n\n\n# shl 和 shr 指令\n\n逻辑移位指令。将一个寄存器或内存单元中的数据向左移位，最后移出的一位写入 CF 中，最低为用 0 来补充。移动位数大于 1 时，必须把移动位数放在 cl 中。\n\nshl 左移，shr 右移。会影响到符号位。（算术右移不会影响符号位）\n\n\n# 期末考试复习\n\n选择，可能有判断题\n\n写一些指令，进行纠正\n\n2 道编程题\n\n宏不作要求\n\n一直到系统调用，比较重要\n\nhttps://github.com/sanmianti/AssemblyLanguageTest/blob/master/%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.md",normalizedContent:"# 课堂速记\n\n> 本笔记使用教材《汇编语言（第三版）》，王爽，清华大学出版社\n\n\n# 引入 进制转换\n\n\n# 十六转十进制\n\n就用乘法，每一位乘以 16^0, 16^1, 16^2 ... 然后加在一起。\n\n举个例子，ff bf 是几？答：65471\n\n\n\n\n# 十六转二进制\n\n更简单了，只需把每一位，变成二进制的四位数，然后拼在一起。\n\n看个例子就懂了，ff bf 是二进制的几？答：1111 1111 1011 1111\n\n\n\n\n# 十进制转十六\n\n稍微复杂些，用短除法。每次除以 16，把余数从下到上拼起来，就得到了 16 进制的数。\n\n来一起试试，65471 是十六进制的几？答：ff bf\n\n\n\n\n# 二进制转十六\n\n又容易了，只需切成 4 个 4 个的小段，把每段对应的字母 / 数字拼在一起，就可以了。\n\n比如这个例子，11 1111 1011 1111 是几？答：3f bf\n\n\n\n\n# 十进制转二进制\n\n除二取余，倒序排列，高位补零。\n\n\n# 二进制转十进制\n\n同十六转十进制，但 16 改成 2\n\n\n# 巧算法\n\n如何快速把 2^n 的十进制数，转换为二进制？\n\n只需把 n 除以 4，得到 j 余 i。把 i 变成 2^i 做为第一位，其余的就是，j 是几就跟几个零。\n\n\n\n\n# 第二章 寄存器\n\n\n# 8086 访问地址\n\n\n\n\n\n\n\n\n\n一个段的最大大小为 2^16=65536=64k，此为偏移地址的最大表示大小 ffffh。\n\n\n\n\n# cs:ip\n\n代码段的段地址存放在 cs 中，指令指针寄存器 ip 指示代码段中指令的偏移地址，处理器利用 cs:ip 取得下一条要执行的指令。\n\n\n\n\n# 第三章 寄存器（内存访问）\n\n\n# 内存中字的存储\n\n\n\n(1) 20h (2) 4e20h\n\n字节型数据＜字型数据。一个字型数据 (如 1234h) 存放在内存中，由 2 个连续的地址的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址内存单元存放字型数据的低位字节。\n\n\n\n\n\n\n\nmov 的大小就是 al 的大小\n\n\n\n\n\n此处 “一般的寄存器” 就是上例中的 bx\n\n# 例 1\n\n\n\n# 例 2\n\n\n\n1200+7c0a+4532+a963（舍弃溢出）\n\n\n# 堆栈\n\n8086cpu 入栈出栈都以字为单位，不能 push/pop 一个 al\n\n# 先进后出\n\n\n\n# ss:sp\n\n\n\n\n\n入栈出栈时 sp 会先进行 - 2/+2 的操作，push 时 sp 向上（低位）移动 - 2。然后将数据送入 ss:sp 指向的内存单元处。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 第四章\n\n\n# 源程序中的 “程序”\n\n汇编源程序：\n\n * 伪指令（编译器处理）\n * 汇编指令（编译为机器码）\n\n程序：源程序中最终由计算机执行、处理的指令或数据。\n\n\n# 汇编程序 & 伪指令\n\ncodesg：标号，放在 segment 的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。\n\n\n\n\n\n\n# 编译 & 连接\n\n当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件；\n\n程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件；\n\n一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。\n\n所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。\n\n\n# 谁将可执行文件中的程序装载进入内存并使它运行？\n\n在 dos 中，可执行文件中的程序 p1 若要运行，必须有一个正在运行的程序 p2 将 p1 从可执行文件中加载入内存，将 cpu 的控制权交给它，p1 才能得以运行；当 p1 运行完毕后，应该将 cpu 的控制权交还给使它得以运行的程序 p2。\n\n（1）我们在 dos 中直接执行 1.exe 时，是正在运行的 command 将 1.exe 中的程序加载入内存。\n\n（2）command 设置 cpu 的 cs:ip 指向程序的第一条指令（即程序的入口），从而使程序得以运行。\n\n（3）程序运行结束后，返回到 command 中，cpu 继续运行 command\n\n\n\n\n# exe 文件中的程序的加载过程 ds\n\n\n\n程序加载后，ds 中存放着程序所在内存区的段地址，这个内存区的偏移地址为 0，则程序所在的内存区的地址为：ds:0；\n\n这个内存区的前 256 个字节中存放的是 psp，dos 用来和程序进行通信。\n\n所以，我们从 ds 中可以得到 psp 的段地址 sa，psp 的偏移地址为 0，则物理地址为 sax16+0。\n\n因为 psp 占 256（100h）字节，所以程序的物理地址是：\n\nsa×16+0+256= sa×16+16×16= (sa+16)×16+0\n\n可用段地址和偏移地址表示为：sa+10:0\n\n\n# 程序执行过程的跟踪\n\n用 r 命令查看各个寄存器的设置情况\n\n\n\n用 u 命令查看其他指令\n\n\n\n使用 p 命令执行 int 21\n\n使用 q 命令退出 debug\n\n\n# 第六章 包含多个段的程序\n\n\n# 在代码段中使用数据\n\n\n\n程序解读见书 p124。 mov ax,4c00h 代表终止。\n\n程序 6.2\n\nend start 除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。\n\n\n# 在代码段中使用栈\n\n程序 6.3\n\n30h 是 48 字节，正好对应 dw 分配的 16 个字型数据，用于栈的空间。\n\n\n# 将数据、代码、栈放入不同的段\n\n程序 6.4\n\ncs 是自动装载的，不用在代码段中指定 cs 的指向。\n\n * 为什么 mov bx,0 可以将 ds:bx 指向 data 段中的第一个单元？\n   \n   因为 0 被认为是 ds,[0]\n\n * 为什么 mov cx,5 表示循环 5 次？\n   \n   cs 用来控制循环次数，每次执行 loop 指令时，都会检查 cs 的值是否为 0\n\n\n# 第七章 更灵活的定位内存地址的方法\n\n\n# ascii 码\n\n程序 7.1\n\ninc 加 1，而不是加 2，因为一个 ascii 码占一个字节\n\n\n# [bx+idata] 寄存器相对寻址\n\n[bx+idata] 表示一个内存单元，它的偏移地址为 (bx)+idata（bx 中的数值加上 idata）\n\nmov ax,[bx+200]\n\n数学化描述：(ax)=((ds)*16+(bx)+200)\n\n\n# si 和 di 基址变址寻址\n\n类似于 bx，但是不能分成两个 8 位寄存器\n\n段寄存器、两个内存单元之间、两个段之间都不能直接 mov，需要用寄存器中转\n\n> si 元变址寄存器\n> \n> di 目的变址寄存器\n\n\n# 相对基址变址寻址（[bx+si+idata] 和 [bx+di+idata]）\n\n问题 7.1、7.3、7.4、7.5 的分析很实用\n\n\n# 第八章 数据处理的两个基本问题\n\n> 用 reg 表示一个寄存器，sreg 表示段寄存器\n\n\n# bx，si，di，bp\n\nbp 用于在堆栈段上寻址，bs 默认用于数据段寻址。都是基址 (base)\n\n“两个 i 不相见，两个 b 不相见”\n\n错误指令：\n\nmov ax,[bx+bp]\n\nmov ax,[si+di]\n\n只要在 [...] 中使用寄存器 bp，且指令中没有显性地给出段地址，段地址就默认在 ss 中。\n\n\n# 寻址方式\n\np164 表 8.2\n\n\n# 指令要处理的数据有多长？\n\nword ptr 和 byte ptr 来显式的指定内存单元的长度\n\np166: mov word ptr [1000h],1 -> 0100ff\n\n\n# div 指令 书 p169\n\ndiv byte ptr ds:[0]\n\n(al) = (ax) / ((ds) * 16 + 0) 的商\n\n(ah) = (ax) / ((ds) * 16 + 0) 的余数\n\ndiv word ptr es:[0]\n\n(ax) = [(dx) * 10000h + (ax)] / ((es) * 16 + 0) 的商\n\n(dx) = [(dx) * 10000h + (ax)] / ((es) * 16 + 0) 的余数\n\n> 低商高余\n\n> 例题\n> \n> mov ax,data\n> \n> mov ds,ax\n> \n> mov ax,ds[0]\n> \n> mov dx,ds[2]\n> \n> div word ptr ds:[4]\n\n\n# 第九章 转移指令的原理\n\n\n# offset\n\np175、176\n\n> 问题 9.1 为什么要加 cs: ？\n\n不加冒号复制的是默认 ds 段\n\n\n# jmp\n\n讲得太快\n\n\n# 第十一章\n\n\n# pf 标志（parity）\n\n表示奇偶性，1 的个数为奇数时 pf=0，为偶数个时 pf 为 1\n\n\n# sf 标志（sign）\n\n结果为负那么 sf=1，结果非负数则 sf=0；\n\n\n# zf 标志（zero）\n\n结果为 0 那么 zf=1, 结果不为 0 则 zf=0；\n\n\n# cf 标志（carry）\n\nmov al,97h\n\nsub al,98h\n\n执行后：(al)=ffh, cf=1, cf 记录了向更高位的借位值\n\n10010111\n\n10011000\n\n(-1)11111111\n\nffh\n\n\n# of 标志（overflow）\n\nmov al,98\nadd al,99\n\n\n1\n2\n\n1\n2\n\n\n执行后 cf=0, of=1\n\n对于无符号数运算，没有进位，cf=0；对于有符号数运算，发生了溢出（数值位向符号位进了一位，虽然污染了符号位，但此时数还是八位。如果进到第九位，则产生了进位），of=1\n\n\n# adc 指令\n\nmov ax,1\nadd ax,ax\nadc ax,3\n\n\n1\n2\n3\n\n1\n2\n3\n\n\nadc 利用了 cf，执行时相当于计算 (ax)+3+cf=2+3+0=5\n\n计算 1ef000h+201000h，结果放在 ax（高 16 位）和 bx（低 16 位）中\n\nmov ax,001eh\nmov bx,f000h\nadd bx,1000h\nadc ax,0020h\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# sbb 指令\n\nadc 的减法版\n\n\n# cmp 指令\n\n不保存结果的减法比较，仅仅根据结果设置标志位\n\n\n\ncmp 比较大小不能仅靠 sf，因为可能溢出，还需要借助 of\n\n * sf=1, of=0，说明没有溢出，逻辑上结果正负 = 实际上结果正负，即 ah＜bh\n\n * sf=1, of=1，溢出会污染符号位，正负性颠倒，即 ah＞bh\n\n * sf=0, of=1，跟刚才逻辑一样，ah＜bh\n\n * sf=0, of=0，ah＞bh；若 zf=0，则 ah=bh\n\n任意一个为 1，另一个为 0 时，前者＜后者\n\n\n# je 指令等\n\n\n\n有符号位的是 jl（小于）、jg（大于）\n\n\n# df 标志和串传送指令\n\ndf=0 每次操作后 si、di 递增\n\ndf=1 每次操作后 si、di 递减\n\nmovsb 将 ds:si 指向的内存单元的一个字节送入 es:di 中，然后根据 df 位的值，将 si 和 di 递增或递减\n\nmovsw\n\nrep\n\n\n# 第十二章 内中断\n\n中断向量表 四个单元\n\ndo0\n\n\n# 第十三章 int 指令\n\nint n，n 是中断类型码，功能是引发中断，相当于引发一个 n 号中断的中断过程，执行过程：\n\n标志寄存器入栈，if=0，tf=0；cs、ip 入栈；(ip)=(n*4), (cs)=(n*4+2)\n\n\n# 13.5 bios 和 dos 中断例程的安装过程\n\n编程时可以用 int 指令调用 bios 和 dos 提供的中断例程\n\n//不重要\nmov ah,9 //调用设置光标的子程序\nmov al,'a'\nmov bh,7 //颜色设置\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# 第十四章\n\n\n# shl 和 shr 指令\n\n逻辑移位指令。将一个寄存器或内存单元中的数据向左移位，最后移出的一位写入 cf 中，最低为用 0 来补充。移动位数大于 1 时，必须把移动位数放在 cl 中。\n\nshl 左移，shr 右移。会影响到符号位。（算术右移不会影响符号位）\n\n\n# 期末考试复习\n\n选择，可能有判断题\n\n写一些指令，进行纠正\n\n2 道编程题\n\n宏不作要求\n\n一直到系统调用，比较重要\n\nhttps://github.com/sanmianti/assemblylanguagetest/blob/master/%e3%80%8a%e6%b1%87%e7%bc%96%e8%af%ad%e8%a8%80%e3%80%8b%e7%ac%ac%e4%b8%89%e7%89%88%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0.md",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"第二章 寄存器",frontmatter:{title:null,date:"2023-01-05T02:55:07.000Z",permalink:"/pages/ea8c9c/"},regularPath:"/02.%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/02.%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/03.%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%84%E5%AD%98%E5%99%A8.html",relativePath:"02.汇编语言/02.《汇编语言》第三版阅读笔记/03.第二章 寄存器.md",key:"v-cd163ea4",path:"/pages/ea8c9c/",headers:[{level:2,title:"2.1 通用寄存器",slug:"_2-1-通用寄存器",normalizedTitle:"2.1 通用寄存器",charIndex:225},{level:2,title:"2.2 字在寄存器中的存储",slug:"_2-2-字在寄存器中的存储",normalizedTitle:"2.2 字在寄存器中的存储",charIndex:424},{level:2,title:"2.3 几条汇编指令",slug:"_2-3-几条汇编指令",normalizedTitle:"2.3 几条汇编指令",charIndex:511},{level:2,title:"2.4 物理地址",slug:"_2-4-物理地址",normalizedTitle:"2.4 物理地址",charIndex:566},{level:2,title:"2.5 16位结构的CPU",slug:"_2-5-16位结构的cpu",normalizedTitle:"2.5 16 位结构的 cpu",charIndex:641},{level:2,title:"2.6 8086CPU给出物理地址的方法",slug:"_2-6-8086cpu给出物理地址的方法",normalizedTitle:"2.6 8086cpu 给出物理地址的方法",charIndex:862},{level:2,title:"2.7  “段地址X16+偏移地址=物理地址”的本质含义",slug:"_2-7-段地址x16-偏移地址-物理地址-的本质含义",normalizedTitle:"2.7  “段地址 x16 + 偏移地址 = 物理地址” 的本质含义",charIndex:null},{level:2,title:"2.8 段的概念",slug:"_2-8-段的概念",normalizedTitle:"2.8 段的概念",charIndex:1549},{level:2,title:"2.9 段寄存器*",slug:"_2-9-段寄存器",normalizedTitle:"2.9 段寄存器 *",charIndex:1701},{level:2,title:"2.10 CS和IP",slug:"_2-10-cs和ip",normalizedTitle:"2.10 cs 和 ip",charIndex:1763},{level:2,title:"2.11 修改CS、IP的指令",slug:"_2-11-修改cs、ip的指令",normalizedTitle:"2.11 修改 cs、ip 的指令",charIndex:1963},{level:2,title:"2.12 代码段",slug:"_2-12-代码段",normalizedTitle:"2.12 代码段",charIndex:2022},{level:2,title:"2.9~2.12小结",slug:"_2-9-2-12小结",normalizedTitle:"2.9~2.12 小结",charIndex:2127}],headersStr:"2.1 通用寄存器 2.2 字在寄存器中的存储 2.3 几条汇编指令 2.4 物理地址 2.5 16位结构的CPU 2.6 8086CPU给出物理地址的方法 2.7  “段地址X16+偏移地址=物理地址”的本质含义 2.8 段的概念 2.9 段寄存器* 2.10 CS和IP 2.11 修改CS、IP的指令 2.12 代码段 2.9~2.12小结",content:"# 第二章 寄存器\n\n一个典型的 CPU 由运算器、控制器、寄存器等器件构成：\n\n * 运算器进行信息处理；\n * 寄存器进行信息存储；\n * 控制器控制各种器件进行工作；\n * 内部总线连接各种器件，在它们之间进行数据的传送。\n\n寄存器是 CPU 内部的存储器件。\n\n8086CPU 内部有 14 个寄存器，分别是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。这 14 个寄存器都是 16 位的。\n\n\n# 2.1 通用寄存器\n\nAX、BX、CX、DX 这这四个寄存器通常用来存放一般性数据，被称为通用寄存器。\n\n为了保证向前兼容，8086CPU 的 AX、BX、CX、DX 这 4 个寄存器可以分为两个独立使用的 8 位寄存器来用：\n\n * AX 可以分为 AH 和 AL;\n * BX 可以分为 BH 和 BL;\n * CX 可以分为 CH 和 CL;\n * DX 可以分为 DH 和 DL。\n\n\n# 2.2 字在寄存器中的存储\n\n对于 8086CPU 来说，一个字由两个字节组成，这两个字节分别称之为高位字节和低位字节，并且存储于寄存器中的高 8 位和低 8 位。\n\n\n# 2.3 几条汇编指令\n\nmov ax, 001AH—— 转移指令\nadd ax, bx—— 求和指令\n\n\n# 2.4 物理地址\n\n所有内存单元构成的存储空间是一个一维线性空间，每一个内存单元在这个空间都有唯一的地址，我们将这个唯一的地址称为物理地址。\n\n\n# 2.5 16 位结构的 CPU\n\n8086CPU 是 16 位结构的 CPU，这也就是说，在 8086 内部，能够一次性处理、传输、暂时存储的信息的最大长度是 16 位的。内存单元的地址在送上地址总线之前，必须在 CPU 中处理、传输、暂时存放，对于 16 位 CPU，能一次性处理、传输、暂时存储 16 位的地址。\n\n但 8086CPU 有 20 根地址总线，那么 16 位的 8086CPU 是如何给出 20 位的地址总线的呢？\n\n\n# 2.6 8086CPU 给出物理地址的方法\n\n8086CPU 地址总线长度大于字长，导致程序物理地址无法一次性传递给 CPU。为此，8086CPU 采用一种在内部用两个 16 位地址合成的方法来形成一个 20 位的物理地址。\n\n当 8086CPU 要读写内存时：\n（1）CPU 中的相关部件提供两个 16 位的地址，一个称为段地址，另一个称为偏移地址；\n（2）段地址和偏移地址通过内部总线送入一个称为地址加法器的部件；\n（3）地址加法器将两个 16 位地址合成为一个 20 位的物理地址；\n（4）地址加法器通过内部总线将 20 位物理地址送入输入输出控制电路；\n（5）输入输出控制电路将 20 位物理地址送上地址总线；\n（6）20 位物理地址被地址总线送到存储器。\n\n地址加法器采用物理地址 = 段地址 X16 + 偏移地址的方法用段地址和偏移地址合成物理地址。\n\n\n# 2.7 “段地址 X16 + 偏移地址 = 物理地址” 的本质含义\n\n“段地址 X16 + 偏移地址 = 物理地址” 的本质含义是：CPU 在访问内存时，用一个基础地址（段地址 X16）和一个相对基础地址的偏移地址相加，给出内存单元的物理地址。\n\n举个例子：\n\n假如说隔壁部门的同事张三来找你询问李四的工位？你发现李四的工位不好直接描述，既不是在角落也不是在中间。这时你发现李四旁边坐着的是经理，所以你告诉张三说李四就是经理左边第二位的那个人。这就是生活中使用 “基础地址 + 偏移地址 = 物理地址” 的例子。\n\n还有比方说，大家描述学校水房的位置，一般会说在几号餐厅后面，或某宿舍楼旁边。\n\n\n# 2.8 段的概念\n\nCPU 访问内存单元时，必须向内存提供内存单元的物理地址。8086CPU 在内部用段地址和偏移地址移位相加的方法形成最终的物理地址。\n\nCPU 可以用不同的段地址和偏移地址形成同一个物理地址。\n\n可以根据需要，将地址连续、起始地址为 16 的倍数的一组内存单元定义为一个段。\n\n\n# 2.9 段寄存器 *\n\n8086CPU 内部有四个段寄存器：CS、DS、SS、ES。用于存储指定内存单元的段地址。\n\n\n# 2.10 CS 和 IP\n\n8086PC 机中，任意时刻，CPU 将 CS:IP 指向的内容当作指令执行。其中 CS 为代码段寄存器，IP 为指令指针寄存器。\n\n8086CPU 执行指令过程如下：\n\n（1） 从 CS：IP 指向的内存单元读取指令，读取的指令进入指令缓冲器；\n（2） IP = IP + 所读指令的长度，从而指向下一条指令；\n（3） 执行指令。转到步骤（1），重复这个过程。\n\n\n# 2.11 修改 CS、IP 的指令\n\n能够改变 CS、IP 内容的指令被统称为转移指令。如 jump 指令。\n\n\n# 2.12 代码段\n\n我们可以将长度为 N (N <= 64KB) 的一组代码，存在一组地址连续、起始地址为 16 的倍数的内存单元中。这段地质连续的内存空间就称之为代码段。简单来说也就是存放代码的段。\n\n\n# 2.9~2.12 小结\n\n> （1） 段地址在 8086CPU 的段寄存器中存放。当 8086CPU 要访问内存时，由段寄存器提供内存单元的段地址。8086CPU 有 4 个段寄存器，其中 CS 用来存放指令的段地址。\n> （2） CS 存放指令的段地址，IP 存放指令的偏移地址。8086 机中，任意时刻，CPU 将 CS:IP 指向的内容当做指令指向。\n> （3） 8086CPU 工作过程：略\n> （4） 8086CPU 提供转移指令修改 CS、IP 的内容。\n\n----------------------------------------",normalizedContent:"# 第二章 寄存器\n\n一个典型的 cpu 由运算器、控制器、寄存器等器件构成：\n\n * 运算器进行信息处理；\n * 寄存器进行信息存储；\n * 控制器控制各种器件进行工作；\n * 内部总线连接各种器件，在它们之间进行数据的传送。\n\n寄存器是 cpu 内部的存储器件。\n\n8086cpu 内部有 14 个寄存器，分别是：ax、bx、cx、dx、si、di、sp、bp、ip、cs、ss、ds、es、psw。这 14 个寄存器都是 16 位的。\n\n\n# 2.1 通用寄存器\n\nax、bx、cx、dx 这这四个寄存器通常用来存放一般性数据，被称为通用寄存器。\n\n为了保证向前兼容，8086cpu 的 ax、bx、cx、dx 这 4 个寄存器可以分为两个独立使用的 8 位寄存器来用：\n\n * ax 可以分为 ah 和 al;\n * bx 可以分为 bh 和 bl;\n * cx 可以分为 ch 和 cl;\n * dx 可以分为 dh 和 dl。\n\n\n# 2.2 字在寄存器中的存储\n\n对于 8086cpu 来说，一个字由两个字节组成，这两个字节分别称之为高位字节和低位字节，并且存储于寄存器中的高 8 位和低 8 位。\n\n\n# 2.3 几条汇编指令\n\nmov ax, 001ah—— 转移指令\nadd ax, bx—— 求和指令\n\n\n# 2.4 物理地址\n\n所有内存单元构成的存储空间是一个一维线性空间，每一个内存单元在这个空间都有唯一的地址，我们将这个唯一的地址称为物理地址。\n\n\n# 2.5 16 位结构的 cpu\n\n8086cpu 是 16 位结构的 cpu，这也就是说，在 8086 内部，能够一次性处理、传输、暂时存储的信息的最大长度是 16 位的。内存单元的地址在送上地址总线之前，必须在 cpu 中处理、传输、暂时存放，对于 16 位 cpu，能一次性处理、传输、暂时存储 16 位的地址。\n\n但 8086cpu 有 20 根地址总线，那么 16 位的 8086cpu 是如何给出 20 位的地址总线的呢？\n\n\n# 2.6 8086cpu 给出物理地址的方法\n\n8086cpu 地址总线长度大于字长，导致程序物理地址无法一次性传递给 cpu。为此，8086cpu 采用一种在内部用两个 16 位地址合成的方法来形成一个 20 位的物理地址。\n\n当 8086cpu 要读写内存时：\n（1）cpu 中的相关部件提供两个 16 位的地址，一个称为段地址，另一个称为偏移地址；\n（2）段地址和偏移地址通过内部总线送入一个称为地址加法器的部件；\n（3）地址加法器将两个 16 位地址合成为一个 20 位的物理地址；\n（4）地址加法器通过内部总线将 20 位物理地址送入输入输出控制电路；\n（5）输入输出控制电路将 20 位物理地址送上地址总线；\n（6）20 位物理地址被地址总线送到存储器。\n\n地址加法器采用物理地址 = 段地址 x16 + 偏移地址的方法用段地址和偏移地址合成物理地址。\n\n\n# 2.7 “段地址 x16 + 偏移地址 = 物理地址” 的本质含义\n\n“段地址 x16 + 偏移地址 = 物理地址” 的本质含义是：cpu 在访问内存时，用一个基础地址（段地址 x16）和一个相对基础地址的偏移地址相加，给出内存单元的物理地址。\n\n举个例子：\n\n假如说隔壁部门的同事张三来找你询问李四的工位？你发现李四的工位不好直接描述，既不是在角落也不是在中间。这时你发现李四旁边坐着的是经理，所以你告诉张三说李四就是经理左边第二位的那个人。这就是生活中使用 “基础地址 + 偏移地址 = 物理地址” 的例子。\n\n还有比方说，大家描述学校水房的位置，一般会说在几号餐厅后面，或某宿舍楼旁边。\n\n\n# 2.8 段的概念\n\ncpu 访问内存单元时，必须向内存提供内存单元的物理地址。8086cpu 在内部用段地址和偏移地址移位相加的方法形成最终的物理地址。\n\ncpu 可以用不同的段地址和偏移地址形成同一个物理地址。\n\n可以根据需要，将地址连续、起始地址为 16 的倍数的一组内存单元定义为一个段。\n\n\n# 2.9 段寄存器 *\n\n8086cpu 内部有四个段寄存器：cs、ds、ss、es。用于存储指定内存单元的段地址。\n\n\n# 2.10 cs 和 ip\n\n8086pc 机中，任意时刻，cpu 将 cs:ip 指向的内容当作指令执行。其中 cs 为代码段寄存器，ip 为指令指针寄存器。\n\n8086cpu 执行指令过程如下：\n\n（1） 从 cs：ip 指向的内存单元读取指令，读取的指令进入指令缓冲器；\n（2） ip = ip + 所读指令的长度，从而指向下一条指令；\n（3） 执行指令。转到步骤（1），重复这个过程。\n\n\n# 2.11 修改 cs、ip 的指令\n\n能够改变 cs、ip 内容的指令被统称为转移指令。如 jump 指令。\n\n\n# 2.12 代码段\n\n我们可以将长度为 n (n <= 64kb) 的一组代码，存在一组地址连续、起始地址为 16 的倍数的内存单元中。这段地质连续的内存空间就称之为代码段。简单来说也就是存放代码的段。\n\n\n# 2.9~2.12 小结\n\n> （1） 段地址在 8086cpu 的段寄存器中存放。当 8086cpu 要访问内存时，由段寄存器提供内存单元的段地址。8086cpu 有 4 个段寄存器，其中 cs 用来存放指令的段地址。\n> （2） cs 存放指令的段地址，ip 存放指令的偏移地址。8086 机中，任意时刻，cpu 将 cs:ip 指向的内容当做指令指向。\n> （3） 8086cpu 工作过程：略\n> （4） 8086cpu 提供转移指令修改 cs、ip 的内容。\n\n----------------------------------------",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"第一章 基础知识",frontmatter:{title:null,date:"2023-01-05T02:55:07.000Z",permalink:"/pages/e44e75/"},regularPath:"/02.%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/02.%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/02.%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html",relativePath:"02.汇编语言/02.《汇编语言》第三版阅读笔记/02.第一章 基础知识.md",key:"v-bd5139f6",path:"/pages/e44e75/",headers:[{level:2,title:"1.1 机器语言",slug:"_1-1-机器语言",normalizedTitle:"1.1 机器语言",charIndex:58},{level:2,title:"1.2 汇编语言的产生",slug:"_1-2-汇编语言的产生",normalizedTitle:"1.2 汇编语言的产生",charIndex:168},{level:2,title:"1.3 汇编语言的组成",slug:"_1-3-汇编语言的组成",normalizedTitle:"1.3 汇编语言的组成",charIndex:267},{level:2,title:"1.4 存储器",slug:"_1-4-存储器",normalizedTitle:"1.4 存储器",charIndex:401},{level:2,title:"1.5 指令和数据",slug:"_1-5-指令和数据",normalizedTitle:"1.5 指令和数据",charIndex:413},{level:2,title:"1.6 存储单元",slug:"_1-6-存储单元",normalizedTitle:"1.6 存储单元",charIndex:470},{level:2,title:"1.7 CPU 对存储器的读写",slug:"_1-7-cpu-对存储器的读写",normalizedTitle:"1.7 cpu 对存储器的读写",charIndex:604},{level:2,title:"1.8 地址总线",slug:"_1-8-地址总线",normalizedTitle:"1.8 地址总线",charIndex:683},{level:2,title:"1.9 数据总线",slug:"_1-9-数据总线",normalizedTitle:"1.9 数据总线",charIndex:765},{level:2,title:"1.10 控制总线",slug:"_1-10-控制总线",normalizedTitle:"1.10 控制总线",charIndex:806},{level:2,title:"1.1~1.10 小结",slug:"_1-1-1-10-小结",normalizedTitle:"1.1~1.10 小结",charIndex:862},{level:2,title:"1.11 内存地址空间（概述）",slug:"_1-11-内存地址空间-概述",normalizedTitle:"1.11 内存地址空间（概述）",charIndex:1338},{level:2,title:"1.12 主板",slug:"_1-12-主板",normalizedTitle:"1.12 主板",charIndex:1392},{level:2,title:"1.13 接口卡",slug:"_1-13-接口卡",normalizedTitle:"1.13 接口卡",charIndex:1404},{level:2,title:"1.14 各类存储器芯片",slug:"_1-14-各类存储器芯片",normalizedTitle:"1.14 各类存储器芯片",charIndex:1468},{level:2,title:"1.15 内存地址空间",slug:"_1-15-内存地址空间",normalizedTitle:"1.15 内存地址空间",charIndex:1771}],headersStr:"1.1 机器语言 1.2 汇编语言的产生 1.3 汇编语言的组成 1.4 存储器 1.5 指令和数据 1.6 存储单元 1.7 CPU 对存储器的读写 1.8 地址总线 1.9 数据总线 1.10 控制总线 1.1~1.10 小结 1.11 内存地址空间（概述） 1.12 主板 1.13 接口卡 1.14 各类存储器芯片 1.15 内存地址空间",content:"# 第一章 基础知识\n\n汇编课程研究重点放在如何利用硬件系统的编程结构和指令集有效灵活的控制系统进行工作。\n\n\n# 1.1 机器语言\n\n机器语言是机器指令的集合。电子计算机的机器指令是一列二进制数字。计算机将之转换为一列高低电平，以使计算机的电子器件受到驱动，进行运算。\n\n每一种微处理器都有自己的机器指令集，也就是机器语言。\n\n\n# 1.2 汇编语言的产生\n\n机器语言难以辩别和记忆，基于此人们发明了汇编语言。\n\n寄存器 简单的讲是 CPU 中（内部）可以存储数据的器件。\n编译器 能够将汇编指令转换为机器指令的翻译程序。\n\n\n# 1.3 汇编语言的组成\n\n汇编语言主要由以下 3 类指令组成：\n\n（1） 汇编指令：机器码的助记符，有对应的机器码。\n（2） 伪指令：没有对应的机器码，由编译器执行，计算机并不执行。\n（3） 其他符号：如 +、-、*、/ 等，由编译器识别，没有对应的机器码。\n\n\n# 1.4 存储器\n\n\n# 1.5 指令和数据\n\n指令和数据是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。\n\n\n# 1.6 存储单元\n\n计算机内的最小信息单位是 bit，即一个二进制位。\n计算机内的基本存储单元是 Byte，即一个字节。一个字节等于 8 个二进制位。\n1KB = 1024B, 1MB = 1024KB, 1GB = 1024MB, 1TB = 1024GB\n\n\n# 1.7 CPU 对存储器的读写\n\nCPU 通过地址总线给出数据存储位置。\nCPU 通过控制总线给出数据存储方向。\nCUP 通过数据总线进行数据传输。\n\n\n# 1.8 地址总线\n\n一个 CPU 有 N 根地址线，则可以说这个 CPU 的地址总线宽度为 N。这样的 CPU 最多可以寻找 2 的 N 次方个内存单元。\n\n\n# 1.9 数据总线\n\n数据总线的宽度决定了 CPU 和外界的数据传送速度。\n\n\n# 1.10 控制总线\n\nCPU 对外部器件的控制是通过控制总线来进行的。控制总线是一些不同控制线的集合。\n\n\n# 1.1~1.10 小结\n\n> （1） 汇编指令是机器指令的助记符，同机器指令一一对应。\n> （2） 每一种 CPU 都有自己的汇编指令集。\n> （3） CPU 可以直接使用的信息在存储器中存放。\n> （4） 在存储器中指令和数据没有任何区别，都是二进制信息。\n> （5） 存储单元从零开始顺序编号。 （6） 一个存储单元可以存储 8 个 bit，即 8 位二进制数。\n> （7） 1Byte = 8bit， 1KB = 1024B = 2^10B， 1MB = 1024KB = 2^20B, 1GB = 1024MB = 230B。210 = 1024, 2^16 = 65536。 （8） 每一个 CPU 芯片都有许多管脚，这些管脚和总线相连。也可以说，这些管脚引出总线。一个 CPU 可以引出 3 中总线的宽度标志了这个 CPU 的不同方面的性能：\n> 地址总线的宽度决定了 CPU 的寻址能力；\n> 数据总线的宽度决定了 CPU 与其他器件进行数据传送时一次数据传送量；\n> 控制总线的宽度决定了 CPU 对系统中其他器件的控制能力。\n\n\n# 1.11 内存地址空间（概述）\n\n内存地址空间就是 CPU 可以通过地址总线寻址到的内存单元集合。\n\n\n# 1.12 主板\n\n\n# 1.13 接口卡\n\nCPU 通过总线向接口卡发送命令，接口卡根据 CPU 的命令控制外设工作。如：网卡、显卡、声卡等。\n\n\n# 1.14 各类存储器芯片\n\nRAM: 随机存储器，可读可写，但必须带电存储，断电后存储内容消失。\nROM: 只读存储器，只能读出，不能写入。断电后存储内容不消失。\nBIOS: Basic Input/Output System，基本输入输出系统。BIOS 是由主板和各类接口卡（如显卡、网卡等）厂商提供的软件系统。 可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上茶油存储相应 BIOS 的 ROM。例如，主板上的 ROM 中存储着主板的 BIOS (通常称为系统 BIOS)；显卡上的 ROM 存储着显卡的 BIOS；如果网卡上装有 ROM，那其中就可以存储网卡的 BIOS。\n\n\n# 1.15 内存地址空间\n\n最终运行程序的是 CPU，我们用汇编语言编程的时候，必须要从 CPU 的角度考虑问题。对 CPU 来讲，系统中所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受 CPU 寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间。\n\n----------------------------------------",normalizedContent:"# 第一章 基础知识\n\n汇编课程研究重点放在如何利用硬件系统的编程结构和指令集有效灵活的控制系统进行工作。\n\n\n# 1.1 机器语言\n\n机器语言是机器指令的集合。电子计算机的机器指令是一列二进制数字。计算机将之转换为一列高低电平，以使计算机的电子器件受到驱动，进行运算。\n\n每一种微处理器都有自己的机器指令集，也就是机器语言。\n\n\n# 1.2 汇编语言的产生\n\n机器语言难以辩别和记忆，基于此人们发明了汇编语言。\n\n寄存器 简单的讲是 cpu 中（内部）可以存储数据的器件。\n编译器 能够将汇编指令转换为机器指令的翻译程序。\n\n\n# 1.3 汇编语言的组成\n\n汇编语言主要由以下 3 类指令组成：\n\n（1） 汇编指令：机器码的助记符，有对应的机器码。\n（2） 伪指令：没有对应的机器码，由编译器执行，计算机并不执行。\n（3） 其他符号：如 +、-、*、/ 等，由编译器识别，没有对应的机器码。\n\n\n# 1.4 存储器\n\n\n# 1.5 指令和数据\n\n指令和数据是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。\n\n\n# 1.6 存储单元\n\n计算机内的最小信息单位是 bit，即一个二进制位。\n计算机内的基本存储单元是 byte，即一个字节。一个字节等于 8 个二进制位。\n1kb = 1024b, 1mb = 1024kb, 1gb = 1024mb, 1tb = 1024gb\n\n\n# 1.7 cpu 对存储器的读写\n\ncpu 通过地址总线给出数据存储位置。\ncpu 通过控制总线给出数据存储方向。\ncup 通过数据总线进行数据传输。\n\n\n# 1.8 地址总线\n\n一个 cpu 有 n 根地址线，则可以说这个 cpu 的地址总线宽度为 n。这样的 cpu 最多可以寻找 2 的 n 次方个内存单元。\n\n\n# 1.9 数据总线\n\n数据总线的宽度决定了 cpu 和外界的数据传送速度。\n\n\n# 1.10 控制总线\n\ncpu 对外部器件的控制是通过控制总线来进行的。控制总线是一些不同控制线的集合。\n\n\n# 1.1~1.10 小结\n\n> （1） 汇编指令是机器指令的助记符，同机器指令一一对应。\n> （2） 每一种 cpu 都有自己的汇编指令集。\n> （3） cpu 可以直接使用的信息在存储器中存放。\n> （4） 在存储器中指令和数据没有任何区别，都是二进制信息。\n> （5） 存储单元从零开始顺序编号。 （6） 一个存储单元可以存储 8 个 bit，即 8 位二进制数。\n> （7） 1byte = 8bit， 1kb = 1024b = 2^10b， 1mb = 1024kb = 2^20b, 1gb = 1024mb = 230b。210 = 1024, 2^16 = 65536。 （8） 每一个 cpu 芯片都有许多管脚，这些管脚和总线相连。也可以说，这些管脚引出总线。一个 cpu 可以引出 3 中总线的宽度标志了这个 cpu 的不同方面的性能：\n> 地址总线的宽度决定了 cpu 的寻址能力；\n> 数据总线的宽度决定了 cpu 与其他器件进行数据传送时一次数据传送量；\n> 控制总线的宽度决定了 cpu 对系统中其他器件的控制能力。\n\n\n# 1.11 内存地址空间（概述）\n\n内存地址空间就是 cpu 可以通过地址总线寻址到的内存单元集合。\n\n\n# 1.12 主板\n\n\n# 1.13 接口卡\n\ncpu 通过总线向接口卡发送命令，接口卡根据 cpu 的命令控制外设工作。如：网卡、显卡、声卡等。\n\n\n# 1.14 各类存储器芯片\n\nram: 随机存储器，可读可写，但必须带电存储，断电后存储内容消失。\nrom: 只读存储器，只能读出，不能写入。断电后存储内容不消失。\nbios: basic input/output system，基本输入输出系统。bios 是由主板和各类接口卡（如显卡、网卡等）厂商提供的软件系统。 可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上茶油存储相应 bios 的 rom。例如，主板上的 rom 中存储着主板的 bios (通常称为系统 bios)；显卡上的 rom 存储着显卡的 bios；如果网卡上装有 rom，那其中就可以存储网卡的 bios。\n\n\n# 1.15 内存地址空间\n\n最终运行程序的是 cpu，我们用汇编语言编程的时候，必须要从 cpu 的角度考虑问题。对 cpu 来讲，系统中所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受 cpu 寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间。\n\n----------------------------------------",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"第三章 寄存器（内存访问）",frontmatter:{title:null,date:"2023-01-05T02:55:07.000Z",permalink:"/pages/252f3a/"},regularPath:"/02.%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/02.%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/04.%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%89.html",relativePath:"02.汇编语言/02.《汇编语言》第三版阅读笔记/04.第三章 寄存器（内存访问）.md",key:"v-64e50a5c",path:"/pages/252f3a/",headers:[{level:2,title:"3.1 内存中字的存储",slug:"_3-1-内存中字的存储",normalizedTitle:"3.1 内存中字的存储",charIndex:40},{level:2,title:"3.2 DS和[Address]",slug:"_3-2-ds和-address",normalizedTitle:"3.2 ds 和 [address]",charIndex:171},{level:2,title:"3.3 字的传送",slug:"_3-3-字的传送",normalizedTitle:"3.3 字的传送",charIndex:524},{level:2,title:"3.4 mov、add、sub指令",slug:"_3-4-mov、add、sub指令",normalizedTitle:"3.4 mov、add、sub 指令",charIndex:632},{level:2,title:"3.5 数据段",slug:"_3-5-数据段",normalizedTitle:"3.5 数据段",charIndex:889},{level:2,title:"3.1~3.5小结",slug:"_3-1-3-5小结",normalizedTitle:"3.1~3.5 小结",charIndex:971},{level:2,title:"3.6 栈",slug:"_3-6-栈",normalizedTitle:"3.6 栈",charIndex:1291},{level:2,title:"3.7 CPU提供的栈机制",slug:"_3-7-cpu提供的栈机制",normalizedTitle:"3.7 cpu 提供的栈机制",charIndex:1343},{level:2,title:"3.8 栈顶超界问题",slug:"_3-8-栈顶超界问题",normalizedTitle:"3.8 栈顶超界问题",charIndex:1783},{level:2,title:"3.9 push、pop指令",slug:"_3-9-push、pop指令",normalizedTitle:"3.9 push、pop 指令",charIndex:1892},{level:2,title:"3.10 栈段",slug:"_3-10-栈段",normalizedTitle:"3.10 栈段",charIndex:2646}],headersStr:"3.1 内存中字的存储 3.2 DS和[Address] 3.3 字的传送 3.4 mov、add、sub指令 3.5 数据段 3.1~3.5小结 3.6 栈 3.7 CPU提供的栈机制 3.8 栈顶超界问题 3.9 push、pop指令 3.10 栈段",content:'# 第三章 寄存器（内存访问）\n\n本章从内存访问的角度学习相关寄存器。\n\n\n# 3.1 内存中字的存储\n\n字单元：存放一个字型数据（16 位）的内存单元，由两个地址连续的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址单元存放字型数据的低位字节。\n\n这种存储方式也被称为小端存储，Intel 系列的处理器一般都是小端存储。\n\n\n# 3.2 DS 和 [Address]\n\n上一章我们学习了 CS 段寄存器，用于存放代码段段地址。这里我们再引入另外一个段寄存器 DS，用于存放数据段段地址。\n\n需要特别注意的是，8086CPU 不支持将数据直接送入段寄存器。 包括所有的段寄存器 CS、DS、SS、ES 都不支持将数据从内存直接送入。内存中的数据必须先送入其他中间寄存器，然后在从中间寄存器送入段寄存器。（此处描述有误：栈操作 "pop 段寄存器" 实际上就是将数据从内存中直接送入段寄存器，此处应该更正为无法通过 move 指令将数据从内存中直接送入段寄存器）\n\n"[address]" 表示一个内存单元，中括号中的 address 表示内存单元的偏移地址。默认情况下，8686CPU 取 DS 中的数据作为该内存单元的段地址。\n\n\n# 3.3 字的传送\n\n使用 move 指令一次可以传送一个字。move 指令可以将数据从内存送入寄存器，也可以将数据从寄存器送入内存，也可以将数据从寄存器送入寄存器。但 move 指令不支持内存到内存的传送。\n\n\n# 3.4 mov、add、sub 指令\n\nadd 指令和 sub 指令与 mov 指令用法类似，他们都有两个操作对象。这两个操作对象可以是如下格式：\n寄存器， 数据\n寄存器， 寄存器\n寄存器， 内存单元\n内存单元， 寄存器\n\n有两点需要注意：\n（1） mov、add、sub 指令的两个操作对象不能同时为内存单元。 （2） 段寄存器只能接收 mov 指令传送数据，不可以进行算术运算。如 add ds, ax 指令是违法的。（此处描述不够严谨，实际上段寄存器也可以接收来自操作栈的 pop 指令传递的数据）\n\n\n# 3.5 数据段\n\n数据段是一段长度为 N (N <= 64KB)、地址连续、其实地址为 16 的倍数的内存单元。我们用段寄存器 DS 存放数据段的段地址。\n\n\n# 3.1~3.5 小结\n\n> （1） 字在内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。\n> （2） 用 mov 指令访问内存单元，可以在 mov 指令中只给出单元的偏移地址，此时，段地址默认在 DS 寄存器中。\n> （3）[address] 表示一个偏移地址为 address 的内存单元。\n> （4） 在内存和寄存器之间传送数据时，高地址单元和高 8 位寄存器、低地址单元和低 8 位寄存器相对应。\n> （5） mov、add、sub 是具有两个操作对象的指令。jmp 是具有一个操作对象的指令。\n> （6） 可以根据自己的推测，在 debug 中实验指令的新格式。\n\n\n# 3.6 栈\n\n栈就是一种先进后出的数据结构。LIFO (Last In First Out)。\n\n\n# 3.7 CPU 提供的栈机制\n\n8086CPU 对栈提供两个基本操作指令：PUSH（入栈）和 POP（出栈）。 PUSH 是将数据送入栈中，POP 是将数据移出栈中。\n\n前面我们已经学习了 CS 和 DS 两个段寄存器。并且知道 CS:IP 指向的内存单元被当做指令，DS:[address] 指向的内存单元被当做数据。这里我们引入另外一个段寄存器 SS，SS 中保存的是栈顶元素的段地址，此外使用 SP 保存栈顶元素的偏移地址。故在任意时刻 SS:SP 都指向栈顶元素。\n\nPUSH AX 的操作详情：\n（1）SP=SP-2，SS:SP 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；\n（2）将 ax 中的内容送入 SS:SP 指向的内存单元，SS:SP 此时指向新的栈顶。\n\nPOP AX 的操作详情：\n（1）将 SS:SP 指向的内存单元处的数据送入 ax 中；\n（2）SP=SP+2，SS:SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。\n\n\n# 3.8 栈顶超界问题\n\n当栈满的时候进行 PUSH 操作或者栈空的时候使用 POP 操作，都将引发栈顶超界问题。\n\n8086CPU 并未对栈顶超界做任何处理，程序员在编程的时候应当避免使得栈顶超界的情况发生。\n\n\n# 3.9 push、pop 指令\n\npush 指令和 pop 指令支持如下形式：\n\npush 寄存器\npush 段寄存器\npush 内存单元\n\npop 寄存器\npop 段寄存器\npop 内存单元\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\npush、pop 实际上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与 mov 指令不同的是，push 和 pop 指令访问的内存单元的地址不是在指令中给出的，而是由 SS:SP 指出的。同时，push 和 pop 还要改变 sp 中的值。CPU 执行 mov 指令仅需一步，CPU 执行 push 和 pop 指令需要两步：传送数据和修改 sp 的值。\n\n需要注意的是，push、pop 等栈操作指令，修改的只是 SP，也就是说，栈顶的变化范围最大为：0~FFFFH。\n\n> 栈的综述\n> （1）8086CPU 提供了栈操作机制，方案如下。\n> 在 SS、SP 中存放栈顶的段地址和偏移地址；\n> 提供入栈和出栈指令，它们根据 SS:SP 指示的地址，按照栈的方式访问内存单元。\n> （2）push 指令的执行步骤：1、 SP=SP-2； 2、向 SS:SP 指向的字单元中送入数据。\n> （3）pop 指令的执行步骤：1、从 SS:SP 指向的字单元中读取数据；2、SP=SP+2。\n> （4）任意时刻，SS:SP 指向栈顶元素。 （5）8086CPU 只记录栈顶，栈空间的大小我们要自己管理。\n> （6）用栈来暂存以后要恢复的寄存器的内容时，寄存器出栈的顺序要和入栈的顺序相反。\n> （7）push、pop 实际上是一种内存传送指令，注意它们的灵活应用。\n> 栈是一种非常重要的机制，一定要深入理解，灵活掌握。 (P67)\n\n\n# 3.10 栈段\n\n与代码段、数据段类似，我们在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为 N (N<=64KB) 的一组地址连续、起始地址为 16 的倍数的内存单元，当做栈空间来用。只需要使用 SS:SP 指向它们。\n\n一个栈最大为 64KB，即偏移地址所能指向的最大范围。当一个大小为 64KB 的栈，其 SP=0 时则表示该栈为空或者栈满。\n\n> 段的综述\n> 我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元（通过偏移地址的移动来访问段内的单元）。这完全是我们自己的安排。\n> \n> 我们可以用一个段存放数据，将它定义为 “数据段”；\n> 我们可以用一个段存放代码，将它定义为 “代码段”；\n> 我们可以用一个段当做栈，将它定义为 “栈段”；\n> \n> 我们可以这样安排，但若要让 CPU 按照我们的安排来访问这些段，就要：\n> \n> 对于数据段，将它的段地址放在 DS 中，用 mov、add、sub 等访问内存单元的指令时，CPU 就将我们定义的数据段中的内容当做数据来访问；\n> \n> 对于代码段，将它的段地址放在 CS 中，将段中第一条指令的偏移地址放在 IP 中，这样 CPU 就将执行我们定义的代码段中的指令； 对于栈段，将它的段地址放在 SS 中，将栈顶单元的偏移地址放在 SP 中，这样 CPU 在需要进行栈操作的时候，比如执行 push、pop 指令等，就将我们定义的栈段当做栈空间来用。\n> \n> 可见，不管我们如何安排，CPU 将内存中的某段内容当做代码，是因为 CS:IP 指向了那里；CPU 将某段内存当做栈，是因为 SS:SP 指向了那里。我们一定要清楚，什么是我们的安排，以及如何让 CPU 按我们的安排行事。要非常清楚 CPU 的工作原理，才能在控制 CPU 按照我们安排运行的时候做到游刃有余。\n> \n> 比如我们将 10000H~1001FH 安排为代码段，并在里面存储如下代码：\n\nmov ax, 1000H   \nmov ss, ax  \nmov sp, 0020H         ;初始化栈顶  \nmov ax, cs  \nmov ds, ax            ;设置数据段段地址  \nmov ax, [0]\nadd ax, [2]\nmov bx, [4]\nadd bx, [6]\npush ax\npush bx\npop ax\npop bx\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 设置 CS=1000H，IP=0，这段代码将得到执行。可以看到，在这段代码中，我们又将 10000H1001FH 安排为栈段和数据段。10000H1001FH 这段内存，即是代码段，又是栈段和数据段。\n> \n> 一段内存，可以即是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是。关键在于 CPU 中寄存器的设置，即 CS、IP，SS、SP，DS 的指向。\n> \n> （p69）\n\n----------------------------------------',normalizedContent:'# 第三章 寄存器（内存访问）\n\n本章从内存访问的角度学习相关寄存器。\n\n\n# 3.1 内存中字的存储\n\n字单元：存放一个字型数据（16 位）的内存单元，由两个地址连续的内存单元组成。高地址内存单元存放字型数据的高位字节，低地址单元存放字型数据的低位字节。\n\n这种存储方式也被称为小端存储，intel 系列的处理器一般都是小端存储。\n\n\n# 3.2 ds 和 [address]\n\n上一章我们学习了 cs 段寄存器，用于存放代码段段地址。这里我们再引入另外一个段寄存器 ds，用于存放数据段段地址。\n\n需要特别注意的是，8086cpu 不支持将数据直接送入段寄存器。 包括所有的段寄存器 cs、ds、ss、es 都不支持将数据从内存直接送入。内存中的数据必须先送入其他中间寄存器，然后在从中间寄存器送入段寄存器。（此处描述有误：栈操作 "pop 段寄存器" 实际上就是将数据从内存中直接送入段寄存器，此处应该更正为无法通过 move 指令将数据从内存中直接送入段寄存器）\n\n"[address]" 表示一个内存单元，中括号中的 address 表示内存单元的偏移地址。默认情况下，8686cpu 取 ds 中的数据作为该内存单元的段地址。\n\n\n# 3.3 字的传送\n\n使用 move 指令一次可以传送一个字。move 指令可以将数据从内存送入寄存器，也可以将数据从寄存器送入内存，也可以将数据从寄存器送入寄存器。但 move 指令不支持内存到内存的传送。\n\n\n# 3.4 mov、add、sub 指令\n\nadd 指令和 sub 指令与 mov 指令用法类似，他们都有两个操作对象。这两个操作对象可以是如下格式：\n寄存器， 数据\n寄存器， 寄存器\n寄存器， 内存单元\n内存单元， 寄存器\n\n有两点需要注意：\n（1） mov、add、sub 指令的两个操作对象不能同时为内存单元。 （2） 段寄存器只能接收 mov 指令传送数据，不可以进行算术运算。如 add ds, ax 指令是违法的。（此处描述不够严谨，实际上段寄存器也可以接收来自操作栈的 pop 指令传递的数据）\n\n\n# 3.5 数据段\n\n数据段是一段长度为 n (n <= 64kb)、地址连续、其实地址为 16 的倍数的内存单元。我们用段寄存器 ds 存放数据段的段地址。\n\n\n# 3.1~3.5 小结\n\n> （1） 字在内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。\n> （2） 用 mov 指令访问内存单元，可以在 mov 指令中只给出单元的偏移地址，此时，段地址默认在 ds 寄存器中。\n> （3）[address] 表示一个偏移地址为 address 的内存单元。\n> （4） 在内存和寄存器之间传送数据时，高地址单元和高 8 位寄存器、低地址单元和低 8 位寄存器相对应。\n> （5） mov、add、sub 是具有两个操作对象的指令。jmp 是具有一个操作对象的指令。\n> （6） 可以根据自己的推测，在 debug 中实验指令的新格式。\n\n\n# 3.6 栈\n\n栈就是一种先进后出的数据结构。lifo (last in first out)。\n\n\n# 3.7 cpu 提供的栈机制\n\n8086cpu 对栈提供两个基本操作指令：push（入栈）和 pop（出栈）。 push 是将数据送入栈中，pop 是将数据移出栈中。\n\n前面我们已经学习了 cs 和 ds 两个段寄存器。并且知道 cs:ip 指向的内存单元被当做指令，ds:[address] 指向的内存单元被当做数据。这里我们引入另外一个段寄存器 ss，ss 中保存的是栈顶元素的段地址，此外使用 sp 保存栈顶元素的偏移地址。故在任意时刻 ss:sp 都指向栈顶元素。\n\npush ax 的操作详情：\n（1）sp=sp-2，ss:sp 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；\n（2）将 ax 中的内容送入 ss:sp 指向的内存单元，ss:sp 此时指向新的栈顶。\n\npop ax 的操作详情：\n（1）将 ss:sp 指向的内存单元处的数据送入 ax 中；\n（2）sp=sp+2，ss:sp 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。\n\n\n# 3.8 栈顶超界问题\n\n当栈满的时候进行 push 操作或者栈空的时候使用 pop 操作，都将引发栈顶超界问题。\n\n8086cpu 并未对栈顶超界做任何处理，程序员在编程的时候应当避免使得栈顶超界的情况发生。\n\n\n# 3.9 push、pop 指令\n\npush 指令和 pop 指令支持如下形式：\n\npush 寄存器\npush 段寄存器\npush 内存单元\n\npop 寄存器\npop 段寄存器\npop 内存单元\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\npush、pop 实际上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与 mov 指令不同的是，push 和 pop 指令访问的内存单元的地址不是在指令中给出的，而是由 ss:sp 指出的。同时，push 和 pop 还要改变 sp 中的值。cpu 执行 mov 指令仅需一步，cpu 执行 push 和 pop 指令需要两步：传送数据和修改 sp 的值。\n\n需要注意的是，push、pop 等栈操作指令，修改的只是 sp，也就是说，栈顶的变化范围最大为：0~ffffh。\n\n> 栈的综述\n> （1）8086cpu 提供了栈操作机制，方案如下。\n> 在 ss、sp 中存放栈顶的段地址和偏移地址；\n> 提供入栈和出栈指令，它们根据 ss:sp 指示的地址，按照栈的方式访问内存单元。\n> （2）push 指令的执行步骤：1、 sp=sp-2； 2、向 ss:sp 指向的字单元中送入数据。\n> （3）pop 指令的执行步骤：1、从 ss:sp 指向的字单元中读取数据；2、sp=sp+2。\n> （4）任意时刻，ss:sp 指向栈顶元素。 （5）8086cpu 只记录栈顶，栈空间的大小我们要自己管理。\n> （6）用栈来暂存以后要恢复的寄存器的内容时，寄存器出栈的顺序要和入栈的顺序相反。\n> （7）push、pop 实际上是一种内存传送指令，注意它们的灵活应用。\n> 栈是一种非常重要的机制，一定要深入理解，灵活掌握。 (p67)\n\n\n# 3.10 栈段\n\n与代码段、数据段类似，我们在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为 n (n<=64kb) 的一组地址连续、起始地址为 16 的倍数的内存单元，当做栈空间来用。只需要使用 ss:sp 指向它们。\n\n一个栈最大为 64kb，即偏移地址所能指向的最大范围。当一个大小为 64kb 的栈，其 sp=0 时则表示该栈为空或者栈满。\n\n> 段的综述\n> 我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元（通过偏移地址的移动来访问段内的单元）。这完全是我们自己的安排。\n> \n> 我们可以用一个段存放数据，将它定义为 “数据段”；\n> 我们可以用一个段存放代码，将它定义为 “代码段”；\n> 我们可以用一个段当做栈，将它定义为 “栈段”；\n> \n> 我们可以这样安排，但若要让 cpu 按照我们的安排来访问这些段，就要：\n> \n> 对于数据段，将它的段地址放在 ds 中，用 mov、add、sub 等访问内存单元的指令时，cpu 就将我们定义的数据段中的内容当做数据来访问；\n> \n> 对于代码段，将它的段地址放在 cs 中，将段中第一条指令的偏移地址放在 ip 中，这样 cpu 就将执行我们定义的代码段中的指令； 对于栈段，将它的段地址放在 ss 中，将栈顶单元的偏移地址放在 sp 中，这样 cpu 在需要进行栈操作的时候，比如执行 push、pop 指令等，就将我们定义的栈段当做栈空间来用。\n> \n> 可见，不管我们如何安排，cpu 将内存中的某段内容当做代码，是因为 cs:ip 指向了那里；cpu 将某段内存当做栈，是因为 ss:sp 指向了那里。我们一定要清楚，什么是我们的安排，以及如何让 cpu 按我们的安排行事。要非常清楚 cpu 的工作原理，才能在控制 cpu 按照我们安排运行的时候做到游刃有余。\n> \n> 比如我们将 10000h~1001fh 安排为代码段，并在里面存储如下代码：\n\nmov ax, 1000h   \nmov ss, ax  \nmov sp, 0020h         ;初始化栈顶  \nmov ax, cs  \nmov ds, ax            ;设置数据段段地址  \nmov ax, [0]\nadd ax, [2]\nmov bx, [4]\nadd bx, [6]\npush ax\npush bx\npop ax\npop bx\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 设置 cs=1000h，ip=0，这段代码将得到执行。可以看到，在这段代码中，我们又将 10000h1001fh 安排为栈段和数据段。10000h1001fh 这段内存，即是代码段，又是栈段和数据段。\n> \n> 一段内存，可以即是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是。关键在于 cpu 中寄存器的设置，即 cs、ip，ss、sp，ds 的指向。\n> \n> （p69）\n\n----------------------------------------',charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"第四章 第一个程序",frontmatter:{title:null,date:"2023-01-05T02:55:07.000Z",permalink:"/pages/310d5a/"},regularPath:"/02.%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/02.%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/05.%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F.html",relativePath:"02.汇编语言/02.《汇编语言》第三版阅读笔记/05.第四章 第一个程序.md",key:"v-424e13f0",path:"/pages/310d5a/",headers:[{level:2,title:"4.1 一个源程序从写出到执行的过程",slug:"_4-1-一个源程序从写出到执行的过程",normalizedTitle:"4.1 一个源程序从写出到执行的过程",charIndex:16},{level:2,title:"4.2 源程序",slug:"_4-2-源程序",normalizedTitle:"4.2 源程序",charIndex:230},{level:3,title:"1. 伪指令",slug:"_1-伪指令",normalizedTitle:"1. 伪指令",charIndex:483},{level:3,title:"2. 源程序中的“程序”",slug:"_2-源程序中的-程序",normalizedTitle:"2. 源程序中的 “程序”",charIndex:968},{level:3,title:"3. 标号",slug:"_3-标号",normalizedTitle:"3. 标号",charIndex:1038},{level:3,title:"4. 程序的结构",slug:"_4-程序的结构",normalizedTitle:"4. 程序的结构",charIndex:1161},{level:3,title:"5. 程序返回",slug:"_5-程序返回",normalizedTitle:"5. 程序返回",charIndex:1217},{level:3,title:"6. 语法错误和逻辑错误",slug:"_6-语法错误和逻辑错误",normalizedTitle:"6. 语法错误和逻辑错误",charIndex:1589},{level:2,title:"4.3 编辑源程序",slug:"_4-3-编辑源程序",normalizedTitle:"4.3 编辑源程序",charIndex:1680},{level:2,title:"4.4 编译",slug:"_4-4-编译",normalizedTitle:"4.4 编译",charIndex:1712},{level:2,title:"4.5 连接",slug:"_4-5-连接",normalizedTitle:"4.5 连接",charIndex:2078},{level:2,title:"4.6 以简化的方式进行编译和连接",slug:"_4-6-以简化的方式进行编译和连接",normalizedTitle:"4.6 以简化的方式进行编译和连接",charIndex:2765},{level:2,title:"4.7 1.exe的执行",slug:"_4-7-1-exe的执行",normalizedTitle:"4.7 1.exe 的执行",charIndex:2849},{level:2,title:"4.8 谁将可执行文件中的程序装载进入内存并使它运行",slug:"_4-8-谁将可执行文件中的程序装载进入内存并使它运行",normalizedTitle:"4.8 谁将可执行文件中的程序装载进入内存并使它运行",charIndex:2902},{level:2,title:"4.9 程序执行过程的跟踪",slug:"_4-9-程序执行过程的跟踪",normalizedTitle:"4.9 程序执行过程的跟踪",charIndex:3907}],headersStr:"4.1 一个源程序从写出到执行的过程 4.2 源程序 1. 伪指令 2. 源程序中的“程序” 3. 标号 4. 程序的结构 5. 程序返回 6. 语法错误和逻辑错误 4.3 编辑源程序 4.4 编译 4.5 连接 4.6 以简化的方式进行编译和连接 4.7 1.exe的执行 4.8 谁将可执行文件中的程序装载进入内存并使它运行 4.9 程序执行过程的跟踪",content:"# 第四章 第一个程序\n\n\n# 4.1 一个源程序从写出到执行的过程\n\n一个汇编语言程序从写出到最终执行主要经历三步：\n\n第一步：编写汇编语言程序；\n第二步：对源程序进行编译连接；\n第三步：执行可执行文件中的程序。\n\n对源程序进行编译连接生成可在操作系统中直接运行的可执行文件。可执行文件包含两部分内容。\n\n * 程序（从源程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）\n * 相关的描述信息（比如，程序有多大、要占用多少内存空间等）\n\n\n# 4.2 源程序\n\n一段简单的汇编语言源程序：\n\nassume cs:codesg\n\ncodesg segment\n\n    mov ax, 0123H\n    mov bx, 0456H\n    add ax, bx\n    add ax, ax\n\n    mov ax, 4c00H\n    int 21H\n\ncodesg ends\n\nend\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 1. 伪指令\n\n在汇编语言源程序中，包括两种指令，一种是汇编指令，一种是伪指令。汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为 CPU 所执行。而伪指令没有对应的机器指令，最终不被 CPU 所执行。伪指令是由编译器来执行的指令，编译器根据伪指令来进行相应的编译工作。\n\n下面介绍上面程序中所出现的几个伪指令：\n\n（1） segment 和 ends\n\nsegment 和 ends 是一对成对使用的伪指令。功能是定义一个段。使用格式为：\n\n段名 segment\n.\n.\n段名 ends\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n一个汇编语言程序是由多个段组成的，这些段被用来存放代码（代码段）、数据（数据段）或当做栈空间（栈段）来使用。\n\n（2）end\n\nend 是一个汇编语言的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令 end，就结束对源程序的编译。\n\n（3）assume\n\n这条伪指令的含义为 “假设”。它假设某一段寄存器和程序中的某一个用 segment...ends 定义的段相关联。即将定义的段的段地址存放在段寄存器中。\n\n\n# 2. 源程序中的 “程序”\n\n我们将源程序文件中的所有的内容称之为源程序，将源程序中最终由计算机执行、处理的指令或数据，称为程序。\n\n\n# 3. 标号\n\n汇编源程序中，除了汇编指令和伪指令外，还有一些标号，比如 “codesg”。一个标号指代了一个地址。比如 codesg 在 segment 的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。\n\n\n# 4. 程序的结构\n\n源程序就是由一些段组成的。我们可以在这些段中存放代码、数据、或将某个段当做栈空间。\n\n\n# 5. 程序返回\n\n一个程序结束后，将 CPU 控制权交还给使它得以运行的程序，我们称这个过程为程序返回。 程序返回指令：\n\nmov ax, 4c00H\nint 21H\n\n\n1\n2\n\n1\n2\n\n\n当前我们不必理解这两天语句的含义。只要记住使用这两条指令可以实现程序返回。\n\n段结束、程序结束、程序返回的区别\n\n目的           相关指令                   指令性质   指令执行者\n通知编译器一个段结束   段名 ends                伪指令    编译时，由编译器执行\n通知编译器程序结束    end                    伪指令    编译时，由编译器执行\n程序返回         mov ax,4c00H int 21H   汇编指令   执行时，由于 CPU 执行\n\n\n# 6. 语法错误和逻辑错误\n\n一般来说，程序在编译时被编译器发现的错误是语法错误，如 mov ss, 1234 。\n\n在程序编译后，在运行时发生的错误是逻辑错误，如除零操作。\n\n\n# 4.3 编辑源程序\n\n源程序文件以.asm 作为后缀。\n\n\n# 4.4 编译\n\n我们使用微软的 masm5.0 汇编编译器进行编译，文件名为 masm.exe。我们以 c:\\1.asm 为例说明编译源程序的方法步骤。\n\n（1）进入 DOS 方式，运行 masm.exe。\n\n...\n...\nSource filename [.ASM]: _\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n（2）输入要编译的源程序文件名，按 enter 键。\n\nSource filename [.ASM]: c:\\1.asm\nObject filename [1.obj]:\n\n\n1\n2\n\n1\n2\n\n\n输入要编译出的目标文件名，如果不输入则默认使用源程序名。\n\n（3）确定了目标文件名称后，继续按 Enter 键（两次），忽略中间文件的生成。\n\n最终完成对源程序的编译，生成目标文件。目标文件以.obj 作为后缀。\n\n\n# 4.5 连接\n\n在对源程序进行编译生成目标文件后，我们需要对目标文件进行连接，从而得到可执行文件。\n\n这里我们使用微软的 Overlay Linker3.60 连接器，文件名为 link.exe。我们以 4.4 中生成的目标文件 c:\\masm\\1.obj 为例说明连接操作步骤。\n\n（1）进入 DOS 方式，运行 link.exe。\n\n...\n...\nObject Modules [.OBJ]: _\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n（2）输入目标文件名，按 enter 键。\n\n...\n...\nObject Modules [.OBJ]: 1.obj\nRun File [1.EXE]: _\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n键入生成可执行文件的名称。如果不输入则默认使用源程序名。\n\n（3）确定了可执行文件名后，按 Enter 键（两次），忽略镜像文件的生成，忽略库文件的连接。\n\n经过以上三步后，最终会生成以.exe 结尾的可执行文件。\n\n连接的作用\n\n（1）当源程序很大时，可以将它分为多个源程序文件来单独编译，然后将生成的目标文件连接在一起，节约程序编译时间。\n\n（2）程序中调用了某个库文件的子程序，需要将这个库文件和该程序生成的目标文件连接在一起，生成一个可执行文件。\n\n（3）一个源程序编译后，达到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行 文件。\n\n\n# 4.6 以简化的方式进行编译和连接\n\n一键编译：\n\nmasm c:\\1.asm;\n\n\n1\n\n1\n\n\n一键连接：\n\nlink c:\\1.obj;\n\n\n1\n\n1\n\n\n\n# 4.7 1.exe 的执行\n\n进入 dos 环境，直接键入.exe 可执行文件的文件名即可执行。\n\n\n# 4.8 谁将可执行文件中的程序装载进入内存并使它运行\n\n（1）在 DOS 中直接执行 1.exe 时，是正在运行的 command，将 1.exe 中的程序加载入内存；\n\n（2）command 设置 CPU 的 CS:IP 指向程序的第一条指令（即程序入口），从而使程序得以运行。\n\n（3）程序运行结束后，返回到 command 中，CPU 继续运行 command。\n\n> 操作系统的外壳\n> \n> 操作系统是由多个功能模块组成的庞大、复杂的软件系统。任何通用的操作系统，都要提供一个称为 shell (外壳) 的程序，用户（操作人员）使用这个程序来操作计算机系统进行工作。\n> \n> DOS 中有一个程序 command.exe，这个程序在 DOS 中称为命令解释器，也就是 DOS 系统的 shell。\n> \n> DOS 启动时，先完成其他重要的初始化工作，然后运行 command.exe，command.exe 运行后，执行完其他的相关任务后，在屏幕上显示出由当前盘符和当前路径组成的提示符，比如：“c:\\” 或 “c:\\windows” 等，然后等待用户的输入。\n> \n> 用户可以输入要执行的命令，比如，cd、dir、type 等，这些命令由于 command 执行，command 执行完这些命令后，再次显示当前盘符和当前路径组成的提示符，等待用户输入。\n> \n> 如果用户要执行一个程序，则输入该程序可执行文件的名称，command 首先根据文件名找到可执行文件，然后将这个可执行文件中的程序加载入内存，设置 CS:IP 指向程序的入口。此后，command 暂停运行，CPU 运行程序。程序运行结束后，返回到 command 中，command 再次显示由当前盘符和当前路径组成的提示符，等待用户输入。\n> \n> 在 DOS 中，command 处理各种输入：命令或要执行的程序的文件名。我们就是通过 command 来进行工作的。\n\nshell : 操作人员和 OS 之间的 API。\n\n> 汇编程序从写出到执行的过程\n> \n> 到此，完成了一个汇编程序从写出到执行的全部过程。我们经历了这样一个历程： 编程（Edit） → 1.asm → 编译（masm） → 1.obj → 连接（link） → 1.exe → 加载（command） → 内存中的程序 → 运行（CPU）\n\n\n# 4.9 程序执行过程的跟踪\n\nDOS 系统中.exe 文件中程序的加载过程\n\n（1）找到一段起始地址为 SA:0000（即起始地址的偏移地址为 0）的容量足够的空闲内存区；\n\n（2）在这段内存区的前 256 个字节中，创建一个称为程序段前缀（PSP）的数据区，DOS 要利用 PSP 来和被加载程序进行通信；\n\n（3）从这段内存区的 256 字节处开始（在 PSP 后面），将程序装入，程序的地址被设为 SA+10H:0；（空闲内存区从 SA:0 开始，0~255 字节为 PSP，从 256 字节处开始存放程序，为了更好地区分 PSP 和程序，DOS 一般将它们划分到不同的段中，所以有了这样的地址安排：\n空闲内存区：SA:00\nPSP 区：SA:0\n程序区：SA+10:0\n注意：PSP 和程序区虽然物理地址连续，却有着不同的段地址 ）\n\n（4）将该内存区的段地址存取 ds 中，初始化其它相关寄存器后，设置 CS:IP 指向程序入口。\n\n程序加载进内存后，cx 中存放的是程序的长度，ds 存放着程序所在内存区的段地址，cs 存放可执行程序的段地址，ip 存放着可执行程序的偏移地址。\n\nDebug 常用命令\n\n我们使用 Debug 对程序的执行过程进行跟踪。\n用 T 命令单步执行程序的每一条执行。\n用 P 命令执行程序结束语句 int 21。\n用 Q 命令退出 debug。\n\n----------------------------------------",normalizedContent:"# 第四章 第一个程序\n\n\n# 4.1 一个源程序从写出到执行的过程\n\n一个汇编语言程序从写出到最终执行主要经历三步：\n\n第一步：编写汇编语言程序；\n第二步：对源程序进行编译连接；\n第三步：执行可执行文件中的程序。\n\n对源程序进行编译连接生成可在操作系统中直接运行的可执行文件。可执行文件包含两部分内容。\n\n * 程序（从源程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）\n * 相关的描述信息（比如，程序有多大、要占用多少内存空间等）\n\n\n# 4.2 源程序\n\n一段简单的汇编语言源程序：\n\nassume cs:codesg\n\ncodesg segment\n\n    mov ax, 0123h\n    mov bx, 0456h\n    add ax, bx\n    add ax, ax\n\n    mov ax, 4c00h\n    int 21h\n\ncodesg ends\n\nend\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 1. 伪指令\n\n在汇编语言源程序中，包括两种指令，一种是汇编指令，一种是伪指令。汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为 cpu 所执行。而伪指令没有对应的机器指令，最终不被 cpu 所执行。伪指令是由编译器来执行的指令，编译器根据伪指令来进行相应的编译工作。\n\n下面介绍上面程序中所出现的几个伪指令：\n\n（1） segment 和 ends\n\nsegment 和 ends 是一对成对使用的伪指令。功能是定义一个段。使用格式为：\n\n段名 segment\n.\n.\n段名 ends\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n一个汇编语言程序是由多个段组成的，这些段被用来存放代码（代码段）、数据（数据段）或当做栈空间（栈段）来使用。\n\n（2）end\n\nend 是一个汇编语言的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令 end，就结束对源程序的编译。\n\n（3）assume\n\n这条伪指令的含义为 “假设”。它假设某一段寄存器和程序中的某一个用 segment...ends 定义的段相关联。即将定义的段的段地址存放在段寄存器中。\n\n\n# 2. 源程序中的 “程序”\n\n我们将源程序文件中的所有的内容称之为源程序，将源程序中最终由计算机执行、处理的指令或数据，称为程序。\n\n\n# 3. 标号\n\n汇编源程序中，除了汇编指令和伪指令外，还有一些标号，比如 “codesg”。一个标号指代了一个地址。比如 codesg 在 segment 的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。\n\n\n# 4. 程序的结构\n\n源程序就是由一些段组成的。我们可以在这些段中存放代码、数据、或将某个段当做栈空间。\n\n\n# 5. 程序返回\n\n一个程序结束后，将 cpu 控制权交还给使它得以运行的程序，我们称这个过程为程序返回。 程序返回指令：\n\nmov ax, 4c00h\nint 21h\n\n\n1\n2\n\n1\n2\n\n\n当前我们不必理解这两天语句的含义。只要记住使用这两条指令可以实现程序返回。\n\n段结束、程序结束、程序返回的区别\n\n目的           相关指令                   指令性质   指令执行者\n通知编译器一个段结束   段名 ends                伪指令    编译时，由编译器执行\n通知编译器程序结束    end                    伪指令    编译时，由编译器执行\n程序返回         mov ax,4c00h int 21h   汇编指令   执行时，由于 cpu 执行\n\n\n# 6. 语法错误和逻辑错误\n\n一般来说，程序在编译时被编译器发现的错误是语法错误，如 mov ss, 1234 。\n\n在程序编译后，在运行时发生的错误是逻辑错误，如除零操作。\n\n\n# 4.3 编辑源程序\n\n源程序文件以.asm 作为后缀。\n\n\n# 4.4 编译\n\n我们使用微软的 masm5.0 汇编编译器进行编译，文件名为 masm.exe。我们以 c:\\1.asm 为例说明编译源程序的方法步骤。\n\n（1）进入 dos 方式，运行 masm.exe。\n\n...\n...\nsource filename [.asm]: _\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n（2）输入要编译的源程序文件名，按 enter 键。\n\nsource filename [.asm]: c:\\1.asm\nobject filename [1.obj]:\n\n\n1\n2\n\n1\n2\n\n\n输入要编译出的目标文件名，如果不输入则默认使用源程序名。\n\n（3）确定了目标文件名称后，继续按 enter 键（两次），忽略中间文件的生成。\n\n最终完成对源程序的编译，生成目标文件。目标文件以.obj 作为后缀。\n\n\n# 4.5 连接\n\n在对源程序进行编译生成目标文件后，我们需要对目标文件进行连接，从而得到可执行文件。\n\n这里我们使用微软的 overlay linker3.60 连接器，文件名为 link.exe。我们以 4.4 中生成的目标文件 c:\\masm\\1.obj 为例说明连接操作步骤。\n\n（1）进入 dos 方式，运行 link.exe。\n\n...\n...\nobject modules [.obj]: _\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n（2）输入目标文件名，按 enter 键。\n\n...\n...\nobject modules [.obj]: 1.obj\nrun file [1.exe]: _\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n键入生成可执行文件的名称。如果不输入则默认使用源程序名。\n\n（3）确定了可执行文件名后，按 enter 键（两次），忽略镜像文件的生成，忽略库文件的连接。\n\n经过以上三步后，最终会生成以.exe 结尾的可执行文件。\n\n连接的作用\n\n（1）当源程序很大时，可以将它分为多个源程序文件来单独编译，然后将生成的目标文件连接在一起，节约程序编译时间。\n\n（2）程序中调用了某个库文件的子程序，需要将这个库文件和该程序生成的目标文件连接在一起，生成一个可执行文件。\n\n（3）一个源程序编译后，达到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行 文件。\n\n\n# 4.6 以简化的方式进行编译和连接\n\n一键编译：\n\nmasm c:\\1.asm;\n\n\n1\n\n1\n\n\n一键连接：\n\nlink c:\\1.obj;\n\n\n1\n\n1\n\n\n\n# 4.7 1.exe 的执行\n\n进入 dos 环境，直接键入.exe 可执行文件的文件名即可执行。\n\n\n# 4.8 谁将可执行文件中的程序装载进入内存并使它运行\n\n（1）在 dos 中直接执行 1.exe 时，是正在运行的 command，将 1.exe 中的程序加载入内存；\n\n（2）command 设置 cpu 的 cs:ip 指向程序的第一条指令（即程序入口），从而使程序得以运行。\n\n（3）程序运行结束后，返回到 command 中，cpu 继续运行 command。\n\n> 操作系统的外壳\n> \n> 操作系统是由多个功能模块组成的庞大、复杂的软件系统。任何通用的操作系统，都要提供一个称为 shell (外壳) 的程序，用户（操作人员）使用这个程序来操作计算机系统进行工作。\n> \n> dos 中有一个程序 command.exe，这个程序在 dos 中称为命令解释器，也就是 dos 系统的 shell。\n> \n> dos 启动时，先完成其他重要的初始化工作，然后运行 command.exe，command.exe 运行后，执行完其他的相关任务后，在屏幕上显示出由当前盘符和当前路径组成的提示符，比如：“c:\\” 或 “c:\\windows” 等，然后等待用户的输入。\n> \n> 用户可以输入要执行的命令，比如，cd、dir、type 等，这些命令由于 command 执行，command 执行完这些命令后，再次显示当前盘符和当前路径组成的提示符，等待用户输入。\n> \n> 如果用户要执行一个程序，则输入该程序可执行文件的名称，command 首先根据文件名找到可执行文件，然后将这个可执行文件中的程序加载入内存，设置 cs:ip 指向程序的入口。此后，command 暂停运行，cpu 运行程序。程序运行结束后，返回到 command 中，command 再次显示由当前盘符和当前路径组成的提示符，等待用户输入。\n> \n> 在 dos 中，command 处理各种输入：命令或要执行的程序的文件名。我们就是通过 command 来进行工作的。\n\nshell : 操作人员和 os 之间的 api。\n\n> 汇编程序从写出到执行的过程\n> \n> 到此，完成了一个汇编程序从写出到执行的全部过程。我们经历了这样一个历程： 编程（edit） → 1.asm → 编译（masm） → 1.obj → 连接（link） → 1.exe → 加载（command） → 内存中的程序 → 运行（cpu）\n\n\n# 4.9 程序执行过程的跟踪\n\ndos 系统中.exe 文件中程序的加载过程\n\n（1）找到一段起始地址为 sa:0000（即起始地址的偏移地址为 0）的容量足够的空闲内存区；\n\n（2）在这段内存区的前 256 个字节中，创建一个称为程序段前缀（psp）的数据区，dos 要利用 psp 来和被加载程序进行通信；\n\n（3）从这段内存区的 256 字节处开始（在 psp 后面），将程序装入，程序的地址被设为 sa+10h:0；（空闲内存区从 sa:0 开始，0~255 字节为 psp，从 256 字节处开始存放程序，为了更好地区分 psp 和程序，dos 一般将它们划分到不同的段中，所以有了这样的地址安排：\n空闲内存区：sa:00\npsp 区：sa:0\n程序区：sa+10:0\n注意：psp 和程序区虽然物理地址连续，却有着不同的段地址 ）\n\n（4）将该内存区的段地址存取 ds 中，初始化其它相关寄存器后，设置 cs:ip 指向程序入口。\n\n程序加载进内存后，cx 中存放的是程序的长度，ds 存放着程序所在内存区的段地址，cs 存放可执行程序的段地址，ip 存放着可执行程序的偏移地址。\n\ndebug 常用命令\n\n我们使用 debug 对程序的执行过程进行跟踪。\n用 t 命令单步执行程序的每一条执行。\n用 p 命令执行程序结束语句 int 21。\n用 q 命令退出 debug。\n\n----------------------------------------",charsets:{cjk:!0},lastUpdated:"2023/01/20, 21:30:41",lastUpdatedTimestamp:1674221441e3},{title:"第五章  [BX]和loop指令",frontmatter:{title:null,date:"2023-01-05T02:55:07.000Z",permalink:"/pages/a97f13/"},regularPath:"/02.%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/02.%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/06.%E7%AC%AC%E4%BA%94%E7%AB%A0%20%5BBX%5D%E5%92%8Cloop%E6%8C%87%E4%BB%A4.html",relativePath:"02.汇编语言/02.《汇编语言》第三版阅读笔记/06.第五章 [BX]和loop指令.md",key:"v-98f5d5a4",path:"/pages/a97f13/",headers:[{level:2,title:"5.1 [BX]",slug:"_5-1-bx",normalizedTitle:"5.1 [bx]",charIndex:367},{level:2,title:"5.2 Loop指令",slug:"_5-2-loop指令",normalizedTitle:"5.2 loop 指令",charIndex:537},{level:2,title:"5.3 在Debug中跟踪用loop指令实现的循环程序",slug:"_5-3-在debug中跟踪用loop指令实现的循环程序",normalizedTitle:"5.3 在 debug 中跟踪用 loop 指令实现的循环程序",charIndex:756},{level:2,title:"5.4 Debug和汇编编译器masm对指令的不同处理",slug:"_5-4-debug和汇编编译器masm对指令的不同处理",normalizedTitle:"5.4 debug 和汇编编译器 masm 对指令的不同处理",charIndex:924},{level:2,title:"5.5 loop和[bx]的联合应用",slug:"_5-5-loop和-bx-的联合应用",normalizedTitle:"5.5 loop 和 [bx] 的联合应用",charIndex:1328},{level:2,title:"5.6 段前缀",slug:"_5-6-段前缀",normalizedTitle:"5.6 段前缀",charIndex:1555},{level:2,title:"5.7 一段安全的空间",slug:"_5-7-一段安全的空间",normalizedTitle:"5.7 一段安全的空间",charIndex:1842},{level:2,title:"5.8 段前缀的使用",slug:"_5-8-段前缀的使用",normalizedTitle:"5.8 段前缀的使用",charIndex:2021}],headersStr:"5.1 [BX] 5.2 Loop指令 5.3 在Debug中跟踪用loop指令实现的循环程序 5.4 Debug和汇编编译器masm对指令的不同处理 5.5 loop和[bx]的联合应用 5.6 段前缀 5.7 一段安全的空间 5.8 段前缀的使用",content:'# 第五章 [BX] 和 loop 指令\n\n1. [bx] 和内存单元的描述\n\n[bx] 表示一个内存单元，该内存单元的段地址位于 ds 中，偏移地址位于 bx 中。 该内存单元的完整地址为： ds*16 + bx。\n\n2. loop\n\n循环指令。指令格式为：loop 标号\n该指令分两步执行。\n\n第一步，计算 cx = cx -1\n第二步，判断 cx 中的值，不为零则跳转至标号出执行程序，如果为零则向下执行。\n\n3. 我们定义的描述性的符号：“（）”\n\n“（）” 表示一个内存单元或寄存器的内容。也即是存储器中存储的值。\n\n“（）” 中的元素可以有 3 中类型：寄存器名、段寄存器名、内存单元的物理地址（一个 20 位数据）。\n\n4. 约定符号 idata 表示常量\n\n在以后的学习中我们约定 idata 表示一个常量。\n\n\n# 5.1 [BX]\n\n[bx] 表示一个内存单元。\n\nmov ax, [bx] 代码的含义：将 ds:bx 所指向内存单元的内容放入 ax 寄存器中。即：(ax)=((ds*16)+(bx))\n\nmov [bx], ax 代码的含义：将 ax 中的内容放入 ds:bx 所指向的内存单元中。即：((ds*16)+(bx))=(ax)\n\n\n# 5.2 Loop 指令\n\n首先 loop 指令的格式是：loop 标号。该指令分两步执行：\n\n第一步， 计算 cx = cx - 1；\n第二步，判断 cx 中的值，不为零则跳转至标号处执行程序，如果为零则向下执行。\n\n一般使用 loop 指令实现循环功能。格式如下：\n\n    mov cx, n\ns:  add ax, ax\n    loop s\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n以上代码会循环执行 n 次。（n >= 0）\n\n\n# 5.3 在 Debug 中跟踪用 loop 指令实现的循环程序\n\n使用 Debug 调试程序时，有几条经常用到的指令。\n\nT 指令，单步执行指令。\n\ng 指令，跳至断点，从当前 IP 执行至指定 IP 处。"g 0012" 表示程序由当前位置执行至 DS:0012 处。\n\np 指令，循环执行指令，p 指令用于执行完当前次数。\n\n\n# 5.4 Debug 和汇编编译器 masm 对指令的不同处理\n\nDebug 和汇编编译器 masm 对形如 “mov ax, [0]” 这类指令的处理是不同的。debug 将 "[0]" 看做是一个内存单元，该内存单元的地址是 ds*6 + 0。而编译器直接将 “[0]” 看做立即数 0。因此有如下约定。\n\n（1）在汇编源程序中，如果指令访问一个内存单元，则在指令中必须用 "[...]" 来表示内存单元，如果在 “[...]” 里用一个常量 idata 直接给出内存单元的偏移地址，就要在 “[]” 的前面显式的给出段地址所在的段寄存器。\n\n（2）如果在 “[]” 里面用寄存器，比如 bx, 间接给出内存单元的偏移地址，则段地址默认在 ds 中。当然，也可以显式的给出段地址所在的段寄存器。\n\n以上两点概括来说就是，如果内存单元的偏移地址使用立即数给出，则必须显式指明其段地址所在的段寄存器。\n\n\n# 5.5 loop 和 [bx] 的联合应用\n\n通过 loop 和 [bx] 联合应用实现对连续内存单元的操作实例：\n\n    ...\n    mov bx, 0\n    mov cx, 50\n\ns:  mov ax, [bx]\n    inc bx\n    loop s\n    ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n以上代码通过循环实现了对内存单元 DS:0000H~DS:0032H 内容的操作。\n\n\n# 5.6 段前缀\n\n如果内存单元的偏移地址由 bx 给出，如 “mov ax, [bx]”，则段地址默认位于 ds 中。我们也可以在访问内存单元的指令中显式的给出内存单元段地址所在的段寄存器。比如：\n\n（1）mov ax, ds:[bx]\n（2）mov ax, cs:[bx]\n（3）mov ax, ss:[bx]\n（4）mov ax, cs:[bx]\n（5）mov ax, ss:[0]\n（6）mov ax, cs:[0]\n\n这些出现在访问内存单元的指令中，用于显式的指明内存单元的段地址的 “ds:”、“cs:”、“ss:”、“es:”，在汇编语言中称为段前缀。\n\n\n# 5.7 一段安全的空间\n\n（1）我们需要直接向一段内存汇总写入内容；\n\n（2）这段内存空间不应当存放系统或其他程序的数据或代码，否则写入操作很可能引发错误；\n\n（3）DOS 方式下，一般情况，0:200~0:2ff 空间中没有系统或其他程序的数据或代码；\n\n（4）以后，我们需要直接向一段内存中写入内容时，就使用 0:200~0:2ff 这段空间。\n\n\n# 5.8 段前缀的使用\n\n当需要操作的内存空间跨段时，显式的使用段前缀给出内存单元的段地址，可以避免在循环中对 ds 的重复设置。\n\n也即是说一个内存单元的段地址不仅仅可以由 ds 给出，也可以通过 cs、ss、es 给出。\n\n----------------------------------------',normalizedContent:'# 第五章 [bx] 和 loop 指令\n\n1. [bx] 和内存单元的描述\n\n[bx] 表示一个内存单元，该内存单元的段地址位于 ds 中，偏移地址位于 bx 中。 该内存单元的完整地址为： ds*16 + bx。\n\n2. loop\n\n循环指令。指令格式为：loop 标号\n该指令分两步执行。\n\n第一步，计算 cx = cx -1\n第二步，判断 cx 中的值，不为零则跳转至标号出执行程序，如果为零则向下执行。\n\n3. 我们定义的描述性的符号：“（）”\n\n“（）” 表示一个内存单元或寄存器的内容。也即是存储器中存储的值。\n\n“（）” 中的元素可以有 3 中类型：寄存器名、段寄存器名、内存单元的物理地址（一个 20 位数据）。\n\n4. 约定符号 idata 表示常量\n\n在以后的学习中我们约定 idata 表示一个常量。\n\n\n# 5.1 [bx]\n\n[bx] 表示一个内存单元。\n\nmov ax, [bx] 代码的含义：将 ds:bx 所指向内存单元的内容放入 ax 寄存器中。即：(ax)=((ds*16)+(bx))\n\nmov [bx], ax 代码的含义：将 ax 中的内容放入 ds:bx 所指向的内存单元中。即：((ds*16)+(bx))=(ax)\n\n\n# 5.2 loop 指令\n\n首先 loop 指令的格式是：loop 标号。该指令分两步执行：\n\n第一步， 计算 cx = cx - 1；\n第二步，判断 cx 中的值，不为零则跳转至标号处执行程序，如果为零则向下执行。\n\n一般使用 loop 指令实现循环功能。格式如下：\n\n    mov cx, n\ns:  add ax, ax\n    loop s\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n以上代码会循环执行 n 次。（n >= 0）\n\n\n# 5.3 在 debug 中跟踪用 loop 指令实现的循环程序\n\n使用 debug 调试程序时，有几条经常用到的指令。\n\nt 指令，单步执行指令。\n\ng 指令，跳至断点，从当前 ip 执行至指定 ip 处。"g 0012" 表示程序由当前位置执行至 ds:0012 处。\n\np 指令，循环执行指令，p 指令用于执行完当前次数。\n\n\n# 5.4 debug 和汇编编译器 masm 对指令的不同处理\n\ndebug 和汇编编译器 masm 对形如 “mov ax, [0]” 这类指令的处理是不同的。debug 将 "[0]" 看做是一个内存单元，该内存单元的地址是 ds*6 + 0。而编译器直接将 “[0]” 看做立即数 0。因此有如下约定。\n\n（1）在汇编源程序中，如果指令访问一个内存单元，则在指令中必须用 "[...]" 来表示内存单元，如果在 “[...]” 里用一个常量 idata 直接给出内存单元的偏移地址，就要在 “[]” 的前面显式的给出段地址所在的段寄存器。\n\n（2）如果在 “[]” 里面用寄存器，比如 bx, 间接给出内存单元的偏移地址，则段地址默认在 ds 中。当然，也可以显式的给出段地址所在的段寄存器。\n\n以上两点概括来说就是，如果内存单元的偏移地址使用立即数给出，则必须显式指明其段地址所在的段寄存器。\n\n\n# 5.5 loop 和 [bx] 的联合应用\n\n通过 loop 和 [bx] 联合应用实现对连续内存单元的操作实例：\n\n    ...\n    mov bx, 0\n    mov cx, 50\n\ns:  mov ax, [bx]\n    inc bx\n    loop s\n    ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n以上代码通过循环实现了对内存单元 ds:0000h~ds:0032h 内容的操作。\n\n\n# 5.6 段前缀\n\n如果内存单元的偏移地址由 bx 给出，如 “mov ax, [bx]”，则段地址默认位于 ds 中。我们也可以在访问内存单元的指令中显式的给出内存单元段地址所在的段寄存器。比如：\n\n（1）mov ax, ds:[bx]\n（2）mov ax, cs:[bx]\n（3）mov ax, ss:[bx]\n（4）mov ax, cs:[bx]\n（5）mov ax, ss:[0]\n（6）mov ax, cs:[0]\n\n这些出现在访问内存单元的指令中，用于显式的指明内存单元的段地址的 “ds:”、“cs:”、“ss:”、“es:”，在汇编语言中称为段前缀。\n\n\n# 5.7 一段安全的空间\n\n（1）我们需要直接向一段内存汇总写入内容；\n\n（2）这段内存空间不应当存放系统或其他程序的数据或代码，否则写入操作很可能引发错误；\n\n（3）dos 方式下，一般情况，0:200~0:2ff 空间中没有系统或其他程序的数据或代码；\n\n（4）以后，我们需要直接向一段内存中写入内容时，就使用 0:200~0:2ff 这段空间。\n\n\n# 5.8 段前缀的使用\n\n当需要操作的内存空间跨段时，显式的使用段前缀给出内存单元的段地址，可以避免在循环中对 ds 的重复设置。\n\n也即是说一个内存单元的段地址不仅仅可以由 ds 给出，也可以通过 cs、ss、es 给出。\n\n----------------------------------------',charsets:{cjk:!0},lastUpdated:"2023/01/20, 21:30:41",lastUpdatedTimestamp:1674221441e3},{title:"第六章 包含多个段的程序",frontmatter:{title:null,date:"2023-01-05T02:55:07.000Z",permalink:"/pages/f2f815/"},regularPath:"/02.%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/02.%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/07.%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F.html",relativePath:"02.汇编语言/02.《汇编语言》第三版阅读笔记/07.第六章 包含多个段的程序.md",key:"v-e967490c",path:"/pages/f2f815/",headers:[{level:2,title:"6.1 在代码段中使用数据",slug:"_6-1-在代码段中使用数据",normalizedTitle:"6.1 在代码段中使用数据",charIndex:86},{level:2,title:"6.2 在代码段中使用栈",slug:"_6-2-在代码段中使用栈",normalizedTitle:"6.2 在代码段中使用栈",charIndex:528},{level:2,title:"6.3 将数据、代码、栈放入不同的段",slug:"_6-3-将数据、代码、栈放入不同的段",normalizedTitle:"6.3 将数据、代码、栈放入不同的段",charIndex:1123}],headersStr:"6.1 在代码段中使用数据 6.2 在代码段中使用栈 6.3 将数据、代码、栈放入不同的段",content:"# 第六章 包含多个段的程序\n\n程序取得所需空间的方法有两种，一是在加载程序的时候为程序分配，再就是程序在执行的过程向系统分配。在本课程中，我们只讨论第一种方法。\n\n\n# 6.1 在代码段中使用数据\n\n下面一段代码用于计算 8 个数据的累加和，结果放在 ax 寄存器中：\n\nassume cs:code\n\ncode segment\n\n  dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h\n\nstart mov bx, 0\n      mov ax, 0\n\n      mov cx, 8\n  s:  add ax, cs:[bx]\n      add bx, 2\n      loop s\n\n  mov ax, 4c00H\n  int 21H\ncode ends\nend start\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n分析这段代码，我们使用 dw 定义了 8 个字型数据，并且使用 “end 标号” 的形式指明了程序的入口。\n\n\n# 6.2 在代码段中使用栈\n\nassume cs:codesg\n\ncodesg segment\n\n    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\n    dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n\nstart:  mov ax, cs\n        mov ss, ax\n        mov sp, 30h\n\n        mov bx, 0\n        mov cx, 8\n    s:  push cs:[bx]\n        add bx, 2\n        loop s\n\n        mov bx, 0\n        mov cx, 8\n    s0: pop cs:[bx]\n        add bx, 2\n        loop s0\n\n    mov ax, 4c00h\n    int 21h\n\ncodesg ends\nend start\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 6.3 将数据、代码、栈放入不同的段\n\nassume cs:code, ds:data, ss:stack\n\ndata segment\n  dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\ndata ends\n\nstack segment\n  dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\nstack ends\n\ncode segment\n\nstart:  mov ax, stack\n        mov ss, ax\n        mov sp, 20h\n\n        mov ax, data\n        mov ds, ax\n\n        mov bx, 0\n\n        mov cx, 8\n    s:  push [bx]\n        add bx, 2\n        loop s\n\n        mov bx, 0\n\n        mov cx, 8\n   s0:  pop [bx]\n        add bx, 2\n        loop s0\n\n      mov ax, 4c00h\n      int 21h\n\ncode ends\n\nend start\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n下面对以上代码进行说明。\n\n（1）定义多个段的方法\n\n定义数据段、栈段与定义代码段的方法没有区别，只是对于不同的段，要有不同的段名。\n\n（2）对段地址的引用\n\n在程序中，段名就相当于一个标号，它代表了段地址。例如程序中 “data” 段中的数据 “0abch” 的地址就是：data:6。要将它送入 bx 中，代码如下：\n\nmov ax, data\nmov ds, ax\nmov bx, ds:[6]\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n（3）“代码段”、“数据段”、“栈段” 完全是我们的安排\n\n我们通过 “end 标号” 的形式来声明程序的入口地址，这个入口信息被写入可执行文件中的描述信息中。可执行文件中的程序被加载入内存后，CPU 的 CS:IP 就会被设置指向这个入口。\n\n我们通过如下代码来指定程序的栈段：\n\nmov ax, stack\nmov ss, ax\nmov sp, 20h\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n通过如下代码来指定数据段：\n\nmov ax, data\nmov ds, ax\n\n\n1\n2\n\n1\n2\n\n\n总而言之，CPU 到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问，还是当作栈空间，完全靠程序中具体的汇编指令，和汇编指令对 CS:IP、SS:SP、DS 等寄存器的设置来决定的。\n\n----------------------------------------",normalizedContent:"# 第六章 包含多个段的程序\n\n程序取得所需空间的方法有两种，一是在加载程序的时候为程序分配，再就是程序在执行的过程向系统分配。在本课程中，我们只讨论第一种方法。\n\n\n# 6.1 在代码段中使用数据\n\n下面一段代码用于计算 8 个数据的累加和，结果放在 ax 寄存器中：\n\nassume cs:code\n\ncode segment\n\n  dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h\n\nstart mov bx, 0\n      mov ax, 0\n\n      mov cx, 8\n  s:  add ax, cs:[bx]\n      add bx, 2\n      loop s\n\n  mov ax, 4c00h\n  int 21h\ncode ends\nend start\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n分析这段代码，我们使用 dw 定义了 8 个字型数据，并且使用 “end 标号” 的形式指明了程序的入口。\n\n\n# 6.2 在代码段中使用栈\n\nassume cs:codesg\n\ncodesg segment\n\n    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\n    dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n\nstart:  mov ax, cs\n        mov ss, ax\n        mov sp, 30h\n\n        mov bx, 0\n        mov cx, 8\n    s:  push cs:[bx]\n        add bx, 2\n        loop s\n\n        mov bx, 0\n        mov cx, 8\n    s0: pop cs:[bx]\n        add bx, 2\n        loop s0\n\n    mov ax, 4c00h\n    int 21h\n\ncodesg ends\nend start\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 6.3 将数据、代码、栈放入不同的段\n\nassume cs:code, ds:data, ss:stack\n\ndata segment\n  dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h\ndata ends\n\nstack segment\n  dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\nstack ends\n\ncode segment\n\nstart:  mov ax, stack\n        mov ss, ax\n        mov sp, 20h\n\n        mov ax, data\n        mov ds, ax\n\n        mov bx, 0\n\n        mov cx, 8\n    s:  push [bx]\n        add bx, 2\n        loop s\n\n        mov bx, 0\n\n        mov cx, 8\n   s0:  pop [bx]\n        add bx, 2\n        loop s0\n\n      mov ax, 4c00h\n      int 21h\n\ncode ends\n\nend start\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n下面对以上代码进行说明。\n\n（1）定义多个段的方法\n\n定义数据段、栈段与定义代码段的方法没有区别，只是对于不同的段，要有不同的段名。\n\n（2）对段地址的引用\n\n在程序中，段名就相当于一个标号，它代表了段地址。例如程序中 “data” 段中的数据 “0abch” 的地址就是：data:6。要将它送入 bx 中，代码如下：\n\nmov ax, data\nmov ds, ax\nmov bx, ds:[6]\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n（3）“代码段”、“数据段”、“栈段” 完全是我们的安排\n\n我们通过 “end 标号” 的形式来声明程序的入口地址，这个入口信息被写入可执行文件中的描述信息中。可执行文件中的程序被加载入内存后，cpu 的 cs:ip 就会被设置指向这个入口。\n\n我们通过如下代码来指定程序的栈段：\n\nmov ax, stack\nmov ss, ax\nmov sp, 20h\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n通过如下代码来指定数据段：\n\nmov ax, data\nmov ds, ax\n\n\n1\n2\n\n1\n2\n\n\n总而言之，cpu 到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问，还是当作栈空间，完全靠程序中具体的汇编指令，和汇编指令对 cs:ip、ss:sp、ds 等寄存器的设置来决定的。\n\n----------------------------------------",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"第七章 更灵活的定位内存地址的方法",frontmatter:{title:null,date:"2023-01-05T02:55:07.000Z",permalink:"/pages/a1378c/"},regularPath:"/02.%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/02.%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/08.%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95.html",relativePath:"02.汇编语言/02.《汇编语言》第三版阅读笔记/08.第七章 更灵活的定位内存地址的方法.md",key:"v-2843adab",path:"/pages/a1378c/",headers:[{level:2,title:"7.1 and和or指令",slug:"_7-1-and和or指令",normalizedTitle:"7.1 and 和 or 指令",charIndex:39},{level:2,title:"7.2 关于ASCII码",slug:"_7-2-关于ascii码",normalizedTitle:"7.2 关于 ascii 码",charIndex:80},{level:2,title:"7.3 以字符形式给出的数据",slug:"_7-3-以字符形式给出的数据",normalizedTitle:"7.3 以字符形式给出的数据",charIndex:417},{level:2,title:"7.4 大小写转换的问题",slug:"_7-4-大小写转换的问题",normalizedTitle:"7.4 大小写转换的问题",charIndex:485},{level:2,title:"7.5 [bx+idata]",slug:"_7-5-bx-idata",normalizedTitle:"7.5 [bx+idata]",charIndex:832},{level:2,title:"7.6 用[bx+idata]的方式进行数组的处理",slug:"_7-6-用-bx-idata-的方式进行数组的处理",normalizedTitle:"7.6 用 [bx+idata] 的方式进行数组的处理",charIndex:1102},{level:2,title:"7.7 SI和DI",slug:"_7-7-si和di",normalizedTitle:"7.7 si 和 di",charIndex:1479},{level:2,title:"7.8 [bx+si]和[bx+di]",slug:"_7-8-bx-si-和-bx-di",normalizedTitle:"7.8 [bx+si] 和 [bx+di]",charIndex:1911},{level:2,title:"7.9 [bx+si+idata]和[bx+di+idata]",slug:"_7-9-bx-si-idata-和-bx-di-idata",normalizedTitle:"7.9 [bx+si+idata] 和 [bx+di+idata]",charIndex:2108},{level:2,title:"7.10 不同的寻址方式的灵活应用",slug:"_7-10-不同的寻址方式的灵活应用",normalizedTitle:"7.10 不同的寻址方式的灵活应用",charIndex:2310}],headersStr:"7.1 and和or指令 7.2 关于ASCII码 7.3 以字符形式给出的数据 7.4 大小写转换的问题 7.5 [bx+idata] 7.6 用[bx+idata]的方式进行数组的处理 7.7 SI和DI 7.8 [bx+si]和[bx+di] 7.9 [bx+si+idata]和[bx+di+idata] 7.10 不同的寻址方式的灵活应用",content:"# 第七章 更灵活的定位内存地址的方法\n\n本章主要讲不同的寻址方式。\n\n\n# 7.1 and 和 or 指令\n\nand 表示逻辑与。or 表示逻辑或。\n\n\n# 7.2 关于 ASCII 码\n\nASCII 码：American Standard Code for Information Interchange，美国信息交换标准代码。用 8 位（一个字节）二进制数表示一个字符。起初定义了 128 个字符，后来扩展至 256 个。\n\n当我们再键盘上按下字母 a 键，屏幕上显示 a 字母，这其中经历了哪些过程？\n\n 1. a 被 ASCII 编码为数字 61H 存储在指定内存空间内。\n 2. 文本编辑器软件从内存中取出 61H, 将其送入显卡显存中。\n 3. 显卡根据 ASCII 编码将 61H 反译为字母 a，同时显卡驱动显示器，将字母 a 的图像画在屏幕上。\n\n通过以上 3 步，我们就看到了字母 a 被显示在屏幕上。\n\n\n# 7.3 以字符形式给出的数据\n\n在汇编程序中，使用引号‘’括起来的内容被识别为字符，编译器将把它转换为对应的 ASCII 码。\n\n\n# 7.4 大小写转换的问题\n\n在 ASCII 码中，小写字母的对应范围为：61H - 7AH。大写字母的对应范围为：41H - 5AH。可见同一个字母的大写形式的 ASCII 码比小写形式的 ASCII 码小 20H。\n\n仔细观察大小写字母所对应的 ASCII 吗二进制形式，可以发现如下规律：大写字母从右数第 6 位（从 1 开始计算）全为 0，小写字母从右数第 6 位全为 1。\n\n综上我们可以总结出大小写转换的两种方式：\n\n字母大小写转换方式 1：\n\n 1. 大写字母加上 20h 可转换为小写字母。\n 2. 小写字母减去 20h 可转换为大写字母。\n\n字母大小写转换方式 2：\n\n 1. 字母转大写：逻辑与 11011111B。\n 2. 字母转小写：逻辑或 00100000B。\n\n\n# 7.5 [bx+idata]\n\n这是一种 \"变量 + 常量\" 的寻址方式。\n\n[bx+idata] 表示一个内存单元，它的偏移地址为 (bx)+idata。\n指令:\n\nmov ax, [bx+200]\n\n\n1\n\n1\n\n\n表示将一个内存单元的内容送入 ax，这个内存单元的长度为 2 个字节（字单元），存放一个字，偏移地址为 bx 中的数值加上 200，段地址在 ds 中。\n\n该指令的常用格式有：\n\nmov ax, [bx+200]\nmov ax, 200[bx]\nmov ax, [bx].200\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 7.6 用 [bx+idata] 的方式进行数组的处理\n\n我们可以将地址连续的多个数据当做数组处理。例如定义如下数据：\n\ndatasg segment\n  db 'BaSiC'\n  db 'MinIX'\ndatasg ends\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n我们可以把如上两个字符串当做两个数组，一个数组下标从 0 开始，一个数组下标从 5 开始。在程序中使用 [bx+0] 和 [bx+5] 的方式定位两个字符串的首地址。从而可以在一个循环当中同时处理两组数据。\n\n回忆我们在高级语言中用到的数组取值方式 (如 c 或 java)：a [index]。可以看出这就是汇编语言中 [bx+idata] 形式的变种。a 与 idata 相对应，是一常量，表示了数组的首地址。而下标 index 与 bx 对应，是一变量，表示数组下标。\n\n\n# 7.7 SI 和 DI\n\nSI 是 Source Index 的缩写。DI 是 Destination Index 的缩写。它俩的功能与 bx 相近，但 SI 和 DI 不能够分成两个 8 位寄存器来使用。下面三组指令实现了相同的功能：\n\n;(1)\nmov bx, 0\nmov ax, [bx]\n\n;(2)\nmov si, 0\nmov ax, [si]\n\n;(3)\nmov di, 0\nmov ax, [di]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n下面的三组指令也实现了相同的功能：\n\n;(1)\nmov bx, 0\nmov ax, [bx+123]\n\n;(2)\nmov si, 0\nmov ax, [si+123]\n\n;(3)\nmov di, 0\nmov ax, [di+123]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 7.8 [bx+si] 和 [bx+di]\n\n这是一种 “变量 + 变量” 的寻址方式。\n\n[bx+si] 和 [bx+di] 含义相似，都是表示一个内存单元。该内存单元的段地址位于 ds 中，偏移地址为 bx 的值加上 si 的值（或 bx 的值加上 di 的值）。\n\n该指令的常用格式有：\n\nmov ax, [bx+si]\nmov ax, [bx][si]\n\n\n1\n2\n\n1\n2\n\n\n\n# 7.9 [bx+si+idata] 和 [bx+di+idata]\n\n这是一种 \"变量 + 变量 + 常量\" 的寻址方式。\n\n常用指令格式：\n\nmov ax, [bx+200+si]\nmov ax, [200+bx+si]\nmov ax, 200[bx][si]\nmov ax, [bx].200[si]\nmov ax, [bx][si].200\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 7.10 不同的寻址方式的灵活应用\n\n总结一下前面讲到的几种定位内存地址的方法（寻址方式）：\n\n（1）[idata] 用一个常量来表示地址，可用于直接定位一个内存单元；\n（2）[bx] 用一个变量来表示内存地址，可用于间接定位一个内存单元；\n（3）[bx+idata] 用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；\n（4）[bx+si] 用两个变量表示地址；\n（5）[bx+si+idata] 用两个变量和一个常量表示地址。\n\n下一章中，我们将对寻址方式的问题进行更深入的探讨，之所以如此重视这个问题，是因为寻址方式的适当应用，使我们可以以更合理的结构来看待所要处理的数据。而为所要处理的看似杂乱的数据设计一种清晰的数据结构是程序设计的一个关键问题（个人认为这段话说的很有道理，特记录于此）\n\n----------------------------------------",normalizedContent:"# 第七章 更灵活的定位内存地址的方法\n\n本章主要讲不同的寻址方式。\n\n\n# 7.1 and 和 or 指令\n\nand 表示逻辑与。or 表示逻辑或。\n\n\n# 7.2 关于 ascii 码\n\nascii 码：american standard code for information interchange，美国信息交换标准代码。用 8 位（一个字节）二进制数表示一个字符。起初定义了 128 个字符，后来扩展至 256 个。\n\n当我们再键盘上按下字母 a 键，屏幕上显示 a 字母，这其中经历了哪些过程？\n\n 1. a 被 ascii 编码为数字 61h 存储在指定内存空间内。\n 2. 文本编辑器软件从内存中取出 61h, 将其送入显卡显存中。\n 3. 显卡根据 ascii 编码将 61h 反译为字母 a，同时显卡驱动显示器，将字母 a 的图像画在屏幕上。\n\n通过以上 3 步，我们就看到了字母 a 被显示在屏幕上。\n\n\n# 7.3 以字符形式给出的数据\n\n在汇编程序中，使用引号‘’括起来的内容被识别为字符，编译器将把它转换为对应的 ascii 码。\n\n\n# 7.4 大小写转换的问题\n\n在 ascii 码中，小写字母的对应范围为：61h - 7ah。大写字母的对应范围为：41h - 5ah。可见同一个字母的大写形式的 ascii 码比小写形式的 ascii 码小 20h。\n\n仔细观察大小写字母所对应的 ascii 吗二进制形式，可以发现如下规律：大写字母从右数第 6 位（从 1 开始计算）全为 0，小写字母从右数第 6 位全为 1。\n\n综上我们可以总结出大小写转换的两种方式：\n\n字母大小写转换方式 1：\n\n 1. 大写字母加上 20h 可转换为小写字母。\n 2. 小写字母减去 20h 可转换为大写字母。\n\n字母大小写转换方式 2：\n\n 1. 字母转大写：逻辑与 11011111b。\n 2. 字母转小写：逻辑或 00100000b。\n\n\n# 7.5 [bx+idata]\n\n这是一种 \"变量 + 常量\" 的寻址方式。\n\n[bx+idata] 表示一个内存单元，它的偏移地址为 (bx)+idata。\n指令:\n\nmov ax, [bx+200]\n\n\n1\n\n1\n\n\n表示将一个内存单元的内容送入 ax，这个内存单元的长度为 2 个字节（字单元），存放一个字，偏移地址为 bx 中的数值加上 200，段地址在 ds 中。\n\n该指令的常用格式有：\n\nmov ax, [bx+200]\nmov ax, 200[bx]\nmov ax, [bx].200\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 7.6 用 [bx+idata] 的方式进行数组的处理\n\n我们可以将地址连续的多个数据当做数组处理。例如定义如下数据：\n\ndatasg segment\n  db 'basic'\n  db 'minix'\ndatasg ends\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n我们可以把如上两个字符串当做两个数组，一个数组下标从 0 开始，一个数组下标从 5 开始。在程序中使用 [bx+0] 和 [bx+5] 的方式定位两个字符串的首地址。从而可以在一个循环当中同时处理两组数据。\n\n回忆我们在高级语言中用到的数组取值方式 (如 c 或 java)：a [index]。可以看出这就是汇编语言中 [bx+idata] 形式的变种。a 与 idata 相对应，是一常量，表示了数组的首地址。而下标 index 与 bx 对应，是一变量，表示数组下标。\n\n\n# 7.7 si 和 di\n\nsi 是 source index 的缩写。di 是 destination index 的缩写。它俩的功能与 bx 相近，但 si 和 di 不能够分成两个 8 位寄存器来使用。下面三组指令实现了相同的功能：\n\n;(1)\nmov bx, 0\nmov ax, [bx]\n\n;(2)\nmov si, 0\nmov ax, [si]\n\n;(3)\nmov di, 0\nmov ax, [di]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n下面的三组指令也实现了相同的功能：\n\n;(1)\nmov bx, 0\nmov ax, [bx+123]\n\n;(2)\nmov si, 0\nmov ax, [si+123]\n\n;(3)\nmov di, 0\nmov ax, [di+123]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 7.8 [bx+si] 和 [bx+di]\n\n这是一种 “变量 + 变量” 的寻址方式。\n\n[bx+si] 和 [bx+di] 含义相似，都是表示一个内存单元。该内存单元的段地址位于 ds 中，偏移地址为 bx 的值加上 si 的值（或 bx 的值加上 di 的值）。\n\n该指令的常用格式有：\n\nmov ax, [bx+si]\nmov ax, [bx][si]\n\n\n1\n2\n\n1\n2\n\n\n\n# 7.9 [bx+si+idata] 和 [bx+di+idata]\n\n这是一种 \"变量 + 变量 + 常量\" 的寻址方式。\n\n常用指令格式：\n\nmov ax, [bx+200+si]\nmov ax, [200+bx+si]\nmov ax, 200[bx][si]\nmov ax, [bx].200[si]\nmov ax, [bx][si].200\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 7.10 不同的寻址方式的灵活应用\n\n总结一下前面讲到的几种定位内存地址的方法（寻址方式）：\n\n（1）[idata] 用一个常量来表示地址，可用于直接定位一个内存单元；\n（2）[bx] 用一个变量来表示内存地址，可用于间接定位一个内存单元；\n（3）[bx+idata] 用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；\n（4）[bx+si] 用两个变量表示地址；\n（5）[bx+si+idata] 用两个变量和一个常量表示地址。\n\n下一章中，我们将对寻址方式的问题进行更深入的探讨，之所以如此重视这个问题，是因为寻址方式的适当应用，使我们可以以更合理的结构来看待所要处理的数据。而为所要处理的看似杂乱的数据设计一种清晰的数据结构是程序设计的一个关键问题（个人认为这段话说的很有道理，特记录于此）\n\n----------------------------------------",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"第八章 数据处理的两个基本问题",frontmatter:{title:null,date:"2023-01-05T02:55:07.000Z",permalink:"/pages/02c62b/"},regularPath:"/02.%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/02.%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/09.%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98.html",relativePath:"02.汇编语言/02.《汇编语言》第三版阅读笔记/09.第八章 数据处理的两个基本问题.md",key:"v-47390ea0",path:"/pages/02c62b/",headers:[{level:2,title:"8.1 bx、si、di和bp",slug:"_8-1-bx、si、di和bp",normalizedTitle:"8.1 bx、si、di 和 bp",charIndex:133},{level:2,title:"8.2 机器指令处理的数据在什么地方",slug:"_8-2-机器指令处理的数据在什么地方",normalizedTitle:"8.2 机器指令处理的数据在什么地方",charIndex:735},{level:2,title:"8.3 汇编语言中数据位置的表达",slug:"_8-3-汇编语言中数据位置的表达",normalizedTitle:"8.3 汇编语言中数据位置的表达",charIndex:880},{level:2,title:"8.4 寻址方式",slug:"_8-4-寻址方式",normalizedTitle:"8.4 寻址方式",charIndex:1541},{level:2,title:"8.5 指令要处理的数据有多长",slug:"_8-5-指令要处理的数据有多长",normalizedTitle:"8.5 指令要处理的数据有多长",charIndex:2513},{level:2,title:"8.6 寻址方式的综合应用",slug:"_8-6-寻址方式的综合应用",normalizedTitle:"8.6 寻址方式的综合应用",charIndex:3107},{level:2,title:"8.7 div指令",slug:"_8-7-div指令",normalizedTitle:"8.7 div 指令",charIndex:3406},{level:2,title:"8.8 伪指令dd",slug:"_8-8-伪指令dd",normalizedTitle:"8.8 伪指令 dd",charIndex:3730},{level:2,title:"8.9 dup",slug:"_8-9-dup",normalizedTitle:"8.9 dup",charIndex:3768}],headersStr:"8.1 bx、si、di和bp 8.2 机器指令处理的数据在什么地方 8.3 汇编语言中数据位置的表达 8.4 寻址方式 8.5 指令要处理的数据有多长 8.6 寻址方式的综合应用 8.7 div指令 8.8 伪指令dd 8.9 dup",content:"# 第八章 数据处理的两个基本问题\n\n本章旨在进一步加强对不同寻址方式的理解及运用。\n\n计算机是进行数据处理、运算的机器，这其中包含两个基本的问题：\n\n（1）处理的数据在什么地方？\n（2）要处理的数据有多长？\n\n携带着这两个问题，我们开启第八章的学习之路。\n\n\n# 8.1 bx、si、di 和 bp\n\n首先看下这四个寄存器的含义：\n\nbx, Base,Pointer to base addresss (data)。一般用于存储数据段的基址（首地址）。\nsi，Source Index，Source string/index pointer。一般用于存储源数组数据索引（下标）。\ndi，Destination Index，estination string/index pointer。一般用于存储目标数组数据索引（下标）。\nbp，Base Pointer，Pointer to base address (stack)。一般用于存储栈的基址。\n\n然后在使用过程中有几处需要注意的地方：\n\n（1）在 8086CPU 中，只有这 4 个寄存器可以用在 “[....]” 中来进行内存单元的寻址。其他寄存器是不可以的，例如 “mov bx, [ax]” 就是错误的用法。\n\n（2）在 [...] 中，这四个寄存器可以单个出现，或只能以 4 种组合出现：bx 和 si、bx 和 di、bp 和 si、bp 和 di。为了方便记忆可以将 si 和 di 看做一组，将 bx 和 bp 看做一组。组间可以自由组合，组内不能组合。（脑补为人类不可以近亲繁殖。）\n\n（3）只要在 [...] 中使用寄存器 bp，而指令中没有显性的给出段地址，则段地址就默认在 ss 中。\n\n\n# 8.2 机器指令处理的数据在什么地方\n\n这是我们在开头抛出的两个问题中的第一个。\n\n在指令执行前，所要处理的数据可以在 3 个地方：CPU 内部、内存、端口（端口暂时不用知道是什么东西）。\n\n我们知道了存储数据的部件，但如果具体找到这些部件存储的数据位置？下一节将解答我们的疑问。\n\n\n# 8.3 汇编语言中数据位置的表达\n\n在汇编语言中如何表达数据的位置？\n\n汇编语言中用 3 个概念来表达数据的位置。\n\n（1）立即数\n\n对于直接包含在机器指令中的数据（执行前在 CPU 的指令缓冲器中），汇编语言中称为立即数（idata）, 在汇编指令中直接给出。 例如：\n\nmov ax, 1\nor bx, 00100000B\n\n\n1\n2\n\n1\n2\n\n\n（2）寄存器\n\n指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。例如：\n\nmov ax, bx\npush bx\n\n\n1\n2\n\n1\n2\n\n\n（3）段地址（SA）和偏移地址（EA）\n\n指令要处理的数据在内存中，在汇编语言中可以用 [X] 的格式给出 EA，SA 在某个段寄存器中。\n\n存放段地址的寄存器可以是默认的，也可以显性给出。例如：\n\n;段寄存器默认存储在DS中\n mov  ax, [0]\n mov ax, [bx]\n mov ax, [di]\n ...\n\n ;段寄存器默认存储在SS中\n mov ax, [bp]\n mov ax, [bp+si]\n mov ax, [bp+di]\n ...\n\n ;段寄存器显性给出\n mov ax, ds:[bp]\n mov ax, es:[3]\n mov ax, ss:[bx+si]\n mov ax, cs:[bx+si+8]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 8.4 寻址方式\n\n这一节我们总结一下所学到过的寻址方式。列表如下：\n\n寻址方式            含义                    名称         常用格式举例                            备注\n[idata]         EA=idata;             直接寻址       [idata]                           偏移地址 = 立即数\n                SA=(ds)\n[bx]            EA=(bx);              寄存器间接寻址    [bx]                              偏移地址 = 变量\n                SA=(ds)\n[bx+idata]      EA=(bx)+idata;        寄存器相对寻址    用于结构体： [bx].idata ;               偏移地址 = 变量 + 立即数\n                SA=(ds)                          用于数组： idata[si] , idata[di] ;\n                                                 用于二维数组： [bx][idata]\n[bx+si]         EA=(bx)+(si);         基址变址寻址     用于二维数组： [bx][si]                  偏移地址 = 变量 + 变量\n                SA=(ds)\n[bx+si+idata]   EA=(bx)+(si)+idata;   相对基址变址寻址   用于表格（结构）中的数组项： [bx].idata[si] ;   偏移地址 = 变量 + 变量 + 立即数\n                SA=(ds)                          用于二维数组： idata[bx][si]\n\n注意在 8.1 节指出的特殊情况，只要在 [...] 中使用寄存器 bp，而指令中没有显性的给出段地址，段地址就默认在 ss 中。\n\n\n# 8.5 指令要处理的数据有多长\n\n这是我们在开头抛出的两个问题中的第二个。\n\n8086CPU 的指令，可以处理两种尺寸的数据，byte 和 word。所以在机器指令中要指明，指令进行的是字操作还是字节操作。对于这个问题，汇编语言中用以下方法处理。\n\n（1）通过寄存器名指定要处理的数据的尺寸。如果寄存器名是字型寄存器（如 ax、bx 等），则说明指令进行的是字操作。如果寄存器名是字节型寄存器（如 al、ah、bl 等），则说明指令进行的是字节操作。\n\n（2）在没有寄存器名存在的情况下，用操作符 X ptr 指明内存单元的长度，X 在汇编指令中可以为 word 或 byte。这种情形适用于没有寄存器参与的内存单元访问指令中。例如：\n\n;下面的指令，用word ptr指明了指令中访问的内存单元是一个字单元\nmov word ptr ds:[0], 1\ninc word ptr [bx]\n\n;下面的指令，用byte ptr指明了指令访问的内存单元是一个字节单元\nmov byte ptr ds:[0], 1\ninc byte ptr [bx]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n（3）其他方法。有些指令默认了访问的是字单元还是字节单元，比如，push [1000H] 就不用指明访问的是字单元还是字节单元，因为 push 指令只会进行字操作。\n\n\n# 8.6 寻址方式的综合应用\n\n8086CPU 提供的如 [bx+si+idata] 的寻址方式为结构化数据的处理提供了方便。使得我们可以在编程的时候，从结构化的角度去看待所要处理的数据。正常情况下，一个结构化的数据包含了多个数据项，而数据项的类型又不相同，有的是字型数据，有的是字节型数据，有的是数组（字符串）。一般来说，我们可以用 [bx+idata+si] 的方式来访问结构体中的数据。用 bx 定位整个结构体，用 idata 定位结构体中的某一个数据项，用 si 定位数组项中的元素。为此，汇编语言提供了更为贴切的书写方式，如 [bx].idata、[bx].idata [si]。\n\n\n# 8.7 div 指令\n\ndiv 是除法指令。在使用的过程中应注意以下问题：\n\n（1）除数：有 8 位和 16 位两种，在一个 reg (寄存器) 或内存单元中。\n\n（2）被除数：默认放在 AX 或 DX 和 AX 中，如果除数为 8 位，被除数则为 16 位，默认在 AX 中存放；如果除数为 16 位，被除数则为 32 位，在 DX 和 AX 中存放，DX 存放高 16 位，AX 存放低 16 位。\n\n（3）结果：如果除数为 8 位，则 AL 存储除法操作的商，AH 存储除法操作的余数；如果除数为 16 位，则 AX 存储除法操作的商，DX 存储除法操作的余数。\n\ndiv 使用格式如下：\n\n> div reg\n> div 内存单元\n\n\n# 8.8 伪指令 dd\n\ndd 用来定义 dword（双字）型数据。\n\n\n# 8.9 dup\n\ndup (duplication 的缩写) 用来重复开辟内存空间。\n\ndup 指令要和 db、dw、dd 等数据定义伪指令配合使用，使用格式如下：\n\n> db 重复次数 dup (重复的字节型数据) dw 重复次数 dup (重复的字型数据) dd 重复次数 dup (重复的双字型数据)\n\n例如，如下代码表示定义了 9 个字节：\n\ndb 3 dup (0,1,2)\n\n\n1\n\n1\n\n\n----------------------------------------",normalizedContent:"# 第八章 数据处理的两个基本问题\n\n本章旨在进一步加强对不同寻址方式的理解及运用。\n\n计算机是进行数据处理、运算的机器，这其中包含两个基本的问题：\n\n（1）处理的数据在什么地方？\n（2）要处理的数据有多长？\n\n携带着这两个问题，我们开启第八章的学习之路。\n\n\n# 8.1 bx、si、di 和 bp\n\n首先看下这四个寄存器的含义：\n\nbx, base,pointer to base addresss (data)。一般用于存储数据段的基址（首地址）。\nsi，source index，source string/index pointer。一般用于存储源数组数据索引（下标）。\ndi，destination index，estination string/index pointer。一般用于存储目标数组数据索引（下标）。\nbp，base pointer，pointer to base address (stack)。一般用于存储栈的基址。\n\n然后在使用过程中有几处需要注意的地方：\n\n（1）在 8086cpu 中，只有这 4 个寄存器可以用在 “[....]” 中来进行内存单元的寻址。其他寄存器是不可以的，例如 “mov bx, [ax]” 就是错误的用法。\n\n（2）在 [...] 中，这四个寄存器可以单个出现，或只能以 4 种组合出现：bx 和 si、bx 和 di、bp 和 si、bp 和 di。为了方便记忆可以将 si 和 di 看做一组，将 bx 和 bp 看做一组。组间可以自由组合，组内不能组合。（脑补为人类不可以近亲繁殖。）\n\n（3）只要在 [...] 中使用寄存器 bp，而指令中没有显性的给出段地址，则段地址就默认在 ss 中。\n\n\n# 8.2 机器指令处理的数据在什么地方\n\n这是我们在开头抛出的两个问题中的第一个。\n\n在指令执行前，所要处理的数据可以在 3 个地方：cpu 内部、内存、端口（端口暂时不用知道是什么东西）。\n\n我们知道了存储数据的部件，但如果具体找到这些部件存储的数据位置？下一节将解答我们的疑问。\n\n\n# 8.3 汇编语言中数据位置的表达\n\n在汇编语言中如何表达数据的位置？\n\n汇编语言中用 3 个概念来表达数据的位置。\n\n（1）立即数\n\n对于直接包含在机器指令中的数据（执行前在 cpu 的指令缓冲器中），汇编语言中称为立即数（idata）, 在汇编指令中直接给出。 例如：\n\nmov ax, 1\nor bx, 00100000b\n\n\n1\n2\n\n1\n2\n\n\n（2）寄存器\n\n指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。例如：\n\nmov ax, bx\npush bx\n\n\n1\n2\n\n1\n2\n\n\n（3）段地址（sa）和偏移地址（ea）\n\n指令要处理的数据在内存中，在汇编语言中可以用 [x] 的格式给出 ea，sa 在某个段寄存器中。\n\n存放段地址的寄存器可以是默认的，也可以显性给出。例如：\n\n;段寄存器默认存储在ds中\n mov  ax, [0]\n mov ax, [bx]\n mov ax, [di]\n ...\n\n ;段寄存器默认存储在ss中\n mov ax, [bp]\n mov ax, [bp+si]\n mov ax, [bp+di]\n ...\n\n ;段寄存器显性给出\n mov ax, ds:[bp]\n mov ax, es:[3]\n mov ax, ss:[bx+si]\n mov ax, cs:[bx+si+8]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 8.4 寻址方式\n\n这一节我们总结一下所学到过的寻址方式。列表如下：\n\n寻址方式            含义                    名称         常用格式举例                            备注\n[idata]         ea=idata;             直接寻址       [idata]                           偏移地址 = 立即数\n                sa=(ds)\n[bx]            ea=(bx);              寄存器间接寻址    [bx]                              偏移地址 = 变量\n                sa=(ds)\n[bx+idata]      ea=(bx)+idata;        寄存器相对寻址    用于结构体： [bx].idata ;               偏移地址 = 变量 + 立即数\n                sa=(ds)                          用于数组： idata[si] , idata[di] ;\n                                                 用于二维数组： [bx][idata]\n[bx+si]         ea=(bx)+(si);         基址变址寻址     用于二维数组： [bx][si]                  偏移地址 = 变量 + 变量\n                sa=(ds)\n[bx+si+idata]   ea=(bx)+(si)+idata;   相对基址变址寻址   用于表格（结构）中的数组项： [bx].idata[si] ;   偏移地址 = 变量 + 变量 + 立即数\n                sa=(ds)                          用于二维数组： idata[bx][si]\n\n注意在 8.1 节指出的特殊情况，只要在 [...] 中使用寄存器 bp，而指令中没有显性的给出段地址，段地址就默认在 ss 中。\n\n\n# 8.5 指令要处理的数据有多长\n\n这是我们在开头抛出的两个问题中的第二个。\n\n8086cpu 的指令，可以处理两种尺寸的数据，byte 和 word。所以在机器指令中要指明，指令进行的是字操作还是字节操作。对于这个问题，汇编语言中用以下方法处理。\n\n（1）通过寄存器名指定要处理的数据的尺寸。如果寄存器名是字型寄存器（如 ax、bx 等），则说明指令进行的是字操作。如果寄存器名是字节型寄存器（如 al、ah、bl 等），则说明指令进行的是字节操作。\n\n（2）在没有寄存器名存在的情况下，用操作符 x ptr 指明内存单元的长度，x 在汇编指令中可以为 word 或 byte。这种情形适用于没有寄存器参与的内存单元访问指令中。例如：\n\n;下面的指令，用word ptr指明了指令中访问的内存单元是一个字单元\nmov word ptr ds:[0], 1\ninc word ptr [bx]\n\n;下面的指令，用byte ptr指明了指令访问的内存单元是一个字节单元\nmov byte ptr ds:[0], 1\ninc byte ptr [bx]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n（3）其他方法。有些指令默认了访问的是字单元还是字节单元，比如，push [1000h] 就不用指明访问的是字单元还是字节单元，因为 push 指令只会进行字操作。\n\n\n# 8.6 寻址方式的综合应用\n\n8086cpu 提供的如 [bx+si+idata] 的寻址方式为结构化数据的处理提供了方便。使得我们可以在编程的时候，从结构化的角度去看待所要处理的数据。正常情况下，一个结构化的数据包含了多个数据项，而数据项的类型又不相同，有的是字型数据，有的是字节型数据，有的是数组（字符串）。一般来说，我们可以用 [bx+idata+si] 的方式来访问结构体中的数据。用 bx 定位整个结构体，用 idata 定位结构体中的某一个数据项，用 si 定位数组项中的元素。为此，汇编语言提供了更为贴切的书写方式，如 [bx].idata、[bx].idata [si]。\n\n\n# 8.7 div 指令\n\ndiv 是除法指令。在使用的过程中应注意以下问题：\n\n（1）除数：有 8 位和 16 位两种，在一个 reg (寄存器) 或内存单元中。\n\n（2）被除数：默认放在 ax 或 dx 和 ax 中，如果除数为 8 位，被除数则为 16 位，默认在 ax 中存放；如果除数为 16 位，被除数则为 32 位，在 dx 和 ax 中存放，dx 存放高 16 位，ax 存放低 16 位。\n\n（3）结果：如果除数为 8 位，则 al 存储除法操作的商，ah 存储除法操作的余数；如果除数为 16 位，则 ax 存储除法操作的商，dx 存储除法操作的余数。\n\ndiv 使用格式如下：\n\n> div reg\n> div 内存单元\n\n\n# 8.8 伪指令 dd\n\ndd 用来定义 dword（双字）型数据。\n\n\n# 8.9 dup\n\ndup (duplication 的缩写) 用来重复开辟内存空间。\n\ndup 指令要和 db、dw、dd 等数据定义伪指令配合使用，使用格式如下：\n\n> db 重复次数 dup (重复的字节型数据) dw 重复次数 dup (重复的字型数据) dd 重复次数 dup (重复的双字型数据)\n\n例如，如下代码表示定义了 9 个字节：\n\ndb 3 dup (0,1,2)\n\n\n1\n\n1\n\n\n----------------------------------------",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"第九章 转移指令的原理",frontmatter:{title:null,date:"2023-01-05T02:55:07.000Z",permalink:"/pages/83284e/"},regularPath:"/02.%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/02.%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/10.%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86.html",relativePath:"02.汇编语言/02.《汇编语言》第三版阅读笔记/10.第九章 转移指令的原理.md",key:"v-139c8f69",path:"/pages/83284e/",headers:[{level:2,title:"9.1 操作符 offset",slug:"_9-1-操作符-offset",normalizedTitle:"9.1 操作符 offset",charIndex:410},{level:2,title:"9.2 jmp 指令",slug:"_9-2-jmp-指令",normalizedTitle:"9.2 jmp 指令",charIndex:474},{level:2,title:"9.3 依据位移进行转移的jmp指令",slug:"_9-3-依据位移进行转移的jmp指令",normalizedTitle:"9.3 依据位移进行转移的 jmp 指令",charIndex:607},{level:2,title:"9.4 转移的目的地址在指令中的jmp指令",slug:"_9-4-转移的目的地址在指令中的jmp指令",normalizedTitle:"9.4 转移的目的地址在指令中的 jmp 指令",charIndex:989},{level:2,title:"9.5 转移地址在寄存器中的jmp指令",slug:"_9-5-转移地址在寄存器中的jmp指令",normalizedTitle:"9.5 转移地址在寄存器中的 jmp 指令",charIndex:1186},{level:2,title:"9.6 转移地址在内存中的jmp指令",slug:"_9-6-转移地址在内存中的jmp指令",normalizedTitle:"9.6 转移地址在内存中的 jmp 指令",charIndex:1258},{level:2,title:"9.7 jcxz 指令",slug:"_9-7-jcxz-指令",normalizedTitle:"9.7 jcxz 指令",charIndex:1453},{level:2,title:"9.8 loop指令",slug:"_9-8-loop指令",normalizedTitle:"9.8 loop 指令",charIndex:1604},{level:2,title:"9.9 根据位移进行转移的意义",slug:"_9-9-根据位移进行转移的意义",normalizedTitle:"9.9 根据位移进行转移的意义",charIndex:1668},{level:2,title:"9.10 编译器对转移位移超界的检测",slug:"_9-10-编译器对转移位移超界的检测",normalizedTitle:"9.10 编译器对转移位移超界的检测",charIndex:1706}],headersStr:"9.1 操作符 offset 9.2 jmp 指令 9.3 依据位移进行转移的jmp指令 9.4 转移的目的地址在指令中的jmp指令 9.5 转移地址在寄存器中的jmp指令 9.6 转移地址在内存中的jmp指令 9.7 jcxz 指令 9.8 loop指令 9.9 根据位移进行转移的意义 9.10 编译器对转移位移超界的检测",content:"# 第九章 转移指令的原理\n\n本章主要讲如何控制 CPU 执行指令的顺序。\n\n可以修改 IP，或同时修改 CS 和 IP 的指令统称为转移指令。概括的降，转移指令就是可以控制 CPU 执行内存中某处代码的指令。\n\n8086CPU 的转移指令有以下几类。\n\n * 只修改 IP 时，称为段内转移，比如：jum ax。\n * 同时修改 CS 和 IP 时，称为段间转移，比如：jmp 1000:0。\n\n由于转移指令对 IP 的修改范围不同，段内转移又分为：短转移和近转移。\n\n * 短转移 IP 的修改范围为 - 128~127。\n * 近转移 IP 的修改范围为 - 32768~32767。\n\n8086CPU 的转移指令分为以下几类。\n\n * 无条件转移指令（如 jmp）\n * 条件转移指令\n * 循环指令（如 loop）\n * 过程\n * 中断\n\n这些转移指令的前提条件可能不同，但转移的基本原理是相同的。\n\n\n# 9.1 操作符 offset\n\n操作符 offset 在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。\n\n\n# 9.2 jmp 指令\n\njmp 为无条件转移指令，可以只修改 IP，也可以同时修改 CS 和 IP。\n\njmp 指令要给出两种信息：\n\n（1）转移的目的地址\n（2）转移的距离（段间转移、段内短转移、段内近转移）\n\n下面几节将对 jmp 指令进行详细的介绍。\n\n\n# 9.3 依据位移进行转移的 jmp 指令\n\n> jmp short 标号\n\n实现的是段内短转移，执行后： （IP） = （IP）+ 8 位位移。\n\n（1）8 位位移 = 标号处的地址 - jmp 指令后第一个字节的地址；\n（2）short 指明此处的位移为 8 位位移；\n（3）8 位位移的范围为 - 128~127，用补码表示；\n（4）8 位位移由编译程序在编译时算出。\n\n> jmp near ptr 标号\n\n实现的是段内近转移，执行后：（IP） = （IP） + 16 位位移。\n\n（1）16 位位移 = 标号处的地址 - jmp 指令后第一个字节的地址；\n（2）near ptr 指明此处的位移为 16 位位移，进行的是段内近转移； （3）16 位位移的范围为 - 32768~32767，用补码表示；\n（4）16 位位移由编译程序在编译时算出。\n\n\n# 9.4 转移的目的地址在指令中的 jmp 指令\n\n> jmp far ptr 标号\n\n实现的是段间转移，又称为远转移。功能如下：\n（CS）= 标号所在段的段地址；（IP）= 标号所在段中的偏移地址。\n\nfar ptr 指明了指令用标号的段地址和偏移地址修改 CS 和 IP。\n\n该指令与上节学习的段内转移明显不同的是：\n段内转移机器指令携带的是位移，段间转移机器指令携带的是目的地址。\n\n\n# 9.5 转移地址在寄存器中的 jmp 指令\n\n> jmp 16 位的 reg\n\n该指令实现的功能为：（IP）= （16 位的 reg）\n\n\n# 9.6 转移地址在内存中的 jmp 指令\n\n> jmp word ptr 内存单元地址（段内转移）\n\n功能：从内存单元地址处开始存放一个字，是转移的目的偏移地址。\n\n内存单元地址可以用之前学过的任一寻址方式给出。\n\n> jmp dword ptr 内存单元地址（段间转移）\n\n功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的的偏移地址。\n\n\n# 9.7 jcxz 指令\n\n> jcxz 标号\n\n功能：如果（cx）=0，则转移到标号处执行。如果（cx）≠ 0，则程序继续向下执行。\n\njcxz 指令为有条件转递指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对 IP 的修改范围都为：-128~127。\n\n\n# 9.8 loop 指令\n\n> loop 标号\n\n功能：（cx）=（cx）-1，如果（cx）≠ 0，则转移到标号处执行。\n\n\n# 9.9 根据位移进行转移的意义\n\n方便了程序段在内存中的浮动装配。\n\n\n# 9.10 编译器对转移位移超界的检测\n\n根据位移进行转移的指令，它们的转移范围受到转移位移的限制，如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错。\n\n----------------------------------------",normalizedContent:"# 第九章 转移指令的原理\n\n本章主要讲如何控制 cpu 执行指令的顺序。\n\n可以修改 ip，或同时修改 cs 和 ip 的指令统称为转移指令。概括的降，转移指令就是可以控制 cpu 执行内存中某处代码的指令。\n\n8086cpu 的转移指令有以下几类。\n\n * 只修改 ip 时，称为段内转移，比如：jum ax。\n * 同时修改 cs 和 ip 时，称为段间转移，比如：jmp 1000:0。\n\n由于转移指令对 ip 的修改范围不同，段内转移又分为：短转移和近转移。\n\n * 短转移 ip 的修改范围为 - 128~127。\n * 近转移 ip 的修改范围为 - 32768~32767。\n\n8086cpu 的转移指令分为以下几类。\n\n * 无条件转移指令（如 jmp）\n * 条件转移指令\n * 循环指令（如 loop）\n * 过程\n * 中断\n\n这些转移指令的前提条件可能不同，但转移的基本原理是相同的。\n\n\n# 9.1 操作符 offset\n\n操作符 offset 在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。\n\n\n# 9.2 jmp 指令\n\njmp 为无条件转移指令，可以只修改 ip，也可以同时修改 cs 和 ip。\n\njmp 指令要给出两种信息：\n\n（1）转移的目的地址\n（2）转移的距离（段间转移、段内短转移、段内近转移）\n\n下面几节将对 jmp 指令进行详细的介绍。\n\n\n# 9.3 依据位移进行转移的 jmp 指令\n\n> jmp short 标号\n\n实现的是段内短转移，执行后： （ip） = （ip）+ 8 位位移。\n\n（1）8 位位移 = 标号处的地址 - jmp 指令后第一个字节的地址；\n（2）short 指明此处的位移为 8 位位移；\n（3）8 位位移的范围为 - 128~127，用补码表示；\n（4）8 位位移由编译程序在编译时算出。\n\n> jmp near ptr 标号\n\n实现的是段内近转移，执行后：（ip） = （ip） + 16 位位移。\n\n（1）16 位位移 = 标号处的地址 - jmp 指令后第一个字节的地址；\n（2）near ptr 指明此处的位移为 16 位位移，进行的是段内近转移； （3）16 位位移的范围为 - 32768~32767，用补码表示；\n（4）16 位位移由编译程序在编译时算出。\n\n\n# 9.4 转移的目的地址在指令中的 jmp 指令\n\n> jmp far ptr 标号\n\n实现的是段间转移，又称为远转移。功能如下：\n（cs）= 标号所在段的段地址；（ip）= 标号所在段中的偏移地址。\n\nfar ptr 指明了指令用标号的段地址和偏移地址修改 cs 和 ip。\n\n该指令与上节学习的段内转移明显不同的是：\n段内转移机器指令携带的是位移，段间转移机器指令携带的是目的地址。\n\n\n# 9.5 转移地址在寄存器中的 jmp 指令\n\n> jmp 16 位的 reg\n\n该指令实现的功能为：（ip）= （16 位的 reg）\n\n\n# 9.6 转移地址在内存中的 jmp 指令\n\n> jmp word ptr 内存单元地址（段内转移）\n\n功能：从内存单元地址处开始存放一个字，是转移的目的偏移地址。\n\n内存单元地址可以用之前学过的任一寻址方式给出。\n\n> jmp dword ptr 内存单元地址（段间转移）\n\n功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的的偏移地址。\n\n\n# 9.7 jcxz 指令\n\n> jcxz 标号\n\n功能：如果（cx）=0，则转移到标号处执行。如果（cx）= 0，则程序继续向下执行。\n\njcxz 指令为有条件转递指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对 ip 的修改范围都为：-128~127。\n\n\n# 9.8 loop 指令\n\n> loop 标号\n\n功能：（cx）=（cx）-1，如果（cx）= 0，则转移到标号处执行。\n\n\n# 9.9 根据位移进行转移的意义\n\n方便了程序段在内存中的浮动装配。\n\n\n# 9.10 编译器对转移位移超界的检测\n\n根据位移进行转移的指令，它们的转移范围受到转移位移的限制，如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错。\n\n----------------------------------------",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"第十章 CALL和RET指令",frontmatter:{title:null,date:"2023-01-05T02:55:07.000Z",permalink:"/pages/a0c561/"},regularPath:"/02.%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/02.%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/11.%E7%AC%AC%E5%8D%81%E7%AB%A0%20CALL%E5%92%8CRET%E6%8C%87%E4%BB%A4.html",relativePath:"02.汇编语言/02.《汇编语言》第三版阅读笔记/11.第十章 CALL和RET指令.md",key:"v-8268a1fe",path:"/pages/a0c561/",headers:[{level:2,title:"10.1 ret 和 retf",slug:"_10-1-ret-和-retf",normalizedTitle:"10.1 ret 和 retf",charIndex:87},{level:2,title:"10.2 call 指令",slug:"_10-2-call-指令",normalizedTitle:"10.2 call 指令",charIndex:448},{level:2,title:"10.3 依据位移进行转移的call指令",slug:"_10-3-依据位移进行转移的call指令",normalizedTitle:"10.3 依据位移进行转移的 call 指令",charIndex:613},{level:2,title:"10.4 转移的目的地址在指令中的call指令",slug:"_10-4-转移的目的地址在指令中的call指令",normalizedTitle:"10.4 转移的目的地址在指令中的 call 指令",charIndex:703},{level:2,title:"10.5 转移地址在寄存器中的call指令",slug:"_10-5-转移地址在寄存器中的call指令",normalizedTitle:"10.5 转移地址在寄存器中的 call 指令",charIndex:858},{level:2,title:"10.6 转移地址在内存中的call指令",slug:"_10-6-转移地址在内存中的call指令",normalizedTitle:"10.6 转移地址在内存中的 call 指令",charIndex:952},{level:2,title:"10.7 call和ret的配合使用",slug:"_10-7-call和ret的配合使用",normalizedTitle:"10.7 call 和 ret 的配合使用",charIndex:1186},{level:2,title:"10.8 mul指令",slug:"_10-8-mul指令",normalizedTitle:"10.8 mul 指令",charIndex:1352},{level:2,title:"10.9 模块化程序设计",slug:"_10-9-模块化程序设计",normalizedTitle:"10.9 模块化程序设计",charIndex:1560},{level:2,title:"10.10 参数和结果传递的问题",slug:"_10-10-参数和结果传递的问题",normalizedTitle:"10.10 参数和结果传递的问题",charIndex:1681},{level:2,title:"10.11 寄存器冲突的问题",slug:"_10-11-寄存器冲突的问题",normalizedTitle:"10.11 寄存器冲突的问题",charIndex:1833}],headersStr:"10.1 ret 和 retf 10.2 call 指令 10.3 依据位移进行转移的call指令 10.4 转移的目的地址在指令中的call指令 10.5 转移地址在寄存器中的call指令 10.6 转移地址在内存中的call指令 10.7 call和ret的配合使用 10.8 mul指令 10.9 模块化程序设计 10.10 参数和结果传递的问题 10.11 寄存器冲突的问题",content:"# 第十章 CALL 和 RET 指令\n\n> call 和 ret 都是转移指令，它们都修改 IP，或同时修改 CS 和 IP。它们经常被共同用来实现子程序的设计。\n\n\n# 10.1 ret 和 retf\n\n这个两个指令可以理解为高级语言中的 return 关键字，表示程序返回。\n\nret 用栈中的数据，修改 IP 的内容，从而实现近转移；\nretf 指令用栈中的数据，修改 CS 和 IP 的内容，从而实现远转移。\n\nCPU 执行 ret 指令时，进行下面两步操作：\n\n（1）(IP) = ((SS)*16+(SP))\n（2）(sp) = (sp)+2\n\n以上步骤相当于进行：\n\n> pop IP\n\nCPU 执行 retf 指令时，进行下面 4 步操作：\n\n（1）(IP) = ((SS)*16+(SP))\n（2）(sp) = (sp)+2\n（3）(CS) = ((SS)*16+(SP))\n（4）(sp) = (sp)+2\n\n以上步骤相当于进行：\n\n> pop IP pop CS\n\n\n# 10.2 call 指令\n\ncall 指令可以理解为高级语言中的方法（函数）调用功能。\n\nCPU 指令 call 指令时，进行两步操作：\n\n（1）将当前的 IP 或 CS 和 IP 压入栈中。 （保存现场） （2）转移。\n\ncall 指令不能实现短转移，除此之外，call 指令实现转移的方法和 jmp 指令的原理相同。\n\n\n# 10.3 依据位移进行转移的 call 指令\n\n指令格式：\n\n> call 标号\n\nCPU 执行该指令时相当于进行：\n\n> push IP jmp near ptr 标号\n\n\n# 10.4 转移的目的地址在指令中的 call 指令\n\n指令格式：\n\n> call far ptr 标号\n\nCPU 执行该指令时相当于进行：\n\n> push CS push IP jmp far ptr 标号\n\n该指令编译的机器指令中包含了转移的目的地址。包括段地址 CS 的值及偏移地址 IP 的值。\n\n\n# 10.5 转移地址在寄存器中的 call 指令\n\n指令格式：\n\n> call 16 位 reg\n\nCPU 执行该指令时相当于进行：\n\n> push IP jmp 16 位 reg\n\n\n# 10.6 转移地址在内存中的 call 指令\n\n转移地址在内存中的 call 指令有两种格式。\n\n（1）第一种指令格式：\n\n> call word ptr 内存单元地址\n\nCPU 执行该指令时相当于进行：\n\n> push IP jmp word ptr 内存单元地址\n\n（2）第二种指令格式:\n\n> call dword ptr 内存单元地址\n\nCPU 执行该指令时相当于进行：\n\n> push CS push IP jmp dword ptr 内存单元地址\n\n\n# 10.7 call 和 ret 的配合使用\n\ncall 和 ret 的配合使用可以用来实现子程序的机制。call 指令在转去执行子程序之前，会将当前指令下一条指令的位置保持在栈中，当子程序执行 ret 或 retf 指令后，会用栈中的数据设置 ip 或 cs 和 ip 的值，从而转到 call 指令后面的代码处继续执行。\n\n\n# 10.8 mul 指令\n\n（1）两个相乘的数：练歌相乘的数，要么都是 8 位，要么都是 16 位。如果是 8 位，一个默认放在 AL 中，另一个放在 8 位 reg 或内存字节单元中；如果是 16 位，一个默认放在 AX 中，另一个放在 16 位 reg 或内存字单元中。\n\n（2）结果：如果是 8 位乘法，结果默认放在 AX 中；如果是 16 位乘法，结果高位默认在 DX 中存放，低位在 AX 中存放。\n\n\n# 10.9 模块化程序设计\n\n> 现实问题比较复杂，对现实问题进行分析时，把它转化为相互联系、不同层次的子问题，是必须的解决方法。\n\n在高级语言中的函数或者方法就是这种思想的体现。在汇编语言中我们将高级语言中的方法或函数称之为子程序。\n\n\n# 10.10 参数和结果传递的问题\n\n当我们设计子程序时面临两个问题：\n\n（1）参数存放的位置？\n（2）计算结果存放的位置？\n\n实际上，我们可以将参数及结果存放于任何可以存储数据的地方。一般情况下，我们可以将参数存储在寄存器中，也可以存储在普通内存单元中。更一般的做法我们将其存储在栈中进行传递。\n\n\n# 10.11 寄存器冲突的问题\n\n寄存器数量是有限的，子程序中使用的寄存器，很可能在主程序中也要使用，造成了寄存器使用上的冲突。解决这个问题的简捷方法是，在子程序的开始将子程序中所有用到的寄存器中的内容都保存起来，在子程序返回前再恢复。 可以用栈来保存寄存器中的内容。\n\n栈是临时保存数据的一个比较理想的数据结构。\n\n----------------------------------------",normalizedContent:"# 第十章 call 和 ret 指令\n\n> call 和 ret 都是转移指令，它们都修改 ip，或同时修改 cs 和 ip。它们经常被共同用来实现子程序的设计。\n\n\n# 10.1 ret 和 retf\n\n这个两个指令可以理解为高级语言中的 return 关键字，表示程序返回。\n\nret 用栈中的数据，修改 ip 的内容，从而实现近转移；\nretf 指令用栈中的数据，修改 cs 和 ip 的内容，从而实现远转移。\n\ncpu 执行 ret 指令时，进行下面两步操作：\n\n（1）(ip) = ((ss)*16+(sp))\n（2）(sp) = (sp)+2\n\n以上步骤相当于进行：\n\n> pop ip\n\ncpu 执行 retf 指令时，进行下面 4 步操作：\n\n（1）(ip) = ((ss)*16+(sp))\n（2）(sp) = (sp)+2\n（3）(cs) = ((ss)*16+(sp))\n（4）(sp) = (sp)+2\n\n以上步骤相当于进行：\n\n> pop ip pop cs\n\n\n# 10.2 call 指令\n\ncall 指令可以理解为高级语言中的方法（函数）调用功能。\n\ncpu 指令 call 指令时，进行两步操作：\n\n（1）将当前的 ip 或 cs 和 ip 压入栈中。 （保存现场） （2）转移。\n\ncall 指令不能实现短转移，除此之外，call 指令实现转移的方法和 jmp 指令的原理相同。\n\n\n# 10.3 依据位移进行转移的 call 指令\n\n指令格式：\n\n> call 标号\n\ncpu 执行该指令时相当于进行：\n\n> push ip jmp near ptr 标号\n\n\n# 10.4 转移的目的地址在指令中的 call 指令\n\n指令格式：\n\n> call far ptr 标号\n\ncpu 执行该指令时相当于进行：\n\n> push cs push ip jmp far ptr 标号\n\n该指令编译的机器指令中包含了转移的目的地址。包括段地址 cs 的值及偏移地址 ip 的值。\n\n\n# 10.5 转移地址在寄存器中的 call 指令\n\n指令格式：\n\n> call 16 位 reg\n\ncpu 执行该指令时相当于进行：\n\n> push ip jmp 16 位 reg\n\n\n# 10.6 转移地址在内存中的 call 指令\n\n转移地址在内存中的 call 指令有两种格式。\n\n（1）第一种指令格式：\n\n> call word ptr 内存单元地址\n\ncpu 执行该指令时相当于进行：\n\n> push ip jmp word ptr 内存单元地址\n\n（2）第二种指令格式:\n\n> call dword ptr 内存单元地址\n\ncpu 执行该指令时相当于进行：\n\n> push cs push ip jmp dword ptr 内存单元地址\n\n\n# 10.7 call 和 ret 的配合使用\n\ncall 和 ret 的配合使用可以用来实现子程序的机制。call 指令在转去执行子程序之前，会将当前指令下一条指令的位置保持在栈中，当子程序执行 ret 或 retf 指令后，会用栈中的数据设置 ip 或 cs 和 ip 的值，从而转到 call 指令后面的代码处继续执行。\n\n\n# 10.8 mul 指令\n\n（1）两个相乘的数：练歌相乘的数，要么都是 8 位，要么都是 16 位。如果是 8 位，一个默认放在 al 中，另一个放在 8 位 reg 或内存字节单元中；如果是 16 位，一个默认放在 ax 中，另一个放在 16 位 reg 或内存字单元中。\n\n（2）结果：如果是 8 位乘法，结果默认放在 ax 中；如果是 16 位乘法，结果高位默认在 dx 中存放，低位在 ax 中存放。\n\n\n# 10.9 模块化程序设计\n\n> 现实问题比较复杂，对现实问题进行分析时，把它转化为相互联系、不同层次的子问题，是必须的解决方法。\n\n在高级语言中的函数或者方法就是这种思想的体现。在汇编语言中我们将高级语言中的方法或函数称之为子程序。\n\n\n# 10.10 参数和结果传递的问题\n\n当我们设计子程序时面临两个问题：\n\n（1）参数存放的位置？\n（2）计算结果存放的位置？\n\n实际上，我们可以将参数及结果存放于任何可以存储数据的地方。一般情况下，我们可以将参数存储在寄存器中，也可以存储在普通内存单元中。更一般的做法我们将其存储在栈中进行传递。\n\n\n# 10.11 寄存器冲突的问题\n\n寄存器数量是有限的，子程序中使用的寄存器，很可能在主程序中也要使用，造成了寄存器使用上的冲突。解决这个问题的简捷方法是，在子程序的开始将子程序中所有用到的寄存器中的内容都保存起来，在子程序返回前再恢复。 可以用栈来保存寄存器中的内容。\n\n栈是临时保存数据的一个比较理想的数据结构。\n\n----------------------------------------",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"第十一章 标志寄存器",frontmatter:{title:null,date:"2023-01-05T02:55:08.000Z",permalink:"/pages/3d86c5/"},regularPath:"/02.%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/02.%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/12.%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8.html",relativePath:"02.汇编语言/02.《汇编语言》第三版阅读笔记/12.第十一章 标志寄存器.md",key:"v-31c3f598",path:"/pages/3d86c5/",headers:[{level:2,title:"11.1 ZF标志",slug:"_11-1-zf标志",normalizedTitle:"11.1 zf 标志",charIndex:163},{level:2,title:"11.2 PF标志",slug:"_11-2-pf标志",normalizedTitle:"11.2 pf 标志",charIndex:390},{level:2,title:"11.3 SF标志",slug:"_11-3-sf标志",normalizedTitle:"11.3 sf 标志",charIndex:495},{level:2,title:"11.4 CF标志",slug:"_11-4-cf标志",normalizedTitle:"11.4 cf 标志",charIndex:830},{level:2,title:"11.5 OF标志",slug:"_11-5-of标志",normalizedTitle:"11.5 of 标志",charIndex:916},{level:2,title:"11.6 adc指令",slug:"_11-6-adc指令",normalizedTitle:"11.6 adc 指令",charIndex:1063},{level:2,title:"11.7 sbb指令",slug:"_11-7-sbb指令",normalizedTitle:"11.7 sbb 指令",charIndex:1442},{level:2,title:"11.8 cmp指令",slug:"_11-8-cmp指令",normalizedTitle:"11.8 cmp 指令",charIndex:1600},{level:2,title:"11.9 检测比较结果的条件转移指令",slug:"_11-9-检测比较结果的条件转移指令",normalizedTitle:"11.9 检测比较结果的条件转移指令",charIndex:2539},{level:2,title:"11.10 DF标志和串传送指令",slug:"_11-10-df标志和串传送指令",normalizedTitle:"11.10 df 标志和串传送指令",charIndex:3165},{level:2,title:"11.11 pushf 和 popf",slug:"_11-11-pushf-和-popf",normalizedTitle:"11.11 pushf 和 popf",charIndex:3770},{level:2,title:"11.12 标志寄存器在Debug中的表示",slug:"_11-12-标志寄存器在debug中的表示",normalizedTitle:"11.12 标志寄存器在 debug 中的表示",charIndex:3874}],headersStr:"11.1 ZF标志 11.2 PF标志 11.3 SF标志 11.4 CF标志 11.5 OF标志 11.6 adc指令 11.7 sbb指令 11.8 cmp指令 11.9 检测比较结果的条件转移指令 11.10 DF标志和串传送指令 11.11 pushf 和 popf 11.12 标志寄存器在Debug中的表示",content:"# 第十一章 标志寄存器\n\n标志寄存器 (Flag Register) 是我们 8086CPU14 个寄存器中最为复杂的一个。其他 13 个寄存器一般用于存放数据，整个寄存器具有一个含义。而 flag 寄存器是按位起作用的。\n\n这一章中我们主要学习 CF、PF、ZF、SF、OF、DF 等标记位，以及其相关部分指令。\n\n\n# 11.1 ZF 标志\n\nZero Flag，零标记位。用于记录相关指令执行后，其结果是否为 0。如果结果为 0，则 ZF=1，如果结果非 0，则 ZF=0。\n\n需要特别注意的是：\n\n> 在 8086 的指令集中，有的指令的执行是影响标志寄存器的，比如，add、sub、mul、div、inc、or、and 等，它们大都是运算指令（进行逻辑或算术运算）；有的指令的执行对标志寄存器没有影响，比如 mov、push、pop 等，它们大都是传送指令。\n\n\n# 11.2 PF 标志\n\nParity Flag，奇偶标记位。它用于记录相关指令执行后，其结果的所有 bit 位中 1 的个数是否为偶数。如果 1 的个数为偶数，则 pf=1，如果为奇数，则 pf=0。\n\n\n# 11.3 SF 标志\n\nSign Flag，符号标记位。它用于记录相关指令执行后，其结果是否为负。如果结果为负，则 SF=1，如果结果非负，则 SF=0。\n\n计算机中通常用补码来表示有符号数，补码在形式上与普通的无符号二进制数据并无差异。也即是说，给定的一个二进制数，我们既可以把它当做有符号数的补码形式，也可以当做一个无符号数。对于计算机来说，无论是无符号数还是有符号数的补码形式，在计算方式上并无差异（补码的符号位同样参与运算）。\n\nSF 标志，就是 CPU 对有符号数运算结果的一种记录，它记录数据的正负。在我们将数据当做有符号数来运算的时候，可以通过它来得知结果的正负。如果我们将数据当做无符号数来运算，SF 的值则没有意义，虽然相关指令影响了它的值。\n\n\n# 11.4 CF 标志\n\nCarry Flag，进位标志位。一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。\n\n\n# 11.5 OF 标志\n\nOverflow Flag，溢出标志位。在进行有符号数运算的时候，如果计算结果超出了机器所能表示的范围则发生溢出，此时 OF=1。否则，OF=0。\n\n注意区分 CF 和 OF 的区别：CF 是对无符号数运算有意义的标志位，OF 是对有符号数运算有意义的标志位。\n\n\n# 11.6 adc 指令\n\nadc 是带进位加法指令，它利用了 CF 位上记录的进位值。\n\n指令格式：\n\n> adc 操作对象 1，操作对象 2\n\n功能：操作对象 1 = 操作对象 1 + 操作对象 2+CF\n\n比如指令 adc ax,bx 实现的功能是：（ax）= （ax）+ （bx）+ CF\n\n既然我们已经有了 add 指令，那为什么还要设计 adc 指令呢？\n\n设想一下，之前我们使用 add 指令做加法运算的时候，相加结果都是 16 位以内，如果和大于 16 位就会产生误差。adc 指令目的就是对任意大的数据进行加法运算。自习观察加法运算可以得到如下规律：\n\n任意大的加法运算都可以分解为多步进行，低位相加，高位相加再加上低位相加产生的进位值，直至所有位都相加完毕。\n\n使用 adc 指令结合上述规律就可以实现对任意大的数据进行加法运算。\n\n\n# 11.7 sbb 指令\n\nsbb 是带借位减法指令，它利用了 CF 位上记录的错位值。\n\n指令格式：\n\n> sbb 操作对象 1，操作对象 2\n\n功能：操作对象 1 = 操作对象 1 - 操作对象 2-CF。\n\nsbb 指令和 adc 指令是基于同样的思想设计的两条指令，在应用思路上和 adc 指令类似。\n\n\n# 11.8 cmp 指令\n\ncmp 是比较指令，cmp 的功能相当于减法指令，只是不保存结果。cmp 指令执行后，将对标志寄存器产生影响。\n\n指令格式：\n\n> cmp 操作对象 1，操作对象 2\n\n功能：计算操作对象 1 - 操作对象 2 但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。\n\n利用 cmp ax, bx 指令对两个无符号数 ax 和 bx 进行比较，如果执行后：\n\nzf = 1，说明 (ax) = (bx)\nzf = 0，说明 (ax) ≠ (bx)\ncf = 1，说明 (ax) < (bx)\ncf = 0，说明 (ax) ≥ (bx)\ncf = 0 并且 zf = 0，说明 (ax) > (bx)\ncf = 1 或 zf = 1，说明 (ax) ≤ (bx)\n\n利用 cmp ah,bh 指令对两个有符号数 ah 和 bh 进行比较，由于有符号数的比较较为复杂，主要是考虑到溢出的特殊情景，我们分类讨论：\n\n（1） 如果 sf = 1 并且 of = 0\n\nof = 0 说明没有溢出，并且 sf = 1 说明逻辑上真正的结果为负数。所以 (ah) < (bh)。\n\n（2） 如果 sf = 1 并且 of = 1\n\nof = 1 说明存在溢出，针对补码求和来说，如果结果非 0 并且产生溢出，正确的逻辑结果符号与实际的结果符号必然相反。 sf = 1 说明实际结果为负，那么正确的逻辑结果应该为正。所以 (ah) > (bh)。\n\n（3） 如果 sf = 0 并且 of = 1\n\nof = 1 说明存在溢出，针对补码求和来说，如果结果非 0 并且产生溢出，正确的逻辑结果符号与实际的结果符号必然相反。 sf = 0 说明实际运算结果必然不小于 0，因为存在溢出所以实际运算结果必不等于 0，所以实际运算结果必然大于 0，进而推导出正确的逻辑运算结果必然小于 0。所以 (ah) < (bh)。\n\n（4） 如果 sf = 0 并且 of = 0\n\nof = 0 说明没有溢出，并且 sf = 0，说明逻辑上真正的结果为非负数。所以 (ah) ≥ (bh)。\n\n（5） 如果 zf = 1\n\n这种情形比较简单。此时 (ah) = (bh)。\n\n\n# 11.9 检测比较结果的条件转移指令\n\n“转移” 指的是它能够修改 IP，而 “条件” 指的是它可以根据某种条件，决定是否修改 IP。比如，jcxz 就是一个条件转移指令，它可以检测 cx 中的数值，如果 (cx) = 0，就修改 IP，否则什么也不做。所有条件转移指令的位移都是 [-128, 127]（即它们都是短转移）。\n\njcxz 是根据寄存器 cx 的值来判断是否转移，除此之外还存在其他条件转移指令，大多数条件转移指令都检测标志寄存器相关标志位，根据检测的结果来决定是否修改 IP。\n\n下表列出了常用的根据无符号数的比较结果进行转移的条件转移指令：\n\n指令    含义       检测的相关标志位          备注\nje    等于则转移    zf = 1            e 表示 equal\njne   不等于则转移   zf = 0            ne 表示 not eauql\njb    低于则转移    cf = 1            b 表示 below\njnb   不低于则转移   cf = 0            nb 表示 not blow\nja    高于则转移    cf = 0 且 zf = 0   a 表示 above\njna   不高于则转移   cf = 1 或 zf = 1   na 表示 not above\n\n注意，条件转移指令通常与 cmp 指令配合使用。\n\n\n# 11.10 DF 标志和串传送指令\n\nDirection Flag，方向标志位。在串传送指令中，控制每次操作后 si、di 的增减。\n\ndf = 0 ，每次操作后 si、di 递增；\ndf = 1 ，每次操作后 si、di 递减。\n\n下面，我们学习几个常见的串传送指令。（写到这里，突然想吃羊肉串了～～）\n\nmovsb 指令\n\n格式：\n\n> movsb\n\n功能：将 ds:si 指向的内存单元中的字节送入 es:di 中，并根据标志寄存器 df 的值，将 si 和 di 递增或递减。 movsw 指令\n\n与 movsb 指令类似，只不过 movsw 指令传送的是一个字单元。\n\nrep 指令\n\n本人将其翻译为重复指令（repetition）。movsb 和 movsw 进行的是串传送操作中的一个步骤，一般来说，movsb 和 movsw 都配合 rep 配合使用，格式如下：\n\n> rep movsb\n\n功能：根据 cx 的值来决定是否重复执行 movsb 操作。使用汇编语法来描述就是 >\n\n> s: movsb loop s\n\ncld 指令和 std 指令\n\ncld 指令：将标志寄存器的 df 位置 0；\nstd 指令：将标志寄存器的 df 位置 1。\n\n为了方便记忆，可以将 cld 理解为 clear direction 的缩写，将 std 理解为 set direction 的缩写。\n\n\n# 11.11 pushf 和 popf\n\npushf 的功能是将标志寄存器的值压栈，而 popf 是从栈中弹出数据，送入标志寄存器中。\n\npushf 和 popf 为直接访问标志寄存器提供了一种方法。\n\n\n# 11.12 标志寄存器在 Debug 中的表示\n\n在 Debug 中，我们使用 r 命令查看寄存器详情，第二行最后几个双字符字母即是标志寄存器中各标志位的值。\n\n----------------------------------------",normalizedContent:"# 第十一章 标志寄存器\n\n标志寄存器 (flag register) 是我们 8086cpu14 个寄存器中最为复杂的一个。其他 13 个寄存器一般用于存放数据，整个寄存器具有一个含义。而 flag 寄存器是按位起作用的。\n\n这一章中我们主要学习 cf、pf、zf、sf、of、df 等标记位，以及其相关部分指令。\n\n\n# 11.1 zf 标志\n\nzero flag，零标记位。用于记录相关指令执行后，其结果是否为 0。如果结果为 0，则 zf=1，如果结果非 0，则 zf=0。\n\n需要特别注意的是：\n\n> 在 8086 的指令集中，有的指令的执行是影响标志寄存器的，比如，add、sub、mul、div、inc、or、and 等，它们大都是运算指令（进行逻辑或算术运算）；有的指令的执行对标志寄存器没有影响，比如 mov、push、pop 等，它们大都是传送指令。\n\n\n# 11.2 pf 标志\n\nparity flag，奇偶标记位。它用于记录相关指令执行后，其结果的所有 bit 位中 1 的个数是否为偶数。如果 1 的个数为偶数，则 pf=1，如果为奇数，则 pf=0。\n\n\n# 11.3 sf 标志\n\nsign flag，符号标记位。它用于记录相关指令执行后，其结果是否为负。如果结果为负，则 sf=1，如果结果非负，则 sf=0。\n\n计算机中通常用补码来表示有符号数，补码在形式上与普通的无符号二进制数据并无差异。也即是说，给定的一个二进制数，我们既可以把它当做有符号数的补码形式，也可以当做一个无符号数。对于计算机来说，无论是无符号数还是有符号数的补码形式，在计算方式上并无差异（补码的符号位同样参与运算）。\n\nsf 标志，就是 cpu 对有符号数运算结果的一种记录，它记录数据的正负。在我们将数据当做有符号数来运算的时候，可以通过它来得知结果的正负。如果我们将数据当做无符号数来运算，sf 的值则没有意义，虽然相关指令影响了它的值。\n\n\n# 11.4 cf 标志\n\ncarry flag，进位标志位。一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。\n\n\n# 11.5 of 标志\n\noverflow flag，溢出标志位。在进行有符号数运算的时候，如果计算结果超出了机器所能表示的范围则发生溢出，此时 of=1。否则，of=0。\n\n注意区分 cf 和 of 的区别：cf 是对无符号数运算有意义的标志位，of 是对有符号数运算有意义的标志位。\n\n\n# 11.6 adc 指令\n\nadc 是带进位加法指令，它利用了 cf 位上记录的进位值。\n\n指令格式：\n\n> adc 操作对象 1，操作对象 2\n\n功能：操作对象 1 = 操作对象 1 + 操作对象 2+cf\n\n比如指令 adc ax,bx 实现的功能是：（ax）= （ax）+ （bx）+ cf\n\n既然我们已经有了 add 指令，那为什么还要设计 adc 指令呢？\n\n设想一下，之前我们使用 add 指令做加法运算的时候，相加结果都是 16 位以内，如果和大于 16 位就会产生误差。adc 指令目的就是对任意大的数据进行加法运算。自习观察加法运算可以得到如下规律：\n\n任意大的加法运算都可以分解为多步进行，低位相加，高位相加再加上低位相加产生的进位值，直至所有位都相加完毕。\n\n使用 adc 指令结合上述规律就可以实现对任意大的数据进行加法运算。\n\n\n# 11.7 sbb 指令\n\nsbb 是带借位减法指令，它利用了 cf 位上记录的错位值。\n\n指令格式：\n\n> sbb 操作对象 1，操作对象 2\n\n功能：操作对象 1 = 操作对象 1 - 操作对象 2-cf。\n\nsbb 指令和 adc 指令是基于同样的思想设计的两条指令，在应用思路上和 adc 指令类似。\n\n\n# 11.8 cmp 指令\n\ncmp 是比较指令，cmp 的功能相当于减法指令，只是不保存结果。cmp 指令执行后，将对标志寄存器产生影响。\n\n指令格式：\n\n> cmp 操作对象 1，操作对象 2\n\n功能：计算操作对象 1 - 操作对象 2 但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。\n\n利用 cmp ax, bx 指令对两个无符号数 ax 和 bx 进行比较，如果执行后：\n\nzf = 1，说明 (ax) = (bx)\nzf = 0，说明 (ax) = (bx)\ncf = 1，说明 (ax) < (bx)\ncf = 0，说明 (ax) ≥ (bx)\ncf = 0 并且 zf = 0，说明 (ax) > (bx)\ncf = 1 或 zf = 1，说明 (ax) ≤ (bx)\n\n利用 cmp ah,bh 指令对两个有符号数 ah 和 bh 进行比较，由于有符号数的比较较为复杂，主要是考虑到溢出的特殊情景，我们分类讨论：\n\n（1） 如果 sf = 1 并且 of = 0\n\nof = 0 说明没有溢出，并且 sf = 1 说明逻辑上真正的结果为负数。所以 (ah) < (bh)。\n\n（2） 如果 sf = 1 并且 of = 1\n\nof = 1 说明存在溢出，针对补码求和来说，如果结果非 0 并且产生溢出，正确的逻辑结果符号与实际的结果符号必然相反。 sf = 1 说明实际结果为负，那么正确的逻辑结果应该为正。所以 (ah) > (bh)。\n\n（3） 如果 sf = 0 并且 of = 1\n\nof = 1 说明存在溢出，针对补码求和来说，如果结果非 0 并且产生溢出，正确的逻辑结果符号与实际的结果符号必然相反。 sf = 0 说明实际运算结果必然不小于 0，因为存在溢出所以实际运算结果必不等于 0，所以实际运算结果必然大于 0，进而推导出正确的逻辑运算结果必然小于 0。所以 (ah) < (bh)。\n\n（4） 如果 sf = 0 并且 of = 0\n\nof = 0 说明没有溢出，并且 sf = 0，说明逻辑上真正的结果为非负数。所以 (ah) ≥ (bh)。\n\n（5） 如果 zf = 1\n\n这种情形比较简单。此时 (ah) = (bh)。\n\n\n# 11.9 检测比较结果的条件转移指令\n\n“转移” 指的是它能够修改 ip，而 “条件” 指的是它可以根据某种条件，决定是否修改 ip。比如，jcxz 就是一个条件转移指令，它可以检测 cx 中的数值，如果 (cx) = 0，就修改 ip，否则什么也不做。所有条件转移指令的位移都是 [-128, 127]（即它们都是短转移）。\n\njcxz 是根据寄存器 cx 的值来判断是否转移，除此之外还存在其他条件转移指令，大多数条件转移指令都检测标志寄存器相关标志位，根据检测的结果来决定是否修改 ip。\n\n下表列出了常用的根据无符号数的比较结果进行转移的条件转移指令：\n\n指令    含义       检测的相关标志位          备注\nje    等于则转移    zf = 1            e 表示 equal\njne   不等于则转移   zf = 0            ne 表示 not eauql\njb    低于则转移    cf = 1            b 表示 below\njnb   不低于则转移   cf = 0            nb 表示 not blow\nja    高于则转移    cf = 0 且 zf = 0   a 表示 above\njna   不高于则转移   cf = 1 或 zf = 1   na 表示 not above\n\n注意，条件转移指令通常与 cmp 指令配合使用。\n\n\n# 11.10 df 标志和串传送指令\n\ndirection flag，方向标志位。在串传送指令中，控制每次操作后 si、di 的增减。\n\ndf = 0 ，每次操作后 si、di 递增；\ndf = 1 ，每次操作后 si、di 递减。\n\n下面，我们学习几个常见的串传送指令。（写到这里，突然想吃羊肉串了～～）\n\nmovsb 指令\n\n格式：\n\n> movsb\n\n功能：将 ds:si 指向的内存单元中的字节送入 es:di 中，并根据标志寄存器 df 的值，将 si 和 di 递增或递减。 movsw 指令\n\n与 movsb 指令类似，只不过 movsw 指令传送的是一个字单元。\n\nrep 指令\n\n本人将其翻译为重复指令（repetition）。movsb 和 movsw 进行的是串传送操作中的一个步骤，一般来说，movsb 和 movsw 都配合 rep 配合使用，格式如下：\n\n> rep movsb\n\n功能：根据 cx 的值来决定是否重复执行 movsb 操作。使用汇编语法来描述就是 >\n\n> s: movsb loop s\n\ncld 指令和 std 指令\n\ncld 指令：将标志寄存器的 df 位置 0；\nstd 指令：将标志寄存器的 df 位置 1。\n\n为了方便记忆，可以将 cld 理解为 clear direction 的缩写，将 std 理解为 set direction 的缩写。\n\n\n# 11.11 pushf 和 popf\n\npushf 的功能是将标志寄存器的值压栈，而 popf 是从栈中弹出数据，送入标志寄存器中。\n\npushf 和 popf 为直接访问标志寄存器提供了一种方法。\n\n\n# 11.12 标志寄存器在 debug 中的表示\n\n在 debug 中，我们使用 r 命令查看寄存器详情，第二行最后几个双字符字母即是标志寄存器中各标志位的值。\n\n----------------------------------------",charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"第十二章 内中断",frontmatter:{title:null,date:"2023-01-05T02:55:08.000Z",permalink:"/pages/27a5f0/"},regularPath:"/02.%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/02.%E3%80%8A%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/13.%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E5%86%85%E4%B8%AD%E6%96%AD.html",relativePath:"02.汇编语言/02.《汇编语言》第三版阅读笔记/13.第十二章 内中断.md",key:"v-12cb66be",path:"/pages/27a5f0/",headers:[{level:2,title:"12.1 内中断的产生",slug:"_12-1-内中断的产生",normalizedTitle:"12.1 内中断的产生",charIndex:282},{level:2,title:"12.2 中断处理程序",slug:"_12-2-中断处理程序",normalizedTitle:"12.2 中断处理程序",charIndex:468},{level:2,title:"12.3 中断向量表",slug:"_12-3-中断向量表",normalizedTitle:"12.3 中断向量表",charIndex:505},{level:2,title:"12.4 中断过程",slug:"_12-4-中断过程",normalizedTitle:"12.4 中断过程",charIndex:790},{level:2,title:"12.5 中断处理程序和iret指令",slug:"_12-5-中断处理程序和iret指令",normalizedTitle:"12.5 中断处理程序和 iret 指令",charIndex:1170},{level:2,title:"12.6 除法错误中断的处理",slug:"_12-6-除法错误中断的处理",normalizedTitle:"12.6 除法错误中断的处理",charIndex:1420},{level:2,title:"12.7 编程处理0号中断",slug:"_12-7-编程处理0号中断",normalizedTitle:"12.7 编程处理 0 号中断",charIndex:1495},{level:2,title:"12.8 安装",slug:"_12-8-安装",normalizedTitle:"12.8 安装",charIndex:2187},{level:2,title:"12.9 do0",slug:"_12-9-do0",normalizedTitle:"12.9 do0",charIndex:3823},{level:2,title:"12.10 设置中断向量",slug:"_12-10-设置中断向量",normalizedTitle:"12.10 设置中断向量",charIndex:4499},{level:2,title:"12.11 单步中断",slug:"_12-11-单步中断",normalizedTitle:"12.11 单步中断",charIndex:4733},{level:2,title:"12.12 响应中断的特殊情况",slug:"_12-12-响应中断的特殊情况",normalizedTitle:"12.12 响应中断的特殊情况",charIndex:4941}],headersStr:"12.1 内中断的产生 12.2 中断处理程序 12.3 中断向量表 12.4 中断过程 12.5 中断处理程序和iret指令 12.6 除法错误中断的处理 12.7 编程处理0号中断 12.8 安装 12.9 do0 12.10 设置中断向量 12.11 单步中断 12.12 响应中断的特殊情况",content:'# 第十二章 内中断\n\n什么是中断？如果你学习过高级编程语言，可以将中断理解为异常的特殊处理过程，就像 Java 里面的 Exception。\n\n任何一个通用的 CPU，都具备一种能力，可以在执行完当前正在执行的指令之后，检测从 CPU 外部发送过来的或内部产生的一种特殊信息，并且可以立即对所收到的信息进行处理。这种特殊信息，我们可以称其为：中断信息。中断的意思是指，CPU 不在接着 (刚执行完的指令) 向下执行，而是转去处理这个特殊信息。\n\n中断信息可以来自 CPU 内部和外部，这一章，我们主要讨论来自 CPU 内部的中断信息，我们称之为内中断。\n\n\n# 12.1 内中断的产生\n\n8086CPU 使用单元字节大小的数字来标识中断类型。\n\nCPU 内部可能产生多种多样的中断，那么应该如何来标识是哪种中断呢，或者说我们如何确定中断源？\n8086CPU 用称为中断类型码的数据来标识中断信息的来源。中断类型码为一个字节型数据，可以表示 256 种中断类型。以后，我们将产生中断信息的事件，即中断信息的来源，称之为中断源。\n\n\n# 12.2 中断处理程序\n\n处理中断信息的程序被称为中断处理程序。\n\n\n# 12.3 中断向量表\n\n中断发生后，CPU 要根据中断类型码去执行对应的中断处理程序？但如何根据 8 位的中断类型码得到中断处理程序的地址呢？\n\n实际上，8086CPU 用 8 位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。中断向量表就是中断处理程序入口地址的列表，列表的下标索引（从 0 开始）即是中断类型码的值。中断向量表实际上是中断类型码与中断处理程序入口地址之间的一种映射关系。可以理解为高级编程语言中的 Map 集合。\n\n8086CPU 中断向量表指定放在内存 0 处。每个表项占用 4 个字节，高位字存放段地址，低位字存放偏移地址。\n\n\n# 12.4 中断过程\n\n用中断类型码找到中断向量，并用它设置 CS 和 IP 的值，这个工作是由 CPU 的硬件自动完成的。CPU 硬件完成这个工作的过程被称为中断过程。中断过程完成后，CPU 就会开始执行中断处理程序。中断过程可以理解为中断环境的初始化。那么在 CPU 进行中断过程中需要准备哪些工作呢？概括来说，主要进行以下六步准备工作：\n\n（1）(从中断信息中) 取得中断类型码；\n（2）标志寄存器的值入栈 (因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中)；\n（3）设置标志寄存器的第 8 位 TF 和第 9 位 IF 的值为 0 (这一步的目的后面将介绍)；\n（4）CS 的内容入栈；\n（5）IP 的内容入栈；\n（6）从内存地址为中断类型码 4 和中断类型码 4+2 的两个字单元中读取中断处理程序的入口地址设置 IP 和 CS。\n\n\n# 12.5 中断处理程序和 iret 指令\n\n中断处理程序必须一直存储在指定内存中，以应对随时可能发生的中断事件。\n\n中断处理程序的编写方法和子程序比较相似，下面是常规步骤：\n\n（1）保存用到的寄存器；\n（2）处理中断；\n（3）恢复用到的寄存器；\n（4）用 ret 指令返回。\n\niret 指令的功能用汇编语法描述为：\n\npop IP\npop CS\npopf\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n在中断过程中，注意标志寄存器入栈和出栈的次序。入栈顺序是标志寄存器、CS、IP，出栈顺序与此相反。\n\n\n# 12.6 除法错误中断的处理\n\n除法错误将引发 0 号中断。至于为何是 0 号中断，我估摸着除法中断时人们最容易想到也最容易遇到的中断了吧。\n\n\n# 12.7 编程处理 0 号中断\n\n我们的需求是重新编写一个 0 号中断处理程序，它的功能是在屏幕中间显示 “overflow!”，然后返回到操作系统。\n\n为了满足以上需求，需要做一下几件事情：\n\n（1）编写可以显示 “overflow” 的中断处理程序：do0；\n（2）将 do0 送入内存 0000:0200 处；\n（3）将 do0 的入口地址 0000:0200 存储在中断向量表 0 号表项中。\n\n程序的框架如下：\n\nassume cs:code\n\ncode segment\n\nstart:  do0安装程序\n        设置中断向量表\n        mov ax, 4c00h\n        int 21h\n\ndo0:    显示字符串"overflow"\n        mov ax, 4c00h\n        int 21h\n\ncode ends\n\nend start\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n下面摘抄书中比较精辟的一段总结：\n\n> 我们如何让一个内存单元成为栈顶？将它的地址放入 SS、SP 中；\n> 我们如何让一个内存单元中的信息被 CPU 当做指令来执行？将它的地址放入 CS、IP 中； 我们如何让一个内存单元成为要处理的数据？将它的段地址放在 DS 中；(书中无这句话，个人根据理解补充)\n> 那么，我们如何让一段程序成为 N 号中断的中断处理程序呢？将它的入口地址放入中断向量表的 N 好表项中。\n\n\n# 12.8 安装\n\n所谓安装就是将中断处理程序 (do0) 送到指定内存处。\n\n我们可以使用 movsb 指令，将 do0 的代码送入 0:200 处。复习一下 movsb 的用法：movsb 是串传送指令，其功能是将 ds:si 指向的内存单元中的字节送入 es:di 中，并根据标志寄存器 df 的值，将 si 和 di 递增或递减。movsb 指令往往与 rep 指令配合使用来实现批量字符串的传送。\n\n安装程序的框架如下所示：\n\nassume cs:code\ncode segment\n\nstart:  设置es:di指向目的地址\n        设置ds:si指向源地址\n        设置cx为传输长度\n        设置传输方向为正\n        rep movsb\n\n        设置中断向量表\n\n        mov ax, 4c00h\n        int 21h\n\ndo0:    显示字符串"overflow!"\n        mov ax, 4c00h\n        int 21h\n\ncode ends\nend start\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n以上步骤的难点在于如何确认中断处理程序 do0 的长度？最笨的方法是计算 do0 中每句代码的长度，然后累加，但这样做太麻烦了，不仅要知道每行代码所占的字节数，代码稍有改动那就令人抓狂。书中作者给出一个非常简便的计算方式，利用编译器来帮助我们计算 do0 的长度。之前我们学过 offset 指令，他的功能是取得标号的偏移地址，我们在 do0 后面在添加一个标号 do0end，使用 offset do0end - offset do0 即可计算出 do0 的长度。\n\n解决了字符传送以及确认 do0 长度这两个拦路虎后，我们就可以看一下较为完整的安装程序代码了：\n\nassume cs:code\ncode segment\nstart:  \n        mov ax, cs\n        mov ds, ax\n        mov si, offset do0        ;设置ds:si指向源地址\n        mov ax, 0\n        mov es, ax                \n        mov di, 0200h             ;设置es:di指向目标地址\n\n        mov cx, offset do0end - offset do0  ;设置cx为传输长度\n        cld                                 ;设置传输方向为正\n        rep movsb                           ;传输开始\n\n        设置中断向量表\n\n        mov ax, 4c00H\n        int 21H\n\ndo0:    显示字符串"overflow!"\n        mov ax, 4c00h\n        int 21h\ncode ends\n\nend start\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n这里补充一点，像 "+"、"-"、"*"、"/"、"offset" 这类指令都是伪指令，并不是标准的汇编指令，它是由编译器识别并由编译器翻译为对应的汇编指令。\n\n\n# 12.9 do0\n\ndo0 程序即是我们的 0 号中断处理程序。其主要目的是显示字符串 "overflow!"。\n\n主要程序代码如下所示：\n\ndo0:    jum short do0start\n        db \'overflow!\'\n\ndo0start: mov ax, cs\n          mov ds, ax\n          mov si, 202h\n\n          mov ax, 0b800h\n          mov es, ax\n          mov di, 12*160 + 36*2\n\n          mov cx, 9\n        s:mov al, [si]\n          mov es:[di], al\n          inc si\n          add di, 2\n          loop s\n\n          mov ax, 4c00h\n          int 21h\n\ndo0end:   nop\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n这部分代码需要注意的地方是，我们在子程序 do0 开始处定义了字符串 "overflow!"，但它并不是可以执行的代码，所以在 "overflow!" 之前加上一条 jmp 指令，转移到正式的 do0 程序。\n\n\n# 12.10 设置中断向量\n\n设置中断向量，也即是将中断处理程序 do0 在内存中的入口地址存放在中断向量表 0 号表项中。0 号表项的地址为 0:0，其中 0:0 字单元存放中断处理程序入口地址的偏移地址，0:2 字单元存放中断处理程序入口地址的段地址。程序如下：\n\nmov ax, 0\nmov es, ax\nmov word ptr es:[0*4], 200h\nmov word ptr es:[0*4+2], 0\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# 12.11 单步中断\n\n基本上，在 CPU 执行完一条指令之后，如果检测到标志寄存器的 TF 位为 1，则产生单步中断，引发中断过程。单步中断的中断类型码为 1。在一开始我们说 CPU 在执行中断处理程序之前要先将标志寄存器 TF 位置 0，这就是为了防止 CPU 在执行 1 号类型中断 (单步中断) 时无限递归执行中断。\n\nCPU 提供单步中断功能的出发点是，为单步跟踪程序的执行过程，提供了实现机制。\n\n\n# 12.12 响应中断的特殊情况\n\n> 一般情况下，CPU 在执行完当前指令后，如果检测到中断信息，就响应中断，引发中断过程。可是，在有些情况下，CPU 执行完当前指令后，即便是发生中断，也不会响应。例如针对 ss 修改执行后，下一条指令 (一般是修改 sp) 也会紧接着执行，中间即使发生中断，CPU 也不会去响应。这样做的主要原因是，ss:sp 联合指向栈顶，而对它们的设置应该连续完成。如果在执行完设置 ss 的指令后，CPU 响应中断，引发中断过程，要在栈中压入标志寄存器、CS 和 IP 的值，而 ss 改变，sp 并未改变，ss:sp 指向的不是正确的栈顶，将引起错误。\n\n这种理念在高级编程语言中的具体体现是 “原子操作”，即一组操作要么不执行，要么就一次执行完毕，不会存在中间状态。\n\n> 上课没有时间详细记笔记，复习阶段参考了 sanmianti/AssemblyLanguageTest，感谢。',normalizedContent:'# 第十二章 内中断\n\n什么是中断？如果你学习过高级编程语言，可以将中断理解为异常的特殊处理过程，就像 java 里面的 exception。\n\n任何一个通用的 cpu，都具备一种能力，可以在执行完当前正在执行的指令之后，检测从 cpu 外部发送过来的或内部产生的一种特殊信息，并且可以立即对所收到的信息进行处理。这种特殊信息，我们可以称其为：中断信息。中断的意思是指，cpu 不在接着 (刚执行完的指令) 向下执行，而是转去处理这个特殊信息。\n\n中断信息可以来自 cpu 内部和外部，这一章，我们主要讨论来自 cpu 内部的中断信息，我们称之为内中断。\n\n\n# 12.1 内中断的产生\n\n8086cpu 使用单元字节大小的数字来标识中断类型。\n\ncpu 内部可能产生多种多样的中断，那么应该如何来标识是哪种中断呢，或者说我们如何确定中断源？\n8086cpu 用称为中断类型码的数据来标识中断信息的来源。中断类型码为一个字节型数据，可以表示 256 种中断类型。以后，我们将产生中断信息的事件，即中断信息的来源，称之为中断源。\n\n\n# 12.2 中断处理程序\n\n处理中断信息的程序被称为中断处理程序。\n\n\n# 12.3 中断向量表\n\n中断发生后，cpu 要根据中断类型码去执行对应的中断处理程序？但如何根据 8 位的中断类型码得到中断处理程序的地址呢？\n\n实际上，8086cpu 用 8 位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。中断向量表就是中断处理程序入口地址的列表，列表的下标索引（从 0 开始）即是中断类型码的值。中断向量表实际上是中断类型码与中断处理程序入口地址之间的一种映射关系。可以理解为高级编程语言中的 map 集合。\n\n8086cpu 中断向量表指定放在内存 0 处。每个表项占用 4 个字节，高位字存放段地址，低位字存放偏移地址。\n\n\n# 12.4 中断过程\n\n用中断类型码找到中断向量，并用它设置 cs 和 ip 的值，这个工作是由 cpu 的硬件自动完成的。cpu 硬件完成这个工作的过程被称为中断过程。中断过程完成后，cpu 就会开始执行中断处理程序。中断过程可以理解为中断环境的初始化。那么在 cpu 进行中断过程中需要准备哪些工作呢？概括来说，主要进行以下六步准备工作：\n\n（1）(从中断信息中) 取得中断类型码；\n（2）标志寄存器的值入栈 (因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中)；\n（3）设置标志寄存器的第 8 位 tf 和第 9 位 if 的值为 0 (这一步的目的后面将介绍)；\n（4）cs 的内容入栈；\n（5）ip 的内容入栈；\n（6）从内存地址为中断类型码 4 和中断类型码 4+2 的两个字单元中读取中断处理程序的入口地址设置 ip 和 cs。\n\n\n# 12.5 中断处理程序和 iret 指令\n\n中断处理程序必须一直存储在指定内存中，以应对随时可能发生的中断事件。\n\n中断处理程序的编写方法和子程序比较相似，下面是常规步骤：\n\n（1）保存用到的寄存器；\n（2）处理中断；\n（3）恢复用到的寄存器；\n（4）用 ret 指令返回。\n\niret 指令的功能用汇编语法描述为：\n\npop ip\npop cs\npopf\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n在中断过程中，注意标志寄存器入栈和出栈的次序。入栈顺序是标志寄存器、cs、ip，出栈顺序与此相反。\n\n\n# 12.6 除法错误中断的处理\n\n除法错误将引发 0 号中断。至于为何是 0 号中断，我估摸着除法中断时人们最容易想到也最容易遇到的中断了吧。\n\n\n# 12.7 编程处理 0 号中断\n\n我们的需求是重新编写一个 0 号中断处理程序，它的功能是在屏幕中间显示 “overflow!”，然后返回到操作系统。\n\n为了满足以上需求，需要做一下几件事情：\n\n（1）编写可以显示 “overflow” 的中断处理程序：do0；\n（2）将 do0 送入内存 0000:0200 处；\n（3）将 do0 的入口地址 0000:0200 存储在中断向量表 0 号表项中。\n\n程序的框架如下：\n\nassume cs:code\n\ncode segment\n\nstart:  do0安装程序\n        设置中断向量表\n        mov ax, 4c00h\n        int 21h\n\ndo0:    显示字符串"overflow"\n        mov ax, 4c00h\n        int 21h\n\ncode ends\n\nend start\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n下面摘抄书中比较精辟的一段总结：\n\n> 我们如何让一个内存单元成为栈顶？将它的地址放入 ss、sp 中；\n> 我们如何让一个内存单元中的信息被 cpu 当做指令来执行？将它的地址放入 cs、ip 中； 我们如何让一个内存单元成为要处理的数据？将它的段地址放在 ds 中；(书中无这句话，个人根据理解补充)\n> 那么，我们如何让一段程序成为 n 号中断的中断处理程序呢？将它的入口地址放入中断向量表的 n 好表项中。\n\n\n# 12.8 安装\n\n所谓安装就是将中断处理程序 (do0) 送到指定内存处。\n\n我们可以使用 movsb 指令，将 do0 的代码送入 0:200 处。复习一下 movsb 的用法：movsb 是串传送指令，其功能是将 ds:si 指向的内存单元中的字节送入 es:di 中，并根据标志寄存器 df 的值，将 si 和 di 递增或递减。movsb 指令往往与 rep 指令配合使用来实现批量字符串的传送。\n\n安装程序的框架如下所示：\n\nassume cs:code\ncode segment\n\nstart:  设置es:di指向目的地址\n        设置ds:si指向源地址\n        设置cx为传输长度\n        设置传输方向为正\n        rep movsb\n\n        设置中断向量表\n\n        mov ax, 4c00h\n        int 21h\n\ndo0:    显示字符串"overflow!"\n        mov ax, 4c00h\n        int 21h\n\ncode ends\nend start\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n以上步骤的难点在于如何确认中断处理程序 do0 的长度？最笨的方法是计算 do0 中每句代码的长度，然后累加，但这样做太麻烦了，不仅要知道每行代码所占的字节数，代码稍有改动那就令人抓狂。书中作者给出一个非常简便的计算方式，利用编译器来帮助我们计算 do0 的长度。之前我们学过 offset 指令，他的功能是取得标号的偏移地址，我们在 do0 后面在添加一个标号 do0end，使用 offset do0end - offset do0 即可计算出 do0 的长度。\n\n解决了字符传送以及确认 do0 长度这两个拦路虎后，我们就可以看一下较为完整的安装程序代码了：\n\nassume cs:code\ncode segment\nstart:  \n        mov ax, cs\n        mov ds, ax\n        mov si, offset do0        ;设置ds:si指向源地址\n        mov ax, 0\n        mov es, ax                \n        mov di, 0200h             ;设置es:di指向目标地址\n\n        mov cx, offset do0end - offset do0  ;设置cx为传输长度\n        cld                                 ;设置传输方向为正\n        rep movsb                           ;传输开始\n\n        设置中断向量表\n\n        mov ax, 4c00h\n        int 21h\n\ndo0:    显示字符串"overflow!"\n        mov ax, 4c00h\n        int 21h\ncode ends\n\nend start\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n这里补充一点，像 "+"、"-"、"*"、"/"、"offset" 这类指令都是伪指令，并不是标准的汇编指令，它是由编译器识别并由编译器翻译为对应的汇编指令。\n\n\n# 12.9 do0\n\ndo0 程序即是我们的 0 号中断处理程序。其主要目的是显示字符串 "overflow!"。\n\n主要程序代码如下所示：\n\ndo0:    jum short do0start\n        db \'overflow!\'\n\ndo0start: mov ax, cs\n          mov ds, ax\n          mov si, 202h\n\n          mov ax, 0b800h\n          mov es, ax\n          mov di, 12*160 + 36*2\n\n          mov cx, 9\n        s:mov al, [si]\n          mov es:[di], al\n          inc si\n          add di, 2\n          loop s\n\n          mov ax, 4c00h\n          int 21h\n\ndo0end:   nop\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n这部分代码需要注意的地方是，我们在子程序 do0 开始处定义了字符串 "overflow!"，但它并不是可以执行的代码，所以在 "overflow!" 之前加上一条 jmp 指令，转移到正式的 do0 程序。\n\n\n# 12.10 设置中断向量\n\n设置中断向量，也即是将中断处理程序 do0 在内存中的入口地址存放在中断向量表 0 号表项中。0 号表项的地址为 0:0，其中 0:0 字单元存放中断处理程序入口地址的偏移地址，0:2 字单元存放中断处理程序入口地址的段地址。程序如下：\n\nmov ax, 0\nmov es, ax\nmov word ptr es:[0*4], 200h\nmov word ptr es:[0*4+2], 0\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# 12.11 单步中断\n\n基本上，在 cpu 执行完一条指令之后，如果检测到标志寄存器的 tf 位为 1，则产生单步中断，引发中断过程。单步中断的中断类型码为 1。在一开始我们说 cpu 在执行中断处理程序之前要先将标志寄存器 tf 位置 0，这就是为了防止 cpu 在执行 1 号类型中断 (单步中断) 时无限递归执行中断。\n\ncpu 提供单步中断功能的出发点是，为单步跟踪程序的执行过程，提供了实现机制。\n\n\n# 12.12 响应中断的特殊情况\n\n> 一般情况下，cpu 在执行完当前指令后，如果检测到中断信息，就响应中断，引发中断过程。可是，在有些情况下，cpu 执行完当前指令后，即便是发生中断，也不会响应。例如针对 ss 修改执行后，下一条指令 (一般是修改 sp) 也会紧接着执行，中间即使发生中断，cpu 也不会去响应。这样做的主要原因是，ss:sp 联合指向栈顶，而对它们的设置应该连续完成。如果在执行完设置 ss 的指令后，cpu 响应中断，引发中断过程，要在栈中压入标志寄存器、cs 和 ip 的值，而 ss 改变，sp 并未改变，ss:sp 指向的不是正确的栈顶，将引起错误。\n\n这种理念在高级编程语言中的具体体现是 “原子操作”，即一组操作要么不执行，要么就一次执行完毕，不会存在中间状态。\n\n> 上课没有时间详细记笔记，复习阶段参考了 sanmianti/assemblylanguagetest，感谢。',charsets:{cjk:!0},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3},{title:"Home",frontmatter:{home:!0,heroImage:"https://static.pil0txia.com/assets/03_3_600p.webp",heroText:"Pil0tXia 的书房",tagline:"我的学习笔记和技术分享",actionText:"开始阅读 →",actionLink:"/pages/5719ac/",bannerBg:"none",features:[{title:"知识管理",details:"包含三种典型的知识管理形态：结构化、碎片化、体系化。轻松打造知识管理平台"},{title:"简洁高效",details:"以 Markdown 为中心的项目结构，内置自动化工具，以更少的配置完成更多的事。配合多维索引快速定位每个知识点"},{title:"沉浸式阅读",details:"专为阅读设计的UI，配合多种颜色模式、可关闭的侧边栏和导航栏，带给你沉浸式阅读体验"},{title:"计算机操作系统",details:"南京信息工程大学 操作系统课程笔记 OS-Notes",link:"/pages/d1af54/"},{title:"汇编语言程序设计",details:"南京信息工程大学 汇编语言课程笔记 ASM-Notes",link:"/asm-notes/shorthand/"},{title:"More to Go",details:"不定期更新中...",link:null}],postList:"simple",simplePostListLength:9},regularPath:"/",relativePath:"index.md",key:"v-525139f4",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/01/15, 23:30:53",lastUpdatedTimestamp:1673796653e3},{title:"时间线",frontmatter:{archivesPage:!0,title:"时间线",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-35d53af0",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/01/06, 19:28:46",lastUpdatedTimestamp:1673004526e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"操作系统课程笔记",link:"/pages/5719ac/",items:[{text:"第一章 操作系统引论",link:"/pages/d1af54/"},{text:"第二章 进程的描述与控制",link:"/pages/1f0d42/"},{text:"第三章 处理机调度与死锁",link:"/pages/9cf689/"},{text:"第四章 存储器管理",link:"/pages/1253d7/"},{text:"第五章 虚拟存储器",link:"/pages/f6080a/"},{text:"期末考试备考",link:"/pages/a80c85/"}]},{text:"汇编语言课程笔记",link:"/asm-notes/shorthand/"}],sidebarDepth:4,logo:"https://static.pil0txia.com/assets/03_3_600p.webp",repo:"Pil0tXia/docs",searchMaxSuggestions:10,lastUpdated:"上次更新",sidebar:{"/01.操作系统/":[{title:"关于本文档",collapsable:!1,children:[["01.关于本文档/01.操作系统课程笔记.md","操作系统课程笔记","/pages/5719ac/"]]},{title:"第一章 操作系统引论",collapsable:!1,children:[["02.第一章 操作系统引论/02.单道批处理.md","单道批处理","/pages/d1af54/"],["02.第一章 操作系统引论/03.多道批处理.md","多道批处理","/pages/4722dd/"],["02.第一章 操作系统引论/04.并发与并行的区别.md","并发与并行的区别","/pages/d4063c/"],["02.第一章 操作系统引论/05.分时操作系统.md","分时操作系统","/pages/ed294b/"],["02.第一章 操作系统引论/06.实时操作系统.md","实时操作系统","/pages/f50a2e/"],["02.第一章 操作系统引论/07.操作系统的四个基础特性.md","操作系统的四个基础特性","/pages/bc61d3/"],["02.第一章 操作系统引论/08.现代OS的基本单位.md","现代OS的基本单位","/pages/4d01a9/"],["02.第一章 操作系统引论/09.作业1.md","作业1","/pages/ebecb5/"],["02.第一章 操作系统引论/10.内核.md","内核","/pages/5203e5/"],["02.第一章 操作系统引论/11.中断和异常.md","中断和异常","/pages/ee322f/"],["02.第一章 操作系统引论/12.系统调用.md","系统调用","/pages/1501a6/"],["02.第一章 操作系统引论/13.冷启动和热启动.md","冷启动和热启动","/pages/1fd856/"],["02.第一章 操作系统引论/14.补充资料.md","补充资料","/pages/e900d8/"],["02.第一章 操作系统引论/15.作业2.md","作业2","/pages/3f251a/"],["02.第一章 操作系统引论/16.附言.md","附言","/pages/82c444/"]]},{title:"第二章 进程的描述与控制",collapsable:!1,children:[["03.第二章 进程的描述与控制/02.程序的基本概念.md","程序的基本概念","/pages/1f0d42/"],["03.第二章 进程的描述与控制/03.进程的基本概念.md","进程的基本概念","/pages/a98e4b/"],["03.第二章 进程的描述与控制/04.作业.md","作业","/pages/ec4dab/"],["03.第二章 进程的描述与控制/05.进程控制.md","进程控制","/pages/d00b2a/"],["03.第二章 进程的描述与控制/06.进程的特征.md","进程的特征","/pages/f0811a/"],["03.第二章 进程的描述与控制/07.进程同步.md","进程同步","/pages/1da972/"],["03.第二章 进程的描述与控制/08.进程通信.md","进程通信","/pages/8c5da1/"],["03.第二章 进程的描述与控制/09.线程.md","线程","/pages/8676b4/"]]},{title:"第三章 处理机调度与死锁",collapsable:!1,children:[["04.第三章 处理机调度与死锁/02.处理机调度的层次.md","处理机调度的层次","/pages/9cf689/"],["04.第三章 处理机调度与死锁/03.队列调度模型.md","队列调度模型","/pages/053628/"],["04.第三章 处理机调度与死锁/04.选择调度算法的原则.md","选择调度算法的原则","/pages/79d126/"],["04.第三章 处理机调度与死锁/05.调度算法.md","调度算法","/pages/e86493/"],["04.第三章 处理机调度与死锁/06.死锁.md","死锁","/pages/15347c/"]]},{title:"第四章 存储器管理",collapsable:!1,children:[["05.第四章 存储器管理/02.多级存储器结构.md","多级存储器结构","/pages/1253d7/"],["05.第四章 存储器管理/03.程序的装入与链接.md","程序的装入与链接","/pages/ae65e4/"],["05.第四章 存储器管理/04.连续内存分配.md","连续内存分配","/pages/e66b46/"],["05.第四章 存储器管理/05.非连续内存分配.md","非连续内存分配","/pages/a8d561/"]]},{title:"第五章 虚拟存储器",collapsable:!1,children:[["06.第五章 虚拟存储器/01.虚拟存储器概述.md","虚拟存储器概述","/pages/f6080a/"],["06.第五章 虚拟存储器/02.请求分页存储管理方式.md","请求分页存储管理方式","/pages/9b0e23/"],["06.第五章 虚拟存储器/03.页面置换算法.md","页面置换算法","/pages/985167/"],["06.第五章 虚拟存储器/04.内存分配策略和分配算法.md","内存分配策略和分配算法","/pages/3be910/"],["06.第五章 虚拟存储器/05.抖动与工作集.md","抖动与工作集","/pages/8b5fe6/"]]},{title:"第六章 输入输出系统",collapsable:!1,children:[]},{title:"第七章 文件管理",collapsable:!1,children:[]},{title:"期末考试备考",collapsable:!1,children:[["09.期末考试备考/01.考试题型.md","考试题型","/pages/a80c85/"]]}],catalogue:{},"/02.汇编语言/":[{title:"汇编语言课程笔记",collapsable:!1,children:[["01.汇编语言课程笔记/02.课堂速记.md","课堂速记","/asm-notes/shorthand/"]]},{title:"《汇编语言》第三版阅读笔记",collapsable:!1,children:[["02.《汇编语言》第三版阅读笔记/02.第一章 基础知识.md","第一章 基础知识","/pages/e44e75/"],["02.《汇编语言》第三版阅读笔记/03.第二章 寄存器.md","第二章 寄存器","/pages/ea8c9c/"],["02.《汇编语言》第三版阅读笔记/04.第三章 寄存器（内存访问）.md","第三章 寄存器（内存访问）","/pages/252f3a/"],["02.《汇编语言》第三版阅读笔记/05.第四章 第一个程序.md","第四章 第一个程序","/pages/310d5a/"],["02.《汇编语言》第三版阅读笔记/06.第五章 [BX]和loop指令.md","第五章 [BX]和loop指令","/pages/a97f13/"],["02.《汇编语言》第三版阅读笔记/07.第六章 包含多个段的程序.md","第六章 包含多个段的程序","/pages/f2f815/"],["02.《汇编语言》第三版阅读笔记/08.第七章 更灵活的定位内存地址的方法.md","第七章 更灵活的定位内存地址的方法","/pages/a1378c/"],["02.《汇编语言》第三版阅读笔记/09.第八章 数据处理的两个基本问题.md","第八章 数据处理的两个基本问题","/pages/02c62b/"],["02.《汇编语言》第三版阅读笔记/10.第九章 转移指令的原理.md","第九章 转移指令的原理","/pages/83284e/"],["02.《汇编语言》第三版阅读笔记/11.第十章 CALL和RET指令.md","第十章 CALL和RET指令","/pages/a0c561/"],["02.《汇编语言》第三版阅读笔记/12.第十一章 标志寄存器.md","第十一章 标志寄存器","/pages/3d86c5/"],["02.《汇编语言》第三版阅读笔记/13.第十二章 内中断.md","第十二章 内中断","/pages/27a5f0/"]]}]},updateBar:{showToArticle:!1},titleBadge:!1,pageButton:!1,pageStyle:"card",category:!1,tag:!1,author:{name:"Pil0tXia",href:"https://www.pil0txia.com"},social:{icons:[{iconClass:"icon-shuben",title:"Blog",link:"https://www.pil0txia.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/Pil0tXia"},{iconClass:"icon-youjian",title:"Contact Me",link:"mailto:admin@pil0txia.com"}]},footer:{createYear:2022,copyrightInfo:'Pil0tXia | CC BY-NC-SA 4.0 Licensed | <a href="https://beian.miit.gov.cn/" target="_blank">苏ICP备2023001491号-1</a>'}}};t(240);var El=t(94),Bl=t(95),Pl=t(11);var _l={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:r}}=n;return!(e||!1===t||!0===r)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(Pl.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(Pl.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(Pl.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let r=0,a=n.length;r<a;r++){const{frontmatter:{categories:a,tags:o}}=n[r];"array"===Object(Pl.n)(a)&&a.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[r]))}),"array"===Object(Pl.n)(o)&&o.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[r]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Kt.component(El.default),Kt.component(Bl.default);function Cl(n){return n.toString().padStart(2,"0")}t(243);Kt.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,385))),Kt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,95))),Kt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,94)));t(244);var Al={render:()=>null};var wl=[{},({Vue:n,options:e,router:t,siteData:r})=>{r.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${Cl(n.getUTCMonth()+1)}-${Cl(n.getUTCDate())} ${Cl(n.getUTCHours())}:${Cl(n.getUTCMinutes())}:${Cl(n.getUTCSeconds())}`}(e)),t?n.author=t:r.themeConfig.author&&(n.author=r.themeConfig.author)}),n.mixin(_l)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?e0873ee59c9d5497473cce1b6db2e1a6";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))},({Vue:n})=>{Al.name&&n.component("ChartJS",Al),Al.name&&n.component("CodeDemo",Al),Al.name&&n.component("CodeGroup",Al),Al.name&&n.component("CodeGroupItem",Al),Promise.all([t.e(0),t.e(59)]).then(t.t.bind(null,327,7)),Al.name&&n.component("FlowChart",Al),Al.name&&n.component("Mermaid",Al),Al.name&&n.component("Presentation",Al),Promise.all([t.e(0),t.e(60)]).then(t.t.bind(null,328,7))}],Sl=[];class kl extends class{constructor(){this.store=new Kt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Kt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(kl.prototype,{getPageAsyncComponent:is,getLayoutAsyncComponent:ss,getAsyncComponent:ls,getVueComponent:cs});var Tl={install(n){const e=new kl;n.$vuepress=e,n.prototype.$vuepress=e}};function Il(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var jl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return us("pageKey",e),Kt.component(e)||Kt.component(e,is(e)),Kt.component(e)?n(e):n("")}},zl={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Ol={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Dl=(t(245),t(246),Object(gl.a)(Ol,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Fl={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Kt.config.productionTip=!1,Kt.use(Hi),Kt.use(Tl),Kt.mixin(function(n,e,t=Kt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const r=new(n(t.$vuepress.$get("siteData"))),a=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),o={};return Object.keys(a).reduce((n,e)=>(e.startsWith("$")&&(n[e]=a[e].get),n),o),{computed:o}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const r in n)"/"===r?t=n[r]:0===this.$page.path.indexOf(r)&&(e=n[r]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" - "+t:t:r||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},yl)),Kt.component("Content",jl),Kt.component("ContentSlotsDistributor",zl),Kt.component("OutboundLink",Dl),Kt.component("ClientOnly",Fl),Kt.component("Layout",ss("Layout")),Kt.component("NotFound",ss("NotFound")),Kt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.2",hash:"170cabb"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:yl.routerBase||yl.base,t=new Hi({base:e,mode:"history",fallback:!1,routes:xl,scrollBehavior:(n,e,t)=>t||(n.hash?!Kt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,r)=>{if(Il(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Il(n,t)?r(t):r()}else r();else{const t=e.path+"/",a=e.path+".html";Il(n,a)?r(a):Il(n,t)?r(t):r()}})}(t);const r={};try{await Promise.all(wl.filter(n=>"function"==typeof n).map(e=>e({Vue:Kt,options:r,router:t,siteData:yl,isServer:n})))}catch(n){console.error(n)}return{app:new Kt(Object.assign(r,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Sl.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);
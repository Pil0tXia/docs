(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{350:function(t,_,v){"use strict";v.r(_);var a=v(7),s=Object(a.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"进程控制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程控制"}},[t._v("#")]),t._v(" 进程控制")]),t._v(" "),_("p",[t._v("进程控制由 “"),_("strong",[t._v("原语")]),t._v("” 实现。原语具有 “原子性”，要么不被执行，一旦被执行，不可以被中断。")]),t._v(" "),_("p",[t._v("在"),_("strong",[t._v("关中断指令")]),t._v("下，即使有中断信号发射过来，也不会调用中断处理程序去处理中断，这就保证了原语操作不会被打断。而在"),_("strong",[t._v("开中断指令")]),t._v("下，才会去处理中断。")]),t._v(" "),_("p",[t._v("原语的基本操作包括：")]),t._v(" "),_("ul",[_("li",[t._v("更新 PCB 中的信息（修改进程状态标志、保存当前运行环境到 PCB、从 PCB 中恢复运行环境）")]),t._v(" "),_("li",[t._v("将 PCB 插入到合适的队列")]),t._v(" "),_("li",[t._v("分配 / 回收资源")])]),t._v(" "),_("p",[t._v("创建原语和撤销原语配对，阻塞原语和唤醒原语配对。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://static.pil0txia.com/picgo/IMG_20221006_104925.jpg",alt:"IMG_20221006_104925"}})]),t._v(" "),_("p",[_("img",{attrs:{src:"https://static.pil0txia.com/picgo/IMG_20221006_111051.jpg",alt:"IMG_20221006_111051"}})]),t._v(" "),_("p",[t._v("进程的执行是 “异步” 的，进程的控制是 “原子性” 的。")]),t._v(" "),_("h2",{attrs:{id:"进程的状态转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程的状态转换"}},[t._v("#")]),t._v(" 进程的状态转换")]),t._v(" "),_("h3",{attrs:{id:"三态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三态"}},[t._v("#")]),t._v(" 三态")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://static.pil0txia.com/picgo/IMG_20221006_111447.jpg",alt:"IMG_20221006_111447"}})]),t._v(" "),_("p",[t._v("阻塞态的进程不会立即转为执行态。阻塞态和就绪态的进程在内存中，执行态的进程在 CPU 中。")]),t._v(" "),_("h3",{attrs:{id:"五态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#五态"}},[t._v("#")]),t._v(" 五态")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://static.pil0txia.com/picgo/IMG_20221006_153725.jpg",alt:"IMG_20221006_153725"}})]),t._v(" "),_("p",[_("img",{attrs:{src:"https://static.pil0txia.com/picgo/image-20221006134335445.png",alt:"image-20221006134335445"}})]),t._v(" "),_("p",[t._v("创建进程的过程在内存里完成。")]),t._v(" "),_("h3",{attrs:{id:"七态-重要-在后面的章节会有所拓展"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#七态-重要-在后面的章节会有所拓展"}},[t._v("#")]),t._v(" 七态（重要，在后面的章节会有所拓展）")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://static.pil0txia.com/picgo/IMG_20221006_153249.jpg",alt:"IMG_20221006_153249"}})]),t._v(" "),_("h4",{attrs:{id:"静止阻塞-就绪队列的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#静止阻塞-就绪队列的理解"}},[t._v("#")]),t._v(" 静止阻塞 / 就绪队列的理解")]),t._v(" "),_("p",[t._v("当我们把作业从外存拿到内存时，这个过程叫做高级调度。")]),t._v(" "),_("p",[t._v("进程 PCB 被创建后，PCB 存在内存中，创建的过程在内存中实现；进程创建完成后，如果所需的资源除了内存之外都满足，则进程被对换到静止就绪队列，不参与调度，此时进程创建工作完成。")]),t._v(" "),_("p",[t._v("如果静止阻塞队列中的进程，内存资源得到满足，但是阻塞的原因仍未解除，则从静止阻塞队列进入活动阻塞队列。")]),t._v(" "),_("p",[t._v("如果静止就绪队列中的进程，内存资源得到满足，则从静止就绪队列进入活动就绪队列。")]),t._v(" "),_("h4",{attrs:{id:"挂起的原因"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#挂起的原因"}},[t._v("#")]),t._v(" 挂起的原因")]),t._v(" "),_("p",[t._v("负荷调节的需要、终端用户的请求、父进程请求、操作系统的需要")]),t._v(" "),_("h4",{attrs:{id:"挂起的特征"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#挂起的特征"}},[t._v("#")]),t._v(" 挂起的特征")]),t._v(" "),_("ul",[_("li",[t._v("该进程不能立即被执行")]),t._v(" "),_("li",[t._v("挂起进程可能会等待事件，但所等待事件是独立于挂起条件的，事件结束并不能导致进程具备执行条件")]),t._v(" "),_("li",[t._v("进程进入挂起状态是由于操作系统父进程或进程本身阻止它的运行")]),t._v(" "),_("li",[t._v("结束进程挂起状态的命令只能通过操作系统或父进程发出")])]),t._v(" "),_("h4",{attrs:{id:"状态转换的汇总"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#状态转换的汇总"}},[t._v("#")]),t._v(" 状态转换的汇总")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"center"}},[t._v("状态")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("解释")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("活动就绪态 → 静止就绪态")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("操作系统根据当前资源状况和性能要求，可能会把活动就绪态对换出去，成为静止就绪态。"),_("strong",[t._v("处于静止就绪态的进程不再被调度执行")]),t._v("；")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("静止就绪态 → 活动就绪态")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("内存中没有进程处于活动就绪态，或者处于静止就绪态的进程具有更高的优先级，那么静止就绪态就会被对换回来，此时才可能被调度执行")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("活动阻塞态→ 静止阻塞态")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("操作系统根据当前资源状况和性能要求，可能会把活动阻塞态对换出去，成为静止阻塞态。")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("静止阻塞态→ 静止就绪态")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("常见的情况是，引起进程等待的事件发生之后，相应的静止阻塞态进程将转换为静止就绪态")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("静止阻塞态→ 活动阻塞态")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("但有时候，如果"),_("strong",[t._v("静止阻塞态进程")]),t._v("的优先级高于"),_("strong",[t._v("静止就绪队列中的任何进程")]),t._v("、并且系统有把握它等待的事件即将完成，那么就会激活为活动阻塞态")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("运行态→ 静止就绪态")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("优先级较高的静止阻塞态在等待的事件完成后，可能会抢占 CPU，若此时资源不够，则可能导致正在运行的进程挂起为静止就绪态")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("创建态→ 静止就绪态")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("操作系统根据当前资源状况和性能要求，可能会在进程创建完就把它对换到外存")])])])]),t._v(" "),_("p",[t._v("进程一旦被挂起，就意味着它被对换到了外存中，此时该进程无法再被 CPU 直接调度，除非它被对换回内存中，回到活动就绪态。比如静止就绪态、静止阻塞态，最后要得到 CPU 的调度，都必须经历回归到活动就绪态的过程。")]),t._v(" "),_("h2",{attrs:{id:"进程的创建-创建原语"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程的创建-创建原语"}},[t._v("#")]),t._v(" 进程的创建（创建原语）")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://static.pil0txia.com/picgo/IMG_20221010_143627.jpg",alt:"IMG_20221010_143627"}})]),t._v(" "),_("ol",[_("li",[t._v("申请空白 PCB")]),t._v(" "),_("li",[t._v("为新进程分配其运行所需的资源")]),t._v(" "),_("li",[t._v("初始化 PCB")]),t._v(" "),_("li",[t._v("如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。如果是三态或五态，进程转入就绪态；如果是七态，储存在内存中的为活动就绪态，储存在外存中的为静止就绪态。")])]),t._v(" "),_("h2",{attrs:{id:"进程的终止-撤销原语"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程的终止-撤销原语"}},[t._v("#")]),t._v(" 进程的终止（撤销原语）")]),t._v(" "),_("p",[t._v("引起进程终止的事件包括正常结束、异常结束和外界干预。")]),t._v(" "),_("p",[t._v("终止进程的过程包括：从 PCB 集合中找到终止进程的 PCB，如果进程正在运行，则立即将它的 CPU 使用权移交给其它进程。接着终止它的所有子进程，将该进程的资源还给父进程或者操作系统，最后再删除 PCB。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://static.pil0txia.com/picgo/IMG_20221006_114004.jpg",alt:"IMG_20221006_114004"}})]),t._v(" "),_("ol",[_("li",[t._v("进入终止态的进程不能再执行")]),t._v(" "),_("li",[t._v("OS 中保留其记录（状态码 + 计时统计数据），供其他进程收集")]),t._v(" "),_("li",[t._v("一旦其他进程完成了对终止状态进程的信息提取，OS 将删除该进程")])]),t._v(" "),_("h2",{attrs:{id:"进程的阻塞-阻塞原语block"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程的阻塞-阻塞原语block"}},[t._v("#")]),t._v(" 进程的阻塞（阻塞原语 block）")]),t._v(" "),_("p",[t._v("阻塞进程的过程包括：找到要阻塞的进程的 PCB，保存当前运行环境到 PCB（方便后续恢复），修改 PCB 状态信息。接着暂停进程的运行，将 PCB 插入相应事件的阻塞队列（即改变它的链接地址）。")]),t._v(" "),_("p",[t._v("引起进程阻塞的事件一般是：")]),t._v(" "),_("ul",[_("li",[t._v("请求系统分配共享资源失败（系统已无足够的资源）")]),t._v(" "),_("li",[t._v("等待某种操作的完成。如请求系统某些服务（比如打印服务）和启动某种操作（比如 I/O 操作）")]),t._v(" "),_("li",[t._v("新数据尚未到达")]),t._v(" "),_("li",[t._v("等待新任务的到达")])]),t._v(" "),_("blockquote",[_("p",[t._v("进程从运行态切换到阻塞态是一种主动行为，这个主动体现在是进程"),_("strong",[t._v("自己调用了")]),t._v("阻塞原语。")])]),t._v(" "),_("h2",{attrs:{id:"进程的唤醒-唤醒原语wake-up"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程的唤醒-唤醒原语wake-up"}},[t._v("#")]),t._v(" 进程的唤醒（唤醒原语 wake up）")]),t._v(" "),_("p",[t._v("唤醒进程的过程包括：在事件阻塞队列中找到 PCB 并将进程移出队列，修改 PCB 的状态信息，再将 PCB 插入到就绪队列。")]),t._v(" "),_("p",[t._v("一般在等待的事件发生时，进程就会被唤醒。")]),t._v(" "),_("blockquote",[_("p",[t._v("阻塞原语和唤醒原语是一对作用刚好相反的原语，必须成对使用。进程从阻塞态切换到运行态，是一个被动的过程，这个被动体现在并不是进程"),_("strong",[t._v("自己调用了")]),t._v("唤醒原语，而是 “合作” 或相关进程进行了调用。")])]),t._v(" "),_("h2",{attrs:{id:"进程的切换-切换原语"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程的切换-切换原语"}},[t._v("#")]),t._v(" 进程的切换（切换原语）")]),t._v(" "),_("p",[t._v("前面的原语主要都是操作一个进程，而切换原语同时操作到了两个进程。")]),t._v(" "),_("p",[t._v("切换原语负责让当前运行的进程从 A 切换为 B，具体包括：")]),t._v(" "),_("ul",[_("li",[t._v("一方面，将 A 的运行环境保存到 PCB 中，再将其 PCB 移入到相应的队列（如果当前进程是从运行态到阻塞态，那么就进入阻塞队列；如果是从运行态到就绪态，那么就进入就绪队列）")]),t._v(" "),_("li",[t._v("另一方面，选择 B 进程运行，更新其 PCB，同时可能会恢复其运行环境（考虑到 B 进程此前可能曾处于阻塞态）")])]),t._v(" "),_("p",[t._v("引起进程切换的事件一般有四种：")]),t._v(" "),_("ul",[_("li",[t._v("当前进程的时间片被消耗完")]),t._v(" "),_("li",[t._v("有更高优先级的进程到达，抢占了当前进程正在使用的 CPU")]),t._v(" "),_("li",[t._v("当前进程主动阻塞")]),t._v(" "),_("li",[t._v("当前进程终止")])]),t._v(" "),_("h2",{attrs:{id:"进程的挂起-挂起原语suspend和激活原语active"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#进程的挂起-挂起原语suspend和激活原语active"}},[t._v("#")]),t._v(" 进程的挂起（挂起原语 suspend 和激活原语 active）")]),t._v(" "),_("p",[_("strong",[t._v("挂起原语：")])]),t._v(" "),_("p",[t._v("将进程从内存对换到外存，具体包括：找到需要挂起的进程的 PCB，检查它的状态并做相应操作（活动就绪态 -> 静止就绪态，活动阻塞态 -> 静止阻塞态），之后将该 PCB 复制到指定的内存区域。若被挂起的进程正在执行，则转向调度程序重新调度。")]),t._v(" "),_("p",[t._v("引起进程挂起的事件，比如用户进程请求将自己挂起，或父进程请求将自己的某个子进程挂起。")]),t._v(" "),_("p",[_("strong",[t._v("激活原语：")])]),t._v(" "),_("p",[t._v("将进程从外存对换回内存，检查该进程的现行状态并进行相应操作（静止就绪态 -> 活动就绪态，静止阻塞 -> 活动阻塞态）。")]),t._v(" "),_("p",[t._v("引起进程激活的事件，比如，父进程或用户进程请求激活指定进程，或者是某个进程驻留在外存而内存中已有足够的空间。")])])}),[],!1,null,null,null);_.default=s.exports}}]);
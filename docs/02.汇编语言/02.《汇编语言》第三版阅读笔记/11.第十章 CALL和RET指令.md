---
title: 
date: 2023-01-05 02:55:07
permalink: /pages/a0c561/
---
# **第十章 CALL和RET指令**
> call和ret都是转移指令，它们都修改IP，或同时修改CS和IP。它们经常被共同用来实现子程序的设计。

## **10.1 ret 和 retf**

这个两个指令可以理解为高级语言中的return关键字，表示程序返回。

ret 用栈中的数据，修改IP的内容，从而实现近转移；  
retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。

CPU执行ret指令时，进行下面两步操作：  

（1）(IP) = ((SS)\*16+(SP))  
（2）(sp) = (sp)+2  

以上步骤相当于进行：

> pop IP


CPU执行retf指令时，进行下面4步操作：

（1）(IP) = ((SS)\*16+(SP))  
（2）(sp) = (sp)+2  
（3）(CS) = ((SS)\*16+(SP))    
（4）(sp) = (sp)+2   

以上步骤相当于进行：

>pop IP
>pop CS

## **10.2 call 指令**

call指令可以理解为高级语言中的方法（函数）调用功能。

CPU指令call指令时，进行两步操作：

（1）将当前的IP或CS和IP压入栈中。  （保存现场）
（2）转移。

call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。

## **10.3 依据位移进行转移的call指令**

指令格式：

> call 标号

CPU执行该指令时相当于进行：

> push IP
> jmp near ptr 标号

## **10.4 转移的目的地址在指令中的call指令**

指令格式：

> call far ptr 标号

CPU执行该指令时相当于进行：

> push CS
> push IP
> jmp far ptr 标号

该指令编译的机器指令中包含了转移的目的地址。包括段地址CS的值及偏移地址IP的值。

## **10.5 转移地址在寄存器中的call指令**

指令格式：

> call 16位reg

CPU执行该指令时相当于进行：

>push IP
>jmp 16位reg

## **10.6 转移地址在内存中的call指令**

转移地址在内存中的call指令有两种格式。

（1）第一种指令格式：

>call word ptr 内存单元地址

CPU执行该指令时相当于进行：

>push IP
>jmp word ptr 内存单元地址

（2）第二种指令格式:

>call dword ptr 内存单元地址

CPU执行该指令时相当于进行：

>push CS
>push IP
>jmp dword ptr 内存单元地址

## **10.7 call和ret的配合使用**

call和ret的配合使用可以用来实现子程序的机制。call指令在转去执行子程序之前，会将当前指令下一条指令的位置保持在栈中，当子程序执行ret或retf指令后，会用栈中的数据设置ip或cs和ip的值，从而转到call指令后面的代码处继续执行。

## **10.8 mul指令**

（1）两个相乘的数：练歌相乘的数，要么都是8位，要么都是16位。如果是8位，一个默认放在AL中，另一个放在8位reg或内存字节单元中；如果是16位，一个默认放在AX中，另一个放在16位reg或内存字单元中。

（2）结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认在DX中存放，低位在AX中存放。

## **10.9 模块化程序设计**

>现实问题比较复杂，对现实问题进行分析时，把它转化为相互联系、不同层次的子问题，是必须的解决方法。

在高级语言中的函数或者方法就是这种思想的体现。在汇编语言中我们将高级语言中的方法或函数称之为子程序。

## **10.10 参数和结果传递的问题**

当我们设计子程序时面临两个问题：

（1）参数存放的位置？  
（2）计算结果存放的位置？  

实际上，我们可以将参数及结果存放于任何可以存储数据的地方。一般情况下，我们可以将参数存储在寄存器中，也可以存储在普通内存单元中。更一般的做法我们将其存储在栈中进行传递。

## **10.11 寄存器冲突的问题**

寄存器数量是有限的，子程序中使用的寄存器，很可能在主程序中也要使用，造成了寄存器使用上的冲突。解决这个问题的简捷方法是，**在子程序的开始将子程序中所有用到的寄存器中的内容都保存起来，在子程序返回前再恢复。** 可以用栈来保存寄存器中的内容。

栈是临时保存数据的一个比较理想的数据结构。


---


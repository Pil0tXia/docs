---
title: 
date: 2023-01-05 02:55:07
permalink: /pages/a1378c/
---
# **第七章 更灵活的定位内存地址的方法**
本章主要讲不同的寻址方式。

## **7.1 and和or指令**

and表示逻辑与。or表示逻辑或。

## **7.2 关于ASCII码**

ASCII码：American Standard Code for Information Interchange，美国信息交换标准代码。用8位（一个字节）二进制数表示一个字符。起初定义了128个字符，后来扩展至256个。

当我们再键盘上按下字母a键，屏幕上显示a字母，这其中经历了哪些过程？

1. a被ASCII编码为数字61H存储在指定内存空间内。
2. 文本编辑器软件从内存中取出61H,将其送入显卡显存中。
3. 显卡根据ASCII编码将61H反译为字母a，同时显卡驱动显示器，将字母a的图像画在屏幕上。

通过以上3步，我们就看到了字母a被显示在屏幕上。

## **7.3 以字符形式给出的数据**

在汇编程序中，使用引号‘’括起来的内容被识别为字符，编译器将把它转换为对应的ASCII码。

## **7.4 大小写转换的问题**

在ASCII码中，小写字母的对应范围为：61H - 7AH。大写字母的对应范围为：41H - 5AH。可见同一个字母的大写形式的ASCII码比小写形式的ASCII码小20H。

仔细观察大小写字母所对应的ASCII吗二进制形式，可以发现如下规律：大写字母从右数第6位（从1开始计算）全为0，小写字母从右数第6位全为1。

综上我们可以总结出大小写转换的两种方式：

**字母大小写转换方式1：**

1. 大写字母加上20h可转换为小写字母。
2. 小写字母减去20h可转换为大写字母。

**字母大小写转换方式2：**

1. 字母转大写：逻辑与11011111B。
2. 字母转小写：逻辑或00100000B。

## **7.5 [bx+idata]**

这是一种"变量+常量"的寻址方式。

[bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata。  
指令:

```c
mov ax, [bx+200]
```

表示将一个内存单元的内容送入ax，这个内存单元的长度为2个字节（字单元），存放一个字，偏移地址为bx中的数值加上200，段地址在ds中。

该指令的常用格式有：

```c
mov ax, [bx+200]
mov ax, 200[bx]
mov ax, [bx].200
```

## **7.6 用[bx+idata]的方式进行数组的处理**

我们可以将地址连续的多个数据当做数组处理。例如定义如下数据：

```c
datasg segment
  db 'BaSiC'
  db 'MinIX'
datasg ends
```

我们可以把如上两个字符串当做两个数组，一个数组下标从0开始，一个数组下标从5开始。在程序中使用[bx+0]和[bx+5]的方式定位两个字符串的首地址。从而可以在一个循环当中同时处理两组数据。

回忆我们在高级语言中用到的数组取值方式(如c或java)：a[index]。可以看出这就是汇编语言中[bx+idata]形式的变种。a与idata相对应，是一常量，表示了数组的首地址。而下标index与bx对应，是一变量，表示数组下标。

## **7.7 SI和DI**

SI是Source Index的缩写。DI是Destination Index的缩写。它俩的功能与bx相近，但SI和DI不能够分成两个8位寄存器来使用。下面三组指令实现了相同的功能：

```c
;(1)
mov bx, 0
mov ax, [bx]

;(2)
mov si, 0
mov ax, [si]

;(3)
mov di, 0
mov ax, [di]
```

下面的三组指令也实现了相同的功能：

```c
;(1)
mov bx, 0
mov ax, [bx+123]

;(2)
mov si, 0
mov ax, [si+123]

;(3)
mov di, 0
mov ax, [di+123]
```

## **7.8 [bx+si]和[bx+di]**

这是一种“变量+变量”的寻址方式。

[bx+si]和[bx+di]含义相似，都是表示一个内存单元。该内存单元的段地址位于ds中，偏移地址为bx的值加上si的值（或bx的值加上di的值）。

该指令的常用格式有：

```c
mov ax, [bx+si]
mov ax, [bx][si]
```

## **7.9 [bx+si+idata]和[bx+di+idata]**

这是一种"变量+变量+常量"的寻址方式。

常用指令格式：

```c
mov ax, [bx+200+si]
mov ax, [200+bx+si]
mov ax, 200[bx][si]
mov ax, [bx].200[si]
mov ax, [bx][si].200
```

## **7.10 不同的寻址方式的灵活应用**

总结一下前面讲到的几种定位内存地址的方法（寻址方式）：

（1）[idata]用一个常量来表示地址，可用于直接定位一个内存单元；  
（2）[bx]用一个变量来表示内存地址，可用于间接定位一个内存单元；  
（3）[bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；  
（4）[bx+si]用两个变量表示地址；  
（5）[bx+si+idata]用两个变量和一个常量表示地址。


下一章中，我们将对寻址方式的问题进行更深入的探讨，之所以如此重视这个问题，是因为寻址方式的适当应用，使我们可以以更合理的结构来看待所要处理的数据。而**为所要处理的看似杂乱的数据设计一种清晰的数据结构是程序设计的一个关键问题**（个人认为这段话说的很有道理，特记录于此）

---

